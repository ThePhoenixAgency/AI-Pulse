<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>A 0-click exploit chain for the Pixel 9 Part 2: Cracking the Sandbox with a Big Wave</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.8; color: #e2e8f0; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.5em; }
  .metadata { color: #94a3b8; font-size: 0.9em; margin-bottom: 2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 1em; }
  img { max-width: 100%; height: auto; border-radius: 8px; }
  a { color: #00d9ff; }
  p { margin-bottom: 1em; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 15px; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 15px; border-radius: 6px; overflow-x: auto; }
</style>
</head>
<body>
  <h1>A 0-click exploit chain for the Pixel 9 Part 2: Cracking the Sandbox with a Big Wave</h1>
  <div class="metadata">
    Source: Google Project Zero | Date: 1/14/2026 | Lang: EN |
    <a href="https://projectzero.google/2026/01/pixel-0-click-part-2.html" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div>
      <article>
        
        <section>
          <p>With the advent of a potential Dolby Unified Decoder RCE exploit, it seemed prudent to see what kind of Linux kernel drivers might be accessible from the resulting userland context, the <code>mediacodec</code> context. <a href="https://source.android.com/docs/core/media/framework-hardening?authuser=1#mediacodecservice_changes">As per the AOSP documentation</a>, the <code>mediacodec</code> SELinux context is intended to be a constrained (a.k.a sandboxed) context where non-secure software decoders are utilized. Nevertheless, using my DriverCartographer tool, I discovered an interesting device driver, <code>/dev/bigwave</code> that was accessible from the <code>mediacodec</code> SELinux context. BigWave is hardware present on the Pixel SOC that accelerates AV1 decoding tasks, which explains why it is accessible from the <code>mediacodec</code> context. <a href="https://googleprojectzero.blogspot.com/2024/12/qualcomm-dsp-driver-unexpectedly-excavating-exploit.html">As</a> <a href="https://googleprojectzero.blogspot.com/2024/06/driving-forward-in-android-drivers.html">previous</a> <a href="https://googleprojectzero.blogspot.com/2023/09/analyzing-modern-in-wild-android-exploit.html">research</a> <a href="https://project-zero.issues.chromium.org/issues/380081941">has</a> <a href="https://project-zero.issues.chromium.org/issues/42451599">copiously</a> <a href="https://project-zero.issues.chromium.org/issues/389724938">affirmed</a>, Android drivers for hardware devices are prime places to find powerful local privilege escalation bugs. The BigWave driver was no exception - across a couple hours of auditing the code, I discovered three separate bugs, including one that was powerful enough to escape the <code>mediacodec</code> sandbox and get kernel arbitrary read/write on the Pixel 9. 
</p>
<h2>The (Very Short) Bug Hunt</h2>

<p><a href="https://project-zero.issues.chromium.org/u/1/issues/425917200">The first bug I found</a> was a duplicate that was originally reported in February of 2024 but remained unfixed at the time of re-discovery in June of 2025, over a year later, despite the bugfix being a transposition of two lines of code. <a href="https://project-zero.issues.chromium.org/u/1/issues/426548270">The second bug</a> presented a really fascinating bug-class that is analogous to the double-free kmalloc exploitation primitive - but with a different linked list entirely. However it was the <a href="https://project-zero.issues.chromium.org/issues/426567975">third bug</a> I discovered that created the nicest exploitation primitive. Fixes were made available for all three bugs on January 5, 2026.</p>

<h2>The Nicest Bug</h2>

<p>Every time the <code>/dev/bigwave</code> device is opened, the driver allocates a new kernel struct called <code>inst</code> which is stored in the <code>private_data</code> field of the <code>fd</code>. Within the <code>inst</code> is a sub-struct called <code>job</code>, which tracks the register values and status associated with an individual invocation of the BigWave hardware to perform a task. In order to submit some work to the bigo hardware, a process uses the ioctl <code>BIGO_IOCX_PROCESS</code>, which fetches Bigwave register values from the ioctl caller in AP userland, and places the <code>job</code> on a queue that gets picked up and used by a separate thread, the bigo worker thread. That means that an object whose lifetime is inherently bound to a file descriptor is transiently accessed on a separate kernel thread that isn’t explicitly synced to the existence of that file descriptor. During <code>BIGO_IOCX_PROCESS</code> ioctl handling, after submitting a <code>job</code> to get executed on <code>bigo_worker_thread</code>, the ioctl call enters <code>wait_for_completion_timeout</code> with a timeout of 16 seconds waiting for <code>bigo_worker_thread</code> to complete the job. After those 16 seconds, if <code>bigo_worker_thread</code> has not signaled job completion, the timeout period ends and the ioctl dequeues the <code>job</code> from the priority queue. However, if a sufficient number of previous jobs were stacked onto the <code>bigo_worker_thread</code>, it is possible that <code>bigo_worker_thread</code> was so delayed that it has only just dequeued and is concurrently processing the very <code>job</code> that the ioctl has considered to have timed out and is trying to dequeue. The syscall context in this case simply returns back to userland, and if at this point userland closes the <code>fd</code> associated with the BigWave instance, the <code>inst</code> (and thusly the <code>job</code>) is destroyed while <code>bigo_worker_thread</code> continues to reference the <code>job</code>.</p>

<p>The highlights indicate any accesses to the UAF’d object:</p>

<div><pre><code><span>static</span> <span>int</span> <span>bigo_worker_thread</span><span>(</span><span>void</span> <span>*</span><span>data</span><span>)</span>
<span>{</span>
	<span>...</span>

	<span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
		<span>rc</span> <span>=</span> <span>wait_event_timeout</span><span>(</span><span>core</span><span>-&gt;</span><span>worker</span><span>,</span>
			<span>dequeue_prioq</span><span>(</span><span>core</span><span>,</span> <span>&amp;</span><span>job</span><span>,</span> <span>&amp;</span><span>should_stop</span><span>),</span>
			<span>msecs_to_jiffies</span><span>(</span><span>BIGO_IDLE_TIMEOUT_MS</span><span>));</span> <span>//The job is fetched from the queue</span>
		<span>...</span>

		<span>inst</span> <span>=</span> <span>container_of</span><span>(</span><span>job</span><span>,</span> <span>struct</span> <span>bigo_inst</span><span>,</span> <span>job</span><span>);</span> <span>//The job is an inline struct inside of the inst which gets UAF'd</span>

		<span>...</span>

		<span>rc</span> <span>=</span> <span>bigo_run_job</span><span>(</span><span>core</span><span>,</span> <span>job</span><span>);</span>

		<span>...</span>
		<span><u>job</u></span><span>-&gt;</span><span>status</span> <span>=</span> <span>rc</span><span>;</span>
		<span>complete</span><span>(</span><span>&amp;</span><span><u>inst</u></span><span>-&gt;</span><span>job_comp</span><span>);</span>
	<span>}</span>
	<span>return</span> <span>0</span><span>;</span>
<span>}</span>

<span>...</span>

<span>static</span> <span>int</span> <span>bigo_run_job</span><span>(</span><span>struct</span> <span>bigo_core</span> <span>*</span><span>core</span><span>,</span> <span>struct</span> <span>bigo_job</span> <span>*</span><span>job</span><span>)</span>
<span>{</span>
	<span>...</span>

	<span>inst</span> <span>=</span> <span>container_of</span><span>(</span><span>job</span><span>,</span> <span>struct</span> <span>bigo_inst</span><span>,</span> <span>job</span><span>);</span>
	<span>bigo_bypass_ssmt_pid</span><span>(</span><span>core</span><span>,</span> <span>inst</span><span>-&gt;</span><span>is_decoder_usage</span><span>);</span>
	<span>bigo_push_regs</span><span>(</span><span>core</span><span>,</span> <span>job</span><span>-&gt;</span><span>regs</span><span>);</span> <span>//The register values of the bigwave processor are set (defined by userland)</span>
	<span>bigo_core_enable</span><span>(</span><span>core</span><span>);</span>
	<span>ret</span> <span>=</span> <span>wait_for_completion_timeout</span><span>(</span><span>&amp;</span><span>core</span><span>-&gt;</span><span>frame_done</span><span>,</span>
			<span>msecs_to_jiffies</span><span>(</span><span>core</span><span>-&gt;</span><span>debugfs</span><span>.</span><span>timeout</span><span>));</span> <span>//pause for 1 second</span>
	<span>...</span>
        <span>//At this point inst/job have been freed</span>
	<span>bigo_pull_regs</span><span>(</span><span>core</span><span>,</span> <span><u>job</u></span><span>-&gt;</span><span>regs</span><span>);</span> <span>//A pointer is taken directly from the freed object</span>
	<span>*</span><span>(</span><span>u32</span> <span>*</span><span>)(</span><span><u>job</u></span><span>-&gt;</span><span>regs</span> <span>+</span> <span>BIGO_REG_STAT</span><span>)</span> <span>=</span> <span>status</span><span>;</span>
	<span>if</span> <span>(</span><span>rc</span> <span>||</span> <span>ret</span><span>)</span>
		<span>rc</span> <span>=</span> <span>-</span><span>ETIMEDOUT</span><span>;</span>
	<span>return</span> <span>rc</span><span>;</span>
<span>}</span>
</code></pre></div>

<div><pre><code><span>void</span> <span>bigo_pull_regs</span><span>(</span><span>struct</span> <span>bigo_core</span> <span>*</span><span>core</span><span>,</span> <span>void</span> <span>*</span><span>regs</span><span>)</span>
<span>{</span>
	<span>memcpy_fromio</span><span>(</span><span>regs</span><span>,</span> <span>core</span><span>-&gt;</span><span>base</span><span>,</span> <span>core</span><span>-&gt;</span><span>regs_size</span><span>);</span> <span>//And the current register values of the bigwave processor are written to that location</span>
<span>}</span>
</code></pre></div>

<p>By spraying attacker-controlled <code>kmalloc</code> allocations (for example via Unix Domain Socket messages) we can control the underlying UAF pointer <code>job-&gt;regs</code>, so we can control the destination of our write. Additionally since we set the registers at the beginning of execution, by setting the registers in such a way that the BigWave processor does not execute at all, we can ensure that the end register state is nearly identical to the original register state - hence we can control what is written as well. And just like that, we have a half decent 2144-byte arbitrary write! And all without leaking the KASLR slide!<br />
<img alt="" /></p>

<h2>Defeating KASLR (by doing nothing at all)</h2>

<p>Exploiting this issue with KASLR enabled would normally involve reallocating some other object over the bigo <code>inst</code> with a pointer at the location of <code>inst-&gt;job.regs</code>, leading to memory corruption of the object pointed to by that overlapped pointer. That would require finding some allocatable object with a pointer at that location, and also finding a way to take advantage of being able to overwrite the sub-object. Finding such an object is difficult but not impossible, especially if you consider cross-cache attacks. It is, however, quite tedious and is not really my idea of a fun time. Thankfully I found a much simpler strategy which essentially allows the generic bypass of KASLR on Pixel in its entirety, the details of which you can read about in <a href="https://googleprojectzero.blogspot.com/2025/11/defeating-kaslr-by-doing-nothing-at-all.html">my previous blog post</a>. The end-result of that sidequest is the discovery that instead of needing to leak the KASLR base, you can just use <code>0xffffff8000010000</code> instead, particularly when it comes to overwriting .data in the kernel. This dramatically simplifies the exploit, and substantially improves the exploit’s potential reliability.</p>

<h2>Creating an arbitrary read/write</h2>

<p>At this point, I have a mostly-arbitrary write primitive anywhere in kernel .data - I have an aliased location for, and can modify, any kernel globals I want. However the <code>complete</code> call at the end of the <code>bigo_worker_thread</code> job execution loop serves to complicate exploitation a little bit. <code>complete</code> calls <code>swake_up_locked</code> which performs a set of list operations on a <code>list_head</code> node inside of the bigo <code>inst</code>:</p>

<div><pre><code><span>static</span> <span>inline</span> <span>int</span> <span>list_empty</span><span>(</span><span>const</span> <span>struct</span> <span>list_head</span> <span>*</span><span>head</span><span>)</span>
<span>{</span>
<span>return</span> <span>READ_ONCE</span><span>(</span><span>head</span><span>-&gt;</span><span>next</span><span>)</span> <span>==</span> <span>head</span><span>;</span>
<span>}</span>

<span>void</span> <span>swake_up_locked</span><span>(</span><span>struct</span> <span>swait_queue_head</span> <span>*</span><span>q</span><span>)</span> <span>//The q is located at &amp;inst-&gt;job_comp.wait (so attacker controlled)</span>
<span>{</span>
	<span>struct</span> <span>swait_queue</span> <span>*</span><span>curr</span><span>;</span>

	<span>if</span> <span>(</span><span>list_empty</span><span>(</span><span>&amp;</span><span>q</span><span>-&gt;</span><span>task_list</span><span>))</span>
		<span>return</span><span>;</span>

	<span>curr</span> <span>=</span> <span>list_first_entry</span><span>(</span><span>&amp;</span><span>q</span><span>-&gt;</span><span>task_list</span><span>,</span> <span>typeof</span><span>(</span><span>*</span><span>curr</span><span>),</span> <span>task_list</span><span>);</span>
	<span>wake_up_process</span><span>(</span><span>curr</span><span>-&gt;</span><span>task</span><span>);</span>
	<span>list_del_init</span><span>(</span><span>&amp;</span><span>curr</span><span>-&gt;</span><span>task_list</span><span>);</span>
<span>}</span>
</code></pre></div>

<p>While the first <code>list_empty</code> call would be the simplest to forge, it would also require knowing the location of the <code>inst</code> in kernel memory as <code>q</code> is an inline struct inside of <code>inst</code>. Unfortunately, our KASLR bypass does not give us this, nor is it particularly easy to acquire, as the <code>inst</code> is in kernel heap, not kernel .data. That means we need to instead forge a valid list entry for the <code>q</code> to point to as well as know the location of a task to pass to <code>wake_up_process()</code>. Finally we need to actually forge enough of a list to survive a <code>list_del_init</code> on an entry in the <code>q-&gt;task_list</code>, which involves list nodes, and second list nodes that point to the first list node. This might sound quite difficult to forge given the limitation we’ve previously noted about our KASLR bypass, but in fact, it’s not so bad, since our arbitrary write has already happened by this point - so we know the location of memory that we control <strong>somewhere</strong> in kernel .data. This means we can forge arbitrary list nodes within that space in .data, and we can place pointers to those future forged list nodes in the original heap spray we use to replace the <code>inst</code>. We ALSO know the location of a single task struct in the kernel virtual address space - the <code>init</code> task! <code>init</code>’s task struct is in the kernel .data, so we can reference it through the linear map. A spurious <code>wake_up_process</code> on the <code>init_task</code> will be entirely inconsequential while avoiding a crash. You can see the code to set up these linked list nodes in <code>setup_linked_list</code> in the exploit.</p>

<p>With that roadblock resolved, it’s time to figure out what in .data to target with our arbitrary write. Our goal is to change our unreliable arbitrary write of 2144 bytes to a reliable arbitrary read/write that causes significantly less collateral damage to the memory around it. I decided to try <a href="https://googleprojectzero.blogspot.com/2023/09/analyzing-modern-in-wild-android-exploit.html#:~:text=Stabilizing%20The%20Arbitrary%20Write">reimplementing the strategy I reversed from an ITW exploit a couple years ago</a>. This technique involves creating a type-confusion by replacing some of the VFS/fops handlers in the <code>ashmem_misc</code> data structure with other VFS handlers for other file types. In fact, because of CFI you cannot replace the handler function pointers with pointers to just any location in the kernel .text. You must replace the VFS handlers with <strong>other</strong> VFS handlers. Rather conveniently however, I can use configfs VFS handlers for my exploit, just like the ITW exploit. The final layout of the fops table and <code>private_data</code> of the <code>struct file</code> look like this:<br />
<img alt="" /></p>

<p>The fops handlers in green will access the <code>private_data</code> structure as a <code>struct</code> <code>ashmem_area</code>, or <code>asma</code>, while the fops handlers in yellow access the same <code>private_data</code> structure as a <code>configfs</code> buffer. For the <code>configfs</code> fops handlers, the memory pointed to by <code>page</code> will be accessed - that is where we will want our arbitrary read/write to read or write. We will set our target using the <code>ASHMEM_SET_NAME</code> ioctl.</p>

<p>One additional complication however, is that the linear mapping of the kernel .text is not executable, so I can’t use .text region linear map addresses to the VFS handlers when forging my <code>ashmem_misc</code> data structure. In practice, it’s not particularly difficult to leak the actual KASLR slide. Before targeting <code>ashmem_misc</code>, I first use my arbitrary write to target the <code>sel_fs_type</code> object in the kernel .data. This structure has a string, name, that is printed when reading <code>/proc/self/mounts</code>. By replacing that string pointer using my arbitrary write, and then reading <code>/proc/self/mounts</code>, I can turn my unreliable arbitrary write into an arbitrary read instead! Using this arbitrary read, I can read the <code>ashmem_fops</code> structure (also through the linear map) which gives me pointers at an offset from the kernel base, allowing me to calculate the KASLR slide.</p>

<p>I then perform my arbitrary write again to overwrite the <code>ashmem_misc</code> structure with a pointer to a new forged <code>ashmem_fops</code> table that I construct at the same time - such is the perk of overwriting far more data than I need.</p>

<p>However, the astute among you may have realized that this massive 2144 byte arbitrary write has a major drawback too, as such a large write will clobber all of the data surrounding whatever I’m actually targeting with the write - this could lead to all sorts of extraneous crashes and kernel panics. In practice, spurious crashing can occur, but the phone is surprisingly quite stable. My experience was that it seemed to crash upon toggling the wifi on/off - but otherwise the phone seems to work mostly fine.</p>

<p>Once the forged <code>ashmem_misc</code> structure has been inserted, we now have a perfectly reliable arbitrary read/write, albeit with the phone extraneously crashing sometimes. Upon getting arb read/write, I set SELinux to permissive (just flip the flag in the <code>selinux_state</code> kernel object), fork off a new process, then use my arb read/write to point the new process’s task creds to <code>init_cred</code>. At this point, I now have a process with root credentials, and SELinux disabled.</p>

<h2>Integrating into the Dolby exploit</h2>

<p>Combining two exploits into one chain requires a fair amount of engineering effort from both exploits. The Dolby exploit will be delivering the Bigwave exploit as a shellcode payload, (patched into the process using <code>/proc/self/mem</code>) so I need to convert my exploit to work as a binary blob. It also needs to be <strong>much</strong> smaller than my static compilation environment supported. The lowest hanging fruit was to remove the static libc requirement and have the exploit include wrappers for all the syscalls and libc functions it needs. When I set about to complete this rather tedious task, I realized that this is something an LLM would probably be quite good at. So instead of implementing the sycall wrappers myself, I simply copy-pasted my source code into Gemini and asked it to create the needed header file of syscall wrappers for me. Naturally the AI-generated header file caused many compilation errors (as it surely would have if I had tried to do it too). I took those compilation errors, gave them back to the same Gemini window, and asked it to amend the header file to resolve those errors. The amended header file caused gcc to emit whole new and exciting compilation failures - but the errors looked different than before, so I simply repeated the process. After 4 or 5 attempts, Gemini was able to generate a header file that not only compiled - it worked perfectly. This provides some insight into how attackers might be able to use (or more likely are already using) LLMs to make their exploit process more efficient.</p>

<p>This effort results in a much smaller ELF than before (7 KB instead of 500 KB) but just an ELF is not enough - I need the generated blob to work if the dolby exploit simply starts executing from the top of the shellcode. The good news however is that my exploit can operate entirely without a linker - all that is necessary is to prepend a jump to the ELF that sets the PC to the entrypoint. I also include “-mcmodel=tiny -fPIC -pie” in the gcc arguments so that the generated code will work agnostic to the shellcode’s location or alignment in memory.</p>

<h2>Finalizing the exploit</h2>

<p>Kernel arbitrary read/write is motivating enough as a security researcher to demonstrate the impact of the vulnerability, but it seemed incumbent to create some more accessible demo in order to demonstrate impact more broadly. I added code so that the exploit executed an included shell script, then wrote a shell script that took a picture and sent that picture back to an arbitrary IP address.</p>

<p>In the <a href="https://projectzero.google/2026/01/pixel-0-click-part-3.html">final part</a> of this blog series, we will discuss what lessons we learned from this research.</p>


        </section>
      </article>
      
      
    </div></div>
  </div>
</body>
</html>