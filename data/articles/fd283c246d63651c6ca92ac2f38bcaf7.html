<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Introducing Apache Fory C++: Blazing-Fast, Type-Safe Serialization for Modern C++ | Apache Fory</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Introducing Apache Fory C++: Blazing-Fast, Type-Safe Serialization for Modern C++ | Apache Fory</h1>
  <div class="metadata">
    Source: Hacker News Show | Date: 2/18/2026 5:45:10 PM | <a href="https://fory.apache.org/blog/fory_cpp_blazing_fast_serialization_framework/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div><p><strong>TL;DR</strong>: Apache Fory C++ is a blazing-fast, cross-language serialization framework delivering <strong>exceptional binary performance</strong> with support for <strong>polymorphic types, circular references, schema evolution, and seamless interoperability</strong> with Java, Python, Go, Rust, and JavaScript — all via modern C++17 with zero runtime reflection overhead.</p>
<ul>
<li> GitHub: <a href="https://github.com/apache/fory" target="_blank">https://github.com/apache/fory</a></li>
<li> Docs: <a href="https://fory.apache.org/docs/guide/cpp" target="_blank">https://fory.apache.org/docs/guide/cpp</a></li>
</ul>
<p><img src="https://fory.apache.org/img/fory-logo-light.png"></p><hr>
<h2>The C++ Serialization Problem<a href="#the-c-serialization-problem">​</a></h2>
<p>Every C++ developer working in a polyglot environment eventually hits the same wall. Existing options force a painful choice:</p>
<ol>
<li><strong>IDL-first frameworks</strong> (Protocol Buffers, FlatBuffers): Require upfront schema compilation, lose native C++ type expressiveness, and carry significant integration friction. Every type change means regenerating code across all languages in lock-step.</li>
<li><strong>Reflection-based frameworks</strong> (Boost.Serialization, cereal): Limited cross-language support, no circular reference handling, no polymorphism without boilerplate. They work well within a single language but break down at system boundaries.</li>
<li><strong>Hand-rolled binary formats</strong>: Fast but brittle — any schema change risks silent corruption, and every new type requires manual encode/decode logic.</li>
</ol>
<p>Apache Fory C++ eliminates this trade-off. It delivers performance competitive with the fastest C++ serialization libraries while providing first-class support for polymorphism, shared/circular references, schema evolution, and <strong>binary compatibility with Java, Python, Go, Rust, and JavaScript</strong> — through a clean C++17 API.</p>
<hr>
<h2>What Makes Apache Fory C++ Different?<a href="#what-makes-apache-fory-c-different">​</a></h2>
<h3>Compile-Time Code Generation<a href="#compile-time-code-generation">​</a></h3>
<p>Most serialization frameworks pay a runtime cost for flexibility — inspecting type information through virtual dispatch or hash maps at every call. Apache Fory takes a different approach: the <code>FORY_STRUCT</code> macro uses C++ template metaprogramming to generate all serialization logic at compile time. The result is inlined, type-specific code with no virtual dispatch, no reflection, and no runtime overhead:</p>
<div><pre><code><span><span>#</span><span>include</span><span> </span><span>"fory/serialization/fory.h"</span><span></span><br></span><span><span></span><span>using</span><span> </span><span>namespace</span><span> fory</span><span>::</span><span>serialization</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>Person</span><span> </span><span>{</span><span></span><br></span><span><span> std</span><span>::</span><span>string name</span><span>;</span><span></span><br></span><span><span> </span><span>int32_t</span><span> age</span><span>;</span><span></span><br></span><span><span> std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>&gt;</span><span> hobbies</span><span>;</span><span></span><br></span><span><span> std</span><span>::</span><span>map</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>,</span><span> std</span><span>::</span><span>string</span><span>&gt;</span><span> metadata</span><span>;</span><span></span><br></span><span><span> std</span><span>::</span><span>optional</span><span>&lt;</span><span>std</span><span>::</span><span>string</span><span>&gt;</span><span> nickname</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>Person</span><span>,</span><span> name</span><span>,</span><span> age</span><span>,</span><span> hobbies</span><span>,</span><span> metadata</span><span>,</span><span> nickname</span><span>)</span><span>;</span><br></span></code></pre></div>
<p>That single macro generates compile-time field metadata, efficient serialization/deserialization code via ADL (Argument-Dependent Lookup), and type registration hooks. The macro can be placed inside the class body to access private fields, or at namespace scope for third-party types.</p>
<h3>Cross-Language Binary Protocol<a href="#cross-language-binary-protocol">​</a></h3>
<p>Apache Fory C++ speaks the same binary wire format as Java, Python, Go, Rust, and JavaScript. Serialize a struct in C++, deserialize it in Python — no adaptation layer, no schema translation, no version negotiation needed. This is especially powerful for microservice architectures where different teams own different services in different languages:</p>
<div><pre><code><span><span>// C++: Serialize</span><span></span><br></span><span><span></span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>xlang</span><span>(</span><span>true</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Person</span><span>&gt;</span><span>(</span><span>100</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> bytes </span><span>=</span><span> fory</span><span>.</span><span>serialize</span><span>(</span><span>person</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><br></span></code></pre></div>
<div><pre><code><span><span># Python: Deserialize (same binary format, same type ID)</span><span></span><br></span><span><span>fory </span><span>=</span><span> pyfory</span><span>.</span><span>Fory</span><span>(</span><span>xlang</span><span>=</span><span>True</span><span>)</span><span></span><br></span><span><span>fory</span><span>.</span><span>register</span><span>(</span><span>Person</span><span>,</span><span> type_id</span><span>=</span><span>100</span><span>)</span><span> </span><span># Same ID as C++</span><span></span><br></span><span><span>person </span><span>=</span><span> fory</span><span>.</span><span>deserialize</span><span>(</span><span>data</span><span>)</span><br></span></code></pre></div>
<p>The core requirements for cross-language interoperability are consistent type IDs/Names across participating runtimes, matching canonical field names, and compatible field types for those names.</p>
<h3>Polymorphism via Smart Pointers<a href="#polymorphism-via-smart-pointers">​</a></h3>
<p>Serializing polymorphic objects is notoriously difficult in C++. Most frameworks require manual type tagging or generate large amounts of boilerplate. Apache Fory handles it automatically: it detects polymorphic types via <code>std::is_polymorphic&lt;T&gt;</code> and preserves the full runtime type identity through <code>std::shared_ptr</code> and <code>std::unique_ptr</code>. When you deserialize a <code>shared_ptr&lt;Animal&gt;</code> that holds a <code>Dog</code>, you get a <code>Dog</code> back — no extra code required:</p>
<div><pre><code><span><span>struct</span><span> </span><span>Animal</span><span> </span><span>{</span><span> </span><span>virtual</span><span> </span><span>~</span><span>Animal</span><span>(</span><span>)</span><span> </span><span>=</span><span> </span><span>default</span><span>;</span><span> </span><span>int32_t</span><span> age </span><span>=</span><span> </span><span>0</span><span>;</span><span> </span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>Animal</span><span>,</span><span> age</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>Dog</span><span> </span><span>:</span><span> </span><span>Animal</span><span> </span><span>{</span><span> std</span><span>::</span><span>string breed</span><span>;</span><span> </span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>Dog</span><span>,</span><span> </span><span>FORY_BASE</span><span>(</span><span>Animal</span><span>)</span><span>,</span><span> breed</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>Cat</span><span> </span><span>:</span><span> </span><span>Animal</span><span> </span><span>{</span><span> std</span><span>::</span><span>string color</span><span>;</span><span> </span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>Cat</span><span>,</span><span> </span><span>FORY_BASE</span><span>(</span><span>Animal</span><span>)</span><span>,</span><span> color</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>Shelter</span><span> </span><span>{</span><span> std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>shared_ptr</span><span>&lt;</span><span>Animal</span><span>&gt;&gt;</span><span> animals</span><span>;</span><span> </span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>Shelter</span><span>,</span><span> animals</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>track_ref</span><span>(</span><span>true</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Shelter</span><span>&gt;</span><span>(</span><span>10</span><span>)</span><span>;</span><span> fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Dog</span><span>&gt;</span><span>(</span><span>11</span><span>)</span><span>;</span><span> fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Cat</span><span>&gt;</span><span>(</span><span>12</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span>Shelter s</span><span>;</span><span></span><br></span><span><span>s</span><span>.</span><span>animals</span><span>.</span><span>push_back</span><span>(</span><span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>Dog</span><span>&gt;</span><span>(</span><span>)</span><span>)</span><span>;</span><span> </span><span>// Dog at runtime</span><span></span><br></span><span><span>s</span><span>.</span><span>animals</span><span>.</span><span>push_back</span><span>(</span><span>std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>Cat</span><span>&gt;</span><span>(</span><span>)</span><span>)</span><span>;</span><span> </span><span>// Cat at runtime</span><span></span><br></span><span><span></span><br></span><span><span></span><span>auto</span><span> decoded </span><span>=</span><span> fory</span><span>.</span><span>deserialize</span><span>&lt;</span><span>Shelter</span><span>&gt;</span><span>(</span><span>fory</span><span>.</span><span>serialize</span><span>(</span><span>s</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>assert</span><span>(</span><span>dynamic_cast</span><span>&lt;</span><span>Dog</span><span>*</span><span>&gt;</span><span>(</span><span>decoded</span><span>.</span><span>animals</span><span>[</span><span>0</span><span>]</span><span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span> </span><span>!=</span><span> </span><span>nullptr</span><span>)</span><span>;</span><span> </span><span>// Runtime type preserved!</span><br></span></code></pre></div>
<p>Fory also supports <code>std::unique_ptr</code> for exclusive-ownership polymorphic fields, and collections of smart pointers (<code>std::vector&lt;std::shared_ptr&lt;Base&gt;&gt;</code>, <code>std::map&lt;K, std::unique_ptr&lt;Base&gt;&gt;</code>).</p>
<h3>Shared/Circular Reference Tracking<a href="#sharedcircular-reference-tracking">​</a></h3>
<p>Many real-world data models contain shared objects or cycles: a parent node pointing to its children, which point back to the parent; an order referencing a customer who appears in multiple orders. Standard serialization frameworks either duplicate the data (wasting space) or crash with a stack overflow when they encounter a cycle.</p>
<p>With <code>track_ref(true)</code>, Fory tracks object identity across the entire graph. Shared objects are serialized exactly once; every subsequent reference is encoded as a back-reference. Cycles terminate naturally:</p>
<div><pre><code><span><span>struct</span><span> </span><span>Node</span><span> </span><span>{</span><span></span><br></span><span><span> </span><span>virtual</span><span> </span><span>~</span><span>Node</span><span>(</span><span>)</span><span> </span><span>=</span><span> </span><span>default</span><span>;</span><span></span><br></span><span><span> </span><span>int32_t</span><span> id </span><span>=</span><span> </span><span>0</span><span>;</span><span></span><br></span><span><span> std</span><span>::</span><span>vector</span><span>&lt;</span><span>std</span><span>::</span><span>shared_ptr</span><span>&lt;</span><span>Node</span><span>&gt;&gt;</span><span> neighbors</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>Node</span><span>,</span><span> id</span><span>,</span><span> neighbors</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>track_ref</span><span>(</span><span>true</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Node</span><span>&gt;</span><span>(</span><span>200</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>auto</span><span> node1 </span><span>=</span><span> std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>Node</span><span>&gt;</span><span>(</span><span>)</span><span>;</span><span> node1</span><span>-&gt;</span><span>id </span><span>=</span><span> </span><span>1</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> node2 </span><span>=</span><span> std</span><span>::</span><span>make_shared</span><span>&lt;</span><span>Node</span><span>&gt;</span><span>(</span><span>)</span><span>;</span><span> node2</span><span>-&gt;</span><span>id </span><span>=</span><span> </span><span>2</span><span>;</span><span></span><br></span><span><span>node1</span><span>-&gt;</span><span>neighbors</span><span>.</span><span>push_back</span><span>(</span><span>node2</span><span>)</span><span>;</span><span></span><br></span><span><span>node2</span><span>-&gt;</span><span>neighbors</span><span>.</span><span>push_back</span><span>(</span><span>node1</span><span>)</span><span>;</span><span> </span><span>// Cycle — handled correctly!</span><span></span><br></span><span><span></span><br></span><span><span></span><span>auto</span><span> bytes </span><span>=</span><span> fory</span><span>.</span><span>serialize</span><span>(</span><span>node1</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>// No stack overflow, no duplicate data — the cycle is preserved faithfully</span><span></span><br></span><span><span></span><span>auto</span><span> decoded </span><span>=</span><span> fory</span><span>.</span><span>deserialize</span><span>&lt;</span><span>std</span><span>::</span><span>shared_ptr</span><span>&lt;</span><span>Node</span><span>&gt;&gt;</span><span>(</span><span>bytes</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><br></span></code></pre></div>
<p>This makes Fory a natural fit for graph databases, entity-component systems, and any domain model with bidirectional relationships.</p>
<h3>Schema Evolution<a href="#schema-evolution">​</a></h3>
<p>In a microservice deployment, services update independently. A new version of the user service may add a <code>phone</code> field while old consumers are still running. Without schema evolution support, this forces a coordinated, big-bang deployment. Apache Fory's <strong>compatible mode</strong> removes this constraint entirely:</p>
<div><pre><code><span><span>// Version 1</span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>UserV1</span><span> </span><span>{</span><span> std</span><span>::</span><span>string name</span><span>;</span><span> </span><span>int32_t</span><span> age</span><span>;</span><span> </span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>UserV1</span><span>,</span><span> name</span><span>,</span><span> age</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Version 2 — new fields added independently</span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>UserV2</span><span> </span><span>{</span><span> std</span><span>::</span><span>string name</span><span>;</span><span> </span><span>int32_t</span><span> age</span><span>;</span><span> std</span><span>::</span><span>string email</span><span>;</span><span> </span><span>}</span><span>;</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>UserV2</span><span>,</span><span> name</span><span>,</span><span> age</span><span>,</span><span> email</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>auto</span><span> fory_v1 </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>compatible</span><span>(</span><span>true</span><span>)</span><span>.</span><span>xlang</span><span>(</span><span>true</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> fory_v2 </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>compatible</span><span>(</span><span>true</span><span>)</span><span>.</span><span>xlang</span><span>(</span><span>true</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory_v1</span><span>.</span><span>register_struct</span><span>&lt;</span><span>UserV1</span><span>&gt;</span><span>(</span><span>100</span><span>)</span><span>;</span><span></span><br></span><span><span>fory_v2</span><span>.</span><span>register_struct</span><span>&lt;</span><span>UserV2</span><span>&gt;</span><span>(</span><span>100</span><span>)</span><span>;</span><span> </span><span>// Same type ID enables evolution</span><span></span><br></span><span><span></span><br></span><span><span></span><span>auto</span><span> bytes </span><span>=</span><span> fory_v1</span><span>.</span><span>serialize</span><span>(</span><span>UserV1</span><span>{</span><span>"Alice"</span><span>,</span><span> </span><span>30</span><span>}</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> v2 </span><span>=</span><span> fory_v2</span><span>.</span><span>deserialize</span><span>&lt;</span><span>UserV2</span><span>&gt;</span><span>(</span><span>bytes</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>assert</span><span>(</span><span>v2</span><span>.</span><span>name </span><span>==</span><span> </span><span>"Alice"</span><span> </span><span>&amp;&amp;</span><span> v2</span><span>.</span><span>email </span><span>==</span><span> </span><span>""</span><span>)</span><span>;</span><span> </span><span>// Default for missing field</span><br></span></code></pre></div>
<p>In compatible mode, fields are matched by name rather than position. New fields receive C++ default values when missing; removed fields are safely skipped. This enables rolling upgrades and independent service deployments without any serialization errors.</p>
<h3>Row Format: Zero-Copy Analytics<a href="#row-format-zero-copy-analytics">​</a></h3>
<p>Beyond object graph serialization, Apache Fory C++ implements a <strong>row-based binary format</strong> designed for analytics workloads. The row format stores data in a contiguous memory layout with a null bitmap, fixed-size slots for primitives, and a variable-length section for strings and nested objects. This enables <strong>O(1) random field access by index</strong> — you can read a single field from a large struct without touching the rest of the data.</p>
<p>This is particularly valuable in data pipelines and OLAP workloads where only a small subset of fields are queried per record:</p>
<div><pre><code><span><span>#</span><span>include</span><span> </span><span>"fory/encoder/row_encoder.h"</span><span></span><br></span><span><span></span><span>using</span><span> </span><span>namespace</span><span> fory</span><span>::</span><span>row</span><span>::</span><span>encoder</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>SensorReading</span><span> </span><span>{</span><span></span><br></span><span><span> </span><span>int32_t</span><span> sensor_id</span><span>;</span><span> </span><span>double</span><span> temperature</span><span>;</span><span> std</span><span>::</span><span>string location</span><span>;</span><span></span><br></span><span><span> </span><span>FORY_STRUCT</span><span>(</span><span>SensorReading</span><span>,</span><span> sensor_id</span><span>,</span><span> temperature</span><span>,</span><span> location</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span>RowEncoder</span><span>&lt;</span><span>SensorReading</span><span>&gt;</span><span> encoder</span><span>;</span><span></span><br></span><span><span>encoder</span><span>.</span><span>encode</span><span>(</span><span>{</span><span>42</span><span>,</span><span> </span><span>23.5</span><span>,</span><span> </span><span>"rack-B"</span><span>}</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> row </span><span>=</span><span> encoder</span><span>.</span><span>get_writer</span><span>(</span><span>)</span><span>.</span><span>to_row</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Read any field in O(1) — no deserialization of unused fields</span><span></span><br></span><span><span></span><span>int32_t</span><span> id </span><span>=</span><span> row</span><span>-&gt;</span><span>get_int32</span><span>(</span><span>0</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>double</span><span> temp </span><span>=</span><span> row</span><span>-&gt;</span><span>get_double</span><span>(</span><span>1</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> loc </span><span>=</span><span> row</span><span>-&gt;</span><span>get_string</span><span>(</span><span>2</span><span>)</span><span>;</span><br></span></code></pre></div>
<p>For zero-copy access into an existing buffer (e.g., from a memory-mapped file or network receive buffer), Fory can point a <code>Row</code> directly at the memory without copying:</p>
<div><pre><code><span><span>auto</span><span> src </span><span>=</span><span> encoder</span><span>.</span><span>get_writer</span><span>(</span><span>)</span><span>.</span><span>to_row</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>::</span><span>row</span><span>::</span><span>Row </span><span>view</span><span>(</span><span>src</span><span>-&gt;</span><span>schema</span><span>(</span><span>)</span><span>)</span><span>;</span><span></span><br></span><span><span>view</span><span>.</span><span>point_to</span><span>(</span><span>src</span><span>-&gt;</span><span>buffer</span><span>(</span><span>)</span><span>,</span><span> src</span><span>-&gt;</span><span>base_offset</span><span>(</span><span>)</span><span>,</span><span> src</span><span>-&gt;</span><span>size_bytes</span><span>(</span><span>)</span><span>)</span><span>;</span><span> </span><span>// Zero-copy view</span><span></span><br></span><span><span></span><span>int32_t</span><span> id </span><span>=</span><span> view</span><span>.</span><span>get_int32</span><span>(</span><span>0</span><span>)</span><span>;</span><span> </span><span>// Reads directly from the original buffer</span><br></span></code></pre></div>
<p>Use the row format for analytics, OLAP-style workloads, and partial field access. Use object graph serialization for full object round-trips with references and polymorphism.</p>
<hr>
<h2>Installation<a href="#installation">​</a></h2>
<p>Fory C++ requires a C++17-compatible compiler (GCC 7+, Clang 5+, MSVC 2017+) and supports both CMake and Bazel build systems.</p>
<h3>CMake (FetchContent)<a href="#cmake-fetchcontent">​</a></h3>
<p>The simplest integration is via CMake's <code>FetchContent</code> module, which fetches and builds Fory as part of your project:</p>
<div><pre><code><span><span>cmake_minimum_required(VERSION 3.16)</span><br></span><span><span>project(my_project LANGUAGES CXX)</span><br></span><span><span>set(CMAKE_CXX_STANDARD 17)</span><br></span><span><span></span><br></span><span><span>include(FetchContent)</span><br></span><span><span>FetchContent_Declare(fory</span><br></span><span><span> GIT_REPOSITORY https://github.com/apache/fory.git</span><br></span><span><span> GIT_TAG v0.15.0</span><br></span><span><span> SOURCE_SUBDIR cpp)</span><br></span><span><span>FetchContent_MakeAvailable(fory)</span><br></span><span><span></span><br></span><span><span>add_executable(my_app main.cc)</span><br></span><span><span>target_link_libraries(my_app PRIVATE fory::serialization)</span><br></span></code></pre></div>
<h3>Bazel<a href="#bazel">​</a></h3>
<p>For Bazel-based projects, add Fory as a module dependency:</p>
<div><pre><code><span><span>bazel_dep(name = "fory", version = "0.15.0")</span><br></span><span><span>git_override(module_name = "fory",</span><br></span><span><span> remote = "https://github.com/apache/fory.git",</span><br></span><span><span> commit = "v0.15.0")</span><br></span></code></pre></div>
<div><pre><code><span><span>cc_binary(name = "my_app", srcs = ["main.cc"],</span><br></span><span><span> deps = ["@fory//cpp/fory/serialization:fory_serialization"])</span><br></span></code></pre></div>
<hr>
<h2>Native Serialization<a href="#native-serialization">​</a></h2>
<p>For pure C++ applications without cross-language requirements, disabling <code>xlang</code> produces a more compact binary encoding because no cross-language type metadata is emitted. This is the fastest possible path:</p>
<div><pre><code><span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span></span><br></span><span><span> </span><span>.</span><span>xlang</span><span>(</span><span>false</span><span>)</span><span> </span><span>// Native C++ mode — tighter encoding</span><span></span><br></span><span><span> </span><span>.</span><span>track_ref</span><span>(</span><span>false</span><span>)</span><span> </span><span>// Disable if no shared/circular refs</span><span></span><br></span><span><span> </span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span>fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Address</span><span>&gt;</span><span>(</span><span>1</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Person</span><span>&gt;</span><span>(</span><span>2</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Serialize</span><span></span><br></span><span><span></span><span>auto</span><span> result </span><span>=</span><span> fory</span><span>.</span><span>serialize</span><span>(</span><span>person</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>if</span><span> </span><span>(</span><span>!</span><span>result</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>)</span><span> </span><span>{</span><span> std</span><span>::</span><span>cerr </span><span>&lt;&lt;</span><span> result</span><span>.</span><span>error</span><span>(</span><span>)</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>;</span><span> </span><span>return</span><span> </span><span>1</span><span>;</span><span> </span><span>}</span><span></span><br></span><span><span>std</span><span>::</span><span>vector</span><span>&lt;</span><span>uint8_t</span><span>&gt;</span><span> bytes </span><span>=</span><span> std</span><span>::</span><span>move</span><span>(</span><span>result</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Deserialize</span><span></span><br></span><span><span></span><span>auto</span><span> decoded </span><span>=</span><span> fory</span><span>.</span><span>deserialize</span><span>&lt;</span><span>Person</span><span>&gt;</span><span>(</span><span>bytes</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>assert</span><span>(</span><span>decoded</span><span>.</span><span>ok</span><span>(</span><span>)</span><span> </span><span>&amp;&amp;</span><span> person </span><span>==</span><span> decoded</span><span>.</span><span>value</span><span>(</span><span>)</span><span>)</span><span>;</span><br></span></code></pre></div>
<p><code>FORY_STRUCT</code> handles several important C++ patterns that commonly arise in production codebases:</p>
<div><pre><code><span><span>// Private fields — place macro in public: section</span><span></span><br></span><span><span></span><span>class</span><span> </span><span>Secure</span><span> </span><span>{</span><span></span><br></span><span><span> </span><span>int32_t</span><span> secret_</span><span>;</span><span> std</span><span>::</span><span>string token_</span><span>;</span><span></span><br></span><span><span></span><span>public</span><span>:</span><span></span><br></span><span><span> </span><span>FORY_STRUCT</span><span>(</span><span>Secure</span><span>,</span><span> secret_</span><span>,</span><span> token_</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Inheritance — FORY_BASE includes base class fields</span><span></span><br></span><span><span></span><span>struct</span><span> </span><span>Derived</span><span> </span><span>:</span><span> </span><span>Base</span><span> </span><span>{</span><span></span><br></span><span><span> std</span><span>::</span><span>string extra</span><span>;</span><span></span><br></span><span><span> </span><span>FORY_STRUCT</span><span>(</span><span>Derived</span><span>,</span><span> </span><span>FORY_BASE</span><span>(</span><span>Base</span><span>)</span><span>,</span><span> extra</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// External/third-party types — use at namespace scope (public fields only)</span><span></span><br></span><span><span></span><span>namespace</span><span> ext </span><span>{</span><span> </span><span>struct</span><span> </span><span>Coord</span><span> </span><span>{</span><span> </span><span>double</span><span> lat</span><span>,</span><span> lon</span><span>;</span><span> </span><span>}</span><span>;</span><span> </span><span>}</span><span></span><br></span><span><span></span><span>FORY_STRUCT</span><span>(</span><span>ext</span><span>::</span><span>Coord</span><span>,</span><span> lat</span><span>,</span><span> lon</span><span>)</span><span>;</span><br></span></code></pre></div>
<h3>Error Handling<a href="#error-handling">​</a></h3>
<p>All Fory operations return <code>Result&lt;T, Error&gt;</code>, making error handling explicit and composable. The <code>FORY_TRY</code> macro provides a concise early-return pattern for functions that propagate errors:</p>
<div><pre><code><span><span>// Option 1: Conditional check</span><span></span><br></span><span><span></span><span>auto</span><span> r </span><span>=</span><span> fory</span><span>.</span><span>serialize</span><span>(</span><span>obj</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>if</span><span> </span><span>(</span><span>r</span><span>.</span><span>ok</span><span>(</span><span>)</span><span>)</span><span> </span><span>{</span><span> </span><span>auto</span><span> bytes </span><span>=</span><span> std</span><span>::</span><span>move</span><span>(</span><span>r</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span> </span><span>}</span><span></span><br></span><span><span></span><span>else</span><span> </span><span>{</span><span> std</span><span>::</span><span>cerr </span><span>&lt;&lt;</span><span> r</span><span>.</span><span>error</span><span>(</span><span>)</span><span>.</span><span>to_string</span><span>(</span><span>)</span><span>;</span><span> </span><span>}</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Option 2: FORY_TRY macro for early return</span><span></span><br></span><span><span></span><span>FORY_TRY</span><span>(</span><span>bytes</span><span>,</span><span> fory</span><span>.</span><span>serialize</span><span>(</span><span>obj</span><span>)</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>// Use bytes directly — any error propagates automatically</span><br></span></code></pre></div>
<h3>Thread Safety<a href="#thread-safety">​</a></h3>
<p>Fory provides two variants with different threading guarantees. Choose based on whether your serialization is centralized (shared instance) or distributed across threads:</p>
<div><pre><code><span><span>// Single-threaded (fastest) — one instance per thread, no synchronization overhead</span><span></span><br></span><span><span></span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Thread-safe — shared across threads via an internal instance pool</span><span></span><br></span><span><span></span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>build_thread_safe</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>MyType</span><span>&gt;</span><span>(</span><span>1</span><span>)</span><span>;</span><span> </span><span>// Register all types before sharing</span><span></span><br></span><span><span>std</span><span>::</span><span>thread </span><span>t</span><span>(</span><span>[</span><span>&amp;</span><span>]</span><span>(</span><span>)</span><span> </span><span>{</span><span> fory</span><span>.</span><span>serialize</span><span>(</span><span>obj</span><span>)</span><span>;</span><span> </span><span>}</span><span>)</span><span>;</span><span> </span><span>// Safe to call concurrently</span><br></span></code></pre></div>
<hr>
<h2>Cross-Language Serialization<a href="#cross-language-serialization">​</a></h2>
<h3>Without IDL<a href="#without-idl">​</a></h3>
<p>When you control both sides of the wire and can coordinate type definitions manually, the simplest approach is to register types with matching numeric IDs in each language. This requires no additional tooling and works well for small, stable schemas:</p>
<div><pre><code><span><span>// C++</span><span></span><br></span><span><span></span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>xlang</span><span>(</span><span>true</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>.</span><span>register_struct</span><span>&lt;</span><span>Order</span><span>&gt;</span><span>(</span><span>201</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> bytes </span><span>=</span><span> fory</span><span>.</span><span>serialize</span><span>(</span><span>order</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><br></span></code></pre></div>
<div><pre><code><span><span>// Java — same binary format, same type ID</span><span></span><br></span><span><span></span><span>Fory</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>.</span><span>builder</span><span>(</span><span>)</span><span>.</span><span>withLanguage</span><span>(</span><span>Language</span><span>.</span><span>XLANG</span><span>)</span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span>fory</span><span>.</span><span>register</span><span>(</span><span>Order</span><span>.</span><span>class</span><span>,</span><span> </span><span>201</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>Order</span><span> order </span><span>=</span><span> </span><span>(</span><span>Order</span><span>)</span><span> fory</span><span>.</span><span>deserialize</span><span>(</span><span>bytes</span><span>)</span><span>;</span><br></span></code></pre></div>
<div><pre><code><span><span># Python — same binary format, same type ID</span><span></span><br></span><span><span>fory </span><span>=</span><span> pyfory</span><span>.</span><span>Fory</span><span>(</span><span>xlang</span><span>=</span><span>True</span><span>)</span><span></span><br></span><span><span>fory</span><span>.</span><span>register</span><span>(</span><span>Order</span><span>,</span><span> type_id</span><span>=</span><span>201</span><span>)</span><span></span><br></span><span><span>order </span><span>=</span><span> fory</span><span>.</span><span>deserialize</span><span>(</span><span>data</span><span>)</span><br></span></code></pre></div>
<p><strong>Field matching</strong>: In cross-language mode, field names are normalized to snake_case and matched by that canonical name. Ordering follows Fory's xlang field-order rules (not simple alphabetical ordering), so keep names semantically consistent across languages.</p>
<h3>With the Fory Schema IDL Compiler<a href="#with-the-fory-schema-idl-compiler">​</a></h3>
<p>As schemas grow and span more services and teams, manually maintaining consistent field names, type IDs, and type definitions across five languages becomes error-prone. The <strong>Fory Schema IDL Compiler</strong> (<code>foryc</code>) solves this by letting you define types once in a <code>.fdl</code> file and generating idiomatic, production-ready code for every target language. The generated code includes typed accessors, serialization macros, registration helpers, and <code>to_bytes()</code>/<code>from_bytes()</code> helpers — so you never write serialization plumbing by hand.</p>
<h4>1. Install the compiler<a href="#1-install-the-compiler">​</a></h4>
<div><pre><code><span><span>pip </span><span>install</span><span> fory-compiler</span><br></span><span><span>foryc </span><span>--help</span><br></span></code></pre></div>
<h4>2. Write a schema (<code>ecommerce.fdl</code>)<a href="#2-write-a-schema-ecommercefdl">​</a></h4>
<p>Fory IDL syntax is concise and deliberately close to protobuf, so it is easy to pick up. Field modifiers like <code>optional</code>, <code>ref</code>, and <code>list</code> map directly to idiomatic C++ types:</p>
<div><pre><code><span><span>package</span><span> ecommerce</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>enum</span><span> </span><span>OrderStatus</span><span> </span><span>{</span><span></span><br></span><span><span> PENDING </span><span>=</span><span> </span><span>0</span><span>;</span><span> CONFIRMED </span><span>=</span><span> </span><span>1</span><span>;</span><span> SHIPPED </span><span>=</span><span> </span><span>2</span><span>;</span><span> DELIVERED </span><span>=</span><span> </span><span>3</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span></span><br></span><span><span></span><br></span><span><span></span><span>message</span><span> </span><span>Address</span><span> </span><span>{</span><span></span><br></span><span><span> </span><span>string</span><span> street </span><span>=</span><span> </span><span>1</span><span>;</span><span> </span><span>string</span><span> city </span><span>=</span><span> </span><span>2</span><span>;</span><span> </span><span>string</span><span> country </span><span>=</span><span> </span><span>3</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span></span><br></span><span><span></span><br></span><span><span></span><span>message</span><span> </span><span>Customer</span><span> </span><span>{</span><span></span><br></span><span><span> </span><span>string</span><span> id </span><span>=</span><span> </span><span>1</span><span>;</span><span></span><br></span><span><span> </span><span>string</span><span> name </span><span>=</span><span> </span><span>2</span><span>;</span><span></span><br></span><span><span> </span><span>optional</span><span> </span><span>string</span><span> email </span><span>=</span><span> </span><span>3</span><span>;</span><span> </span><span>// Nullable: maps to std::optional&lt;std::string&gt;</span><span></span><br></span><span><span> </span><span>optional</span><span> </span><span>Address</span><span> address </span><span>=</span><span> </span><span>4</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span></span><br></span><span><span></span><br></span><span><span></span><span>message</span><span> </span><span>OrderItem</span><span> </span><span>{</span><span></span><br></span><span><span> </span><span>string</span><span> sku </span><span>=</span><span> </span><span>1</span><span>;</span><span></span><br></span><span><span> </span><span>int32</span><span> quantity </span><span>=</span><span> </span><span>2</span><span>;</span><span></span><br></span><span><span> </span><span>float64</span><span> unit_price </span><span>=</span><span> </span><span>3</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// Discount can be either a fixed amount or a percentage — modelled as a union</span><span></span><br></span><span><span></span><span>message</span><span> </span><span>FixedDiscount</span><span> </span><span>{</span><span> </span><span>float64</span><span> amount </span><span>=</span><span> </span><span>1</span><span>;</span><span> </span><span>}</span><span></span><br></span><span><span></span><span>message</span><span> </span><span>PercentDiscount</span><span> </span><span>{</span><span> </span><span>float64</span><span> percentage </span><span>=</span><span> </span><span>1</span><span>;</span><span> </span><span>}</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// union maps to std::variant&lt;FixedDiscount, PercentDiscount&gt; in C++</span><span></span><br></span><span><span>union Discount </span><span>{</span><span></span><br></span><span><span> </span><span>FixedDiscount</span><span> fixed </span><span>=</span><span> </span><span>1</span><span>;</span><span></span><br></span><span><span> </span><span>PercentDiscount</span><span> percent </span><span>=</span><span> </span><span>2</span><span>;</span><span></span><br></span><span><span></span><span>}</span><span></span><br></span><span><span></span><br></span><span><span></span><span>message</span><span> </span><span>Order</span><span> </span><span>{</span><span></span><br></span><span><span> </span><span>string</span><span> order_id </span><span>=</span><span> </span><span>1</span><span>;</span><span></span><br></span><span><span> ref </span><span>Customer</span><span> customer </span><span>=</span><span> </span><span>2</span><span>;</span><span> </span><span>// ref: std::shared_ptr + reference tracking</span><span></span><br></span><span><span> list</span><span>&lt;</span><span>OrderItem</span><span>&gt;</span><span> items </span><span>=</span><span> </span><span>3</span><span>;</span><span> </span><span>// list: std::vector&lt;OrderItem&gt;</span><span></span><br></span><span><span> </span><span>OrderStatus</span><span> status </span><span>=</span><span> </span><span>4</span><span>;</span><span></span><br></span><span><span> </span><span>float64</span><span> total </span><span>=</span><span> </span><span>5</span><span>;</span><span></span><br></span><span><span> </span><span>optional</span><span> </span><span>string</span><span> notes </span><span>=</span><span> </span><span>6</span><span>;</span><span></span><br></span><span><span> </span><span>timestamp</span><span> created_at </span><span>=</span><span> </span><span>7</span><span>;</span><span></span><br></span><span><span> </span><span>optional</span><span> </span><span>Discount</span><span> discount </span><span>=</span><span> </span><span>8</span><span>;</span><span> </span><span>// optional union field</span><span></span><br></span><span><span></span><span>}</span><br></span></code></pre></div>
<p>The IDL type system maps cleanly to native C++ constructs. <code>union</code> is a first-class IDL construct that generates a <code>std::variant</code>-based wrapper class in C++, with typed case accessors (<code>is_fixed()</code>, <code>as_fixed()</code>, etc.) and a <code>visit()</code> method. Here is the full set of field modifiers and their C++ equivalents:</p>
<table><thead><tr><th>Modifier</th><th>C++ type</th><th>Purpose</th></tr></thead><tbody><tr><td><code>optional T</code></td><td><code>std::optional&lt;T&gt;</code></td><td>Nullable field</td></tr><tr><td><code>ref T</code></td><td><code>std::shared_ptr&lt;T&gt;</code></td><td>Shared / circular reference</td></tr><tr><td><code>ref(weak=true) T</code></td><td><code>fory::serialization::SharedWeak&lt;T&gt;</code></td><td>Weak reference (breaks cycles)</td></tr><tr><td><code>list&lt;T&gt;</code></td><td><code>std::vector&lt;T&gt;</code></td><td>Ordered list</td></tr><tr><td><code>map&lt;K,V&gt;</code></td><td><code>std::map&lt;K,V&gt;</code></td><td>Key-value map</td></tr></tbody></table>
<h4>3. Generate code<a href="#3-generate-code">​</a></h4>
<p><code>foryc</code> generates a single header file per schema for C++, and equivalent files for every other target language. All generated files use the same type IDs derived from the package and type names, guaranteeing binary compatibility without any manual coordination:</p>
<div><pre><code><span><span># Generate C++ header directly under ./generated</span><span></span><br></span><span><span>foryc ecommerce.fdl </span><span>--cpp_out</span><span> ./generated</span><br></span><span><span></span><br></span><span><span></span><span># Generate multiple languages with explicit output directories</span><span></span><br></span><span><span>foryc ecommerce.fdl </span><span>--cpp_out</span><span> ./generated </span><span>--java_out</span><span> ./java/src/main/java </span><span>--python_out</span><span> ./python/gen </span><span>--go_out</span><span> ./go/gen </span><span>--rust_out</span><span> ./rust/gen</span><br></span></code></pre></div>
<p>The output structure for C++ is one header per schema file under the directory passed to <code>--cpp_out</code>. For example, <code>--cpp_out ./generated</code> produces <code>generated/ecommerce.h</code>. The header contains all types under the <code>ecommerce::</code> namespace, with <code>FORY_STRUCT</code> macros and a <code>register_types()</code> helper already wired up.</p>
<h4>4. Use the generated C++ code<a href="#4-use-the-generated-c-code">​</a></h4>
<p>The generated header provides <code>final</code> classes with typed accessors and <code>to_bytes()</code>/<code>from_bytes()</code> helpers. There is no manual Fory instance setup required — the helpers manage it internally:</p>
<div><pre><code><span><span>#</span><span>include</span><span> </span><span>"generated/ecommerce.h"</span><span></span><br></span><span><span></span><br></span><span><span>ecommerce</span><span>::</span><span>Order order</span><span>;</span><span></span><br></span><span><span>order</span><span>.</span><span>set_order_id</span><span>(</span><span>"ORD-2025-001"</span><span>)</span><span>;</span><span></span><br></span><span><span>order</span><span>.</span><span>mutable_customer</span><span>(</span><span>)</span><span>-&gt;</span><span>set_name</span><span>(</span><span>"Alice"</span><span>)</span><span>;</span><span></span><br></span><span><span>order</span><span>.</span><span>set_status</span><span>(</span><span>ecommerce</span><span>::</span><span>OrderStatus</span><span>::</span><span>CONFIRMED</span><span>)</span><span>;</span><span></span><br></span><span><span>order</span><span>.</span><span>set_total</span><span>(</span><span>159.98</span><span>)</span><span>;</span><span></span><br></span><span><span></span><br></span><span><span></span><span>// to_bytes()/from_bytes() are generated — no Fory boilerplate needed</span><span></span><br></span><span><span></span><span>auto</span><span> bytes </span><span>=</span><span> order</span><span>.</span><span>to_bytes</span><span>(</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>auto</span><span> restored </span><span>=</span><span> ecommerce</span><span>::</span><span>Order</span><span>::</span><span>from_bytes</span><span>(</span><span>bytes</span><span>)</span><span>.</span><span>value</span><span>(</span><span>)</span><span>;</span><span></span><br></span><span><span></span><span>assert</span><span>(</span><span>restored</span><span>.</span><span>order_id</span><span>(</span><span>)</span><span> </span><span>==</span><span> </span><span>"ORD-2025-001"</span><span>)</span><span>;</span><br></span></code></pre></div>
<p>Because the generated Java, Python, and Go code uses the same type IDs, bytes serialized by the C++ <code>to_bytes()</code> helper can be deserialized by the Java <code>fromBytes()</code> or Python <code>from_bytes()</code> helpers out of the box — no extra configuration required.</p>
<hr>
<h2>Supported Types<a href="#supported-types">​</a></h2>
<p>Apache Fory C++ supports a comprehensive set of types covering all common C++ data structures and cross-language primitives:</p>
<table><thead><tr><th>Category</th><th>C++ Types</th></tr></thead><tbody><tr><td>Primitives</td><td><code>bool</code>, <code>int8_t</code>…<code>int64_t</code>, <code>uint8_t</code>…<code>uint64_t</code>, <code>float</code>, <code>double</code></td></tr><tr><td>Strings</td><td><code>std::string</code>, <code>std::string_view</code>, <code>std::u16string</code></td></tr><tr><td>Collections</td><td><code>std::vector&lt;T&gt;</code>, <code>std::set&lt;T&gt;</code>, <code>std::unordered_set&lt;T&gt;</code>, <code>std::map&lt;K,V&gt;</code>, <code>std::unordered_map&lt;K,V&gt;</code></td></tr><tr><td>Optional/Union</td><td><code>std::optional&lt;T&gt;</code>, <code>std::variant&lt;Ts...&gt;</code></td></tr><tr><td>Smart Pointers</td><td><code>std::shared_ptr&lt;T&gt;</code> (ref tracking + polymorphism), <code>std::unique_ptr&lt;T&gt;</code>, <code>fory::serialization::SharedWeak&lt;T&gt;</code></td></tr><tr><td>Temporal</td><td><code>std::chrono::nanoseconds</code>, <code>fory::serialization::Timestamp</code>, <code>fory::serialization::Date</code></td></tr><tr><td>Enums</td><td>Scoped/unscoped enums; use <code>FORY_ENUM</code> for non-continuous values</td></tr><tr><td>User structs</td><td>Any type annotated with <code>FORY_STRUCT</code></td></tr></tbody></table>
<p>All collection element and map value types can be arbitrarily nested, including structs, smart pointers, and <code>std::optional</code>.</p>
<hr>
<h2>Configuration Reference<a href="#configuration-reference">​</a></h2>
<p>Fory instances are constructed through a fluent builder API. All options have sensible defaults, so most applications only need to set one or two:</p>
<div><pre><code><span><span>auto</span><span> fory </span><span>=</span><span> </span><span>Fory</span><span>::</span><span>builder</span><span>(</span><span>)</span><span></span><br></span><span><span> </span><span>.</span><span>xlang</span><span>(</span><span>true</span><span>)</span><span> </span><span>// Cross-language binary protocol (default: true)</span><span></span><br></span><span><span> </span><span>.</span><span>compatible</span><span>(</span><span>true</span><span>)</span><span> </span><span>// Schema evolution / compatible mode (default: false)</span><span></span><br></span><span><span> </span><span>.</span><span>track_ref</span><span>(</span><span>true</span><span>)</span><span> </span><span>// Shared/circular reference tracking (default: true)</span><span></span><br></span><span><span> </span><span>.</span><span>max_dyn_depth</span><span>(</span><span>10</span><span>)</span><span> </span><span>// Max polymorphic nesting depth (default: 5)</span><span></span><br></span><span><span> </span><span>.</span><span>check_struct_version</span><span>(</span><span>true</span><span>)</span><span> </span><span>// Validate struct hash on deserialization (default: false)</span><span></span><br></span><span><span> </span><span>.</span><span>build</span><span>(</span><span>)</span><span>;</span><span> </span><span>// Single-threaded; use build_thread_safe() for multi-thread</span><br></span></code></pre></div>
<p><strong>Tuning guide</strong>: Disable <code>compatible</code> for maximum throughput when schema changes are coordinated (same binary deployed together). Disable <code>track_ref</code> for pure value types with no sharing or cycles — it eliminates per-object reference bookkeeping. Use <code>xlang(false)</code> for C++-only deployments to get a more compact binary encoding.</p>
<hr>
<h2>Benchmarks<a href="#benchmarks">​</a></h2>
<p>Apache Fory delivers exceptional performance across diverse data shapes. The combination of compile-time code generation, variable-length integer encoding, and a carefully designed binary protocol yields major gains versus text formats and strong results versus Protocol Buffers. In the current C++ benchmark report, Fory throughput vs Protobuf ranges from about <strong>1.1x to 12.2x</strong> depending on workload and operation:</p>
<p><img src="https://fory.apache.org/img/benchmarks/cpp/throughput.png"></p><p>The C++ implementation achieves similar relative speedups to the Java implementation. Because both share the same binary protocol design, and C++ serialization code is generated at compile time (eliminating the JIT warm-up cost), C++ performance is competitive or superior for latency-sensitive workloads.</p>
<p>Serialized Data Sizes (bytes)</p>
<table><thead><tr><th>Datatype</th><th>Fory</th><th>Protobuf</th></tr></thead><tbody><tr><td>Struct</td><td>58</td><td>61</td></tr><tr><td>Sample</td><td>446</td><td>375</td></tr><tr><td>MediaContent</td><td>365</td><td>301</td></tr><tr><td>StructList</td><td>184</td><td>315</td></tr><tr><td>SampleList</td><td>1980</td><td>1890</td></tr><tr><td>MediaContentList</td><td>1535</td><td>1520</td></tr></tbody></table>
<hr>
<h2>Conclusion<a href="#conclusion">​</a></h2>
<p>Apache Fory C++ brings together a set of capabilities that no other C++ serialization library delivers as a cohesive package:</p>
<ul>
<li><strong>Performance</strong>: Template-based compile-time codegen eliminates all runtime reflection overhead; a highly efficient binary protocol minimizes both serialized size and CPU cycles</li>
<li><strong>Cross-language</strong>: The same binary format works natively with Java, Python, Go, Rust, and JavaScript</li>
<li><strong>Native C++ idioms</strong>: <code>std::shared_ptr</code>, <code>std::optional</code>, <code>std::variant</code>, <code>fory::serialization::SharedWeak</code> — all handled naturally</li>
<li><strong>Production-ready features</strong>: Polymorphism, circular references, schema evolution, thread safety out of the box</li>
<li><strong>Schema-first option</strong>: The Fory IDL Compiler generates consistent, idiomatic code across all languages from a single <code>.fdl</code> definition — no more manually synchronizing type IDs across codebases</li>
</ul>
<p>Whether you are building a high-performance game server, a polyglot microservice backend, a real-time analytics pipeline, or an embedded system serializing complex domain models, Apache Fory C++ has you covered.</p>
<p><strong>Get started:</strong></p>
<div><pre><code><span><span>git</span><span> clone https://github.com/apache/fory.git</span><br></span><span><span></span><span>cd</span><span> fory/examples/cpp/hello_world</span><br></span><span><span>cmake </span><span>-B</span><span> build </span><span>-DCMAKE_BUILD_TYPE</span><span>=</span><span>Release </span><span>&amp;&amp;</span><span> cmake </span><span>--build</span><span> build</span><br></span><span><span>./build/hello_world</span><br></span></code></pre></div>
<p><strong>Documentation:</strong></p>
<ul>
<li>C++ Serialization Guide: <a href="https://fory.apache.org/docs/guide/cpp" target="_blank">fory.apache.org/docs/guide/cpp</a></li>
<li>Fory Schema IDL Compiler: <a href="https://fory.apache.org/docs/compiler" target="_blank">fory.apache.org/docs/compiler</a></li>
<li>Xlang Serialization Spec: <a href="https://fory.apache.org/docs/specification/xlang_serialization_spec/" target="_blank">fory.apache.org/docs/specification</a></li>
</ul>
<p><strong>Community:</strong></p>
<ul>
<li>GitHub: <a href="https://github.com/apache/fory" target="_blank">apache/fory</a></li>
<li>Slack: <a href="https://join.slack.com/t/fory-project/shared_invite/zt-1u8soj4qc-ieYEu7ciHOqA2mo47llS8A" target="_blank">Join our community</a></li>
<li>License: Apache License 2.0</li>
</ul></div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>