<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Agent Smith – Open Source Agent That Turns Issues into Pull Requests – codingsoul</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Agent Smith – Open Source Agent That Turns Issues into Pull Requests – codingsoul</h1>
  <div class="metadata">
    Source: Hacker News Show | Date: 2/19/2026 11:47:58 AM | <a href="https://codingsoul.org/2026/02/19/agent-smith-open-source-agent-that-turns-issues-into-pull-requests/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div> <p>Agent Smith is an open source AI coding agent. You point it at a ticket — GitHub Issue, Azure DevOps Work Item, Jira, GitLab — and it clones your repo, analyzes the codebase, generates an implementation plan, writes the code, runs tests, and opens a pull request. Ticket in, PR out. Fully automated.</p> <p>You say, you’ve seen that before, what’s the difference? </p> <p>It runs on <em>your</em> infrastructure. No <em>SaaS</em>, no account, no <em>subscription</em>. You bring your<strong> own API key</strong> (Claude, OpenAI, or Gemini), configure your repo, and let it run — locally, in <strong>Docker</strong>, on your <strong>K8s cluster</strong>, or as a <strong>GitHub Action</strong>. The entire codebase, including all prompts and architecture docs, is open source.</p> <p>I built it in a few days using structured prompts and an AI coding assistant. The same approach the agent uses on your tickets is the approach I used to build it. Have a look here in the <a href="https://github.com/holgerleichsenring/agent-smith">agent smith repository</a>. </p> <hr> <h2>TL;DR — Try It</h2> <figure><img src="https://codingsoul.org/wp-content/uploads/2026/02/image-1.png" alt=""></figure> <p><strong>Docker:</strong></p> <pre><code>docker run --rm \ -e ANTHROPIC_API_KEY="$ANTHROPIC_API_KEY" \ -e GITHUB_TOKEN="$GITHUB_TOKEN" \ -v $(pwd)/config:/app/config \ agentsmith:latest --headless "fix #42 in my-project"
</code></pre> <p><strong>Local:</strong></p> <pre><code>dotnet run --project src/AgentSmith.Host -- "fix #42 in my-project"
</code></pre> <p>Configure your project in <code>agentsmith.yml</code>, point it at your repo, and go. GitHub, Azure DevOps, GitLab, Jira — all supported. Nothing leaves your infrastructure except the LLM API calls.</p> <hr> <h2>The Shift</h2> <p>Here’s what I believe is happening right now, and why I built this.</p> <p>The work of software development is shifting. Not disappearing — shifting. The leverage you have as a developer is moving away from writing implementation code and toward structuring the context that makes good implementation possible.</p> <p>That means writing <em><strong>precise tickets</strong></em> that a machine can act on. <strong><em>Defining coding principles</em></strong> that produce consistent output. <strong><em>Documenting architecture decisions </em></strong>as machine-readable context, not just human-readable afterthoughts. Reviewing and steering instead of line-by-line typing.</p> <p>This requires <em>more</em> engineering discipline, not less. Garbage context in, garbage code out. The quality of your output no longer depends on how fast you type — it depends on how well you structure your intent.</p> <p>Agent Smith is my attempt to put this into practice. Not as a prototype or a demo, but as a tool I actually use. And the way I built it proves the point: I structured (by now) 17 phases of architecture prompts, defined strict coding principles, and let an AI assistant generate the implementation. The same workflow Agent Smith now runs on your tickets is the workflow I used to build Agent Smith itself.</p> <p>There will always be vibe coding in the IDE. There will always be problems where you don’t even consider an agent. But for well-scoped, ticket-driven work, I guess everybody has a lot of that in his backlog, the speed-up is real. </p> <p>And what’s coming next makes it more interesting: interactive agents that ask clarifying questions in Slack or Teams, where the conversation happens where your team already works. Not fire-and-forget, but a dialogue at a higher level of abstraction.</p> <hr> <h2>Why Context Is Everything</h2> <p>The difference between an agent that produces garbage and one that produces usable code is not the model. It’s the context.</p> <p>Agent Smith loads a <code>coding-principles.md</code> at runtime and injects it into every LLM call:</p> <ul>
<li>Max 20 lines per method. No exceptions.</li> <li>Max 120 lines per class. Split when needed.</li> <li>SOLID principles. Dependency inversion everywhere.</li> <li>No magic strings. No god classes. No commented-out code.</li>
</ul> <p>These aren’t suggestions. They’re constraints the agent treats as non-negotiable. With these principles in context, the LLM produces small, focused classes with clean interfaces. Without them, you get the same 500-line spaghetti that every model defaults to.</p> <p>But coding principles alone aren’t enough. Agent Smith uses a full context stack:</p> <p><strong>Architecture prompts.</strong> 17 phases of structured design documents define the domain, contracts, patterns, and boundaries. The agent doesn’t decide the architecture — it follows it. These prompts are in the repo. You can read every one of them.</p> <p><strong>Model registry.</strong> A cost-aware routing layer sends scout tasks (file discovery) to cheap, fast models and primary coding tasks to more capable ones. You don’t burn expensive tokens on work that doesn’t need them.</p> <p><strong>Prompt caching and context compaction.</strong> System prompts get cached across agentic loop iterations. When conversations grow too long, a summarization model compresses earlier context while preserving what matters. The agent can work on large codebases without blowing up the context window or your budget.</p> <p>You can swap all of this. Different coding principles, different models, different providers. The config file drives everything.</p> <hr> <h2>How I Built It</h2> <p>Agent Smith was built with the same approach it now uses on your tickets. That’s not a coincidence — it’s the point.</p> <p>I started by thinking about where the gaps are. There are plenty of AI coding tools, but most are either locked behind SaaS subscriptions or tightly coupled to a single platform. I wanted something self-hosted, provider-agnostic, and open — something you can point at your own infrastructure and just run. </p> <p>So I defined an architecture. Clean Architecture, DDD, command/handler pattern for the pipeline, provider abstractions for everything. Then I wrote the coding principles — the same <code>coding-principles.md</code> that Agent Smith now loads at runtime. 20 lines per method, 120 per class, SOLID, no exceptions. These became the rules for both me and the agent.</p> <p>From there, I broke the work into phases. Each phase got its own structured prompt: domain entities, contracts, providers, factories, pipeline execution, CLI, Docker. One phase at a time, each building on the last. An AI coding assistant in the IDE did the implementation — I provided the context, reviewed the output, and steered.</p> <p>After phase 8, I ran it for the first time. Agent Smith’s first task was to work on itself — I pointed it at its own repo and told it to implement Issue #1: “Add a README.” A few small fixes later, it worked. The agent cloned its own code, read its own architecture, and wrote its own documentation.</p> <blockquote>
<blockquote>
<p>This was the moment I was smiling. Some very small issues, mostly due to my not-so-big-amount-of-tokens in Claude API usage. But if just worked.</p>
</blockquote>
</blockquote> <p>Three days and a few more phases later, it was running on a second provider. Azure DevOps instead of GitHub, Docker instead of local, headless mode. Complete success on the first try — PR created, ticket closed, comment posted. The numbers from that run:</p> <figure><table><thead><tr><th>Metric</th><th>Value</th></tr></thead><tbody><tr><td>Scout model</td><td>claude-haiku-4-5</td></tr><tr><td>Primary model</td><td>claude-sonnet-4</td></tr><tr><td>Input tokens</td><td>7,978</td></tr><tr><td>Output tokens</td><td>1,110</td></tr><tr><td>Cache hit rate</td><td>37%</td></tr><tr><td>Cost</td><td>fractions of a cent</td></tr></tbody></table></figure> <p>Same pipeline, different provider, same result. The architecture held. And the meta-lesson was clear: structured context and AI-assisted execution isn’t just how Agent Smith works on tickets — it’s how Agent Smith was built.</p> <p>Have a lock at how to start it and the resulting log.</p> <pre><code>source .env &amp;&amp; docker run --rm \<br> -e ANTHROPIC_API_KEY="$ANTHROPIC_API_KEY" \<br> -e AZURE_DEVOPS_TOKEN="$AZURE_DEVOPS_TOKEN" \<br> -v $(pwd)/config:/app/config \<br> -v ~/.ssh:/home/agentsmith/.ssh:ro \<br> agentsmith:latest \<br> --headless "fix #54 in agent-smith-test" 2&gt;&amp;1 </code></pre> <pre><code>info: AgentSmith.Application.UseCases.ProcessTicketUseCase[0]<br> Processing input: fix #54 in agent-smith-test<br>info: AgentSmith.Application.Services.RegexIntentParser[0]<br> Parsed intent: Ticket=54, Project=agent-smith-test<br>info: AgentSmith.Application.UseCases.ProcessTicketUseCase[0]<br> Running pipeline 'fix-bug' for project 'agent-smith-test', ticket 54<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> Starting pipeline with 9 commands<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [1/9] Executing FetchTicketCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing FetchTicketContext...<br>info: AgentSmith.Application.Commands.Handlers.FetchTicketHandler[0]<br> Fetching ticket 54...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> FetchTicketContext completed: Ticket 54 fetched from AzureDevOps<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [1/9] FetchTicketCommand completed: Ticket 54 fetched from AzureDevOps<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [2/9] Executing CheckoutSourceCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing CheckoutSourceContext...<br>info: AgentSmith.Application.Commands.Handlers.CheckoutSourceHandler[0]<br> Checking out branch fix/54...<br>info: AgentSmith.Infrastructure.Providers.Source.AzureReposSourceProvider[0]<br> Cloning https://dev.azure.com/holgerleichsenring/agent-smith-test/_git/agent-smith-test to /tmp/agentsmith/azuredevops/agent-smith-test/agent-smith-test<br>info: AgentSmith.Infrastructure.Providers.Source.AzureReposSourceProvider[0]<br> Checked out branch fix/54 in /tmp/agentsmith/azuredevops/agent-smith-test/agent-smith-test<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> CheckoutSourceContext completed: Repository checked out to /tmp/agentsmith/azuredevops/agent-smith-test/agent-smith-test<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [2/9] CheckoutSourceCommand completed: Repository checked out to /tmp/agentsmith/azuredevops/agent-smith-test/agent-smith-test<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [3/9] Executing LoadCodingPrinciplesCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing LoadCodingPrinciplesContext...<br>info: AgentSmith.Application.Commands.Handlers.LoadCodingPrinciplesHandler[0]<br> Loading coding principles from ./config/coding-principles.md...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> LoadCodingPrinciplesContext completed: Loaded coding principles (3524 chars)<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [3/9] LoadCodingPrinciplesCommand completed: Loaded coding principles (3524 chars)<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [4/9] Executing AnalyzeCodeCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing AnalyzeCodeContext...<br>info: AgentSmith.Application.Commands.Handlers.AnalyzeCodeHandler[0]<br> Analyzing code in /tmp/agentsmith/azuredevops/agent-smith-test/agent-smith-test...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> AnalyzeCodeContext completed: Code analysis completed: 1 files found<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [4/9] AnalyzeCodeCommand completed: Code analysis completed: 1 files found<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [5/9] Executing GeneratePlanCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing GeneratePlanContext...<br>info: AgentSmith.Application.Commands.Handlers.GeneratePlanHandler[0]<br> Generating plan for ticket 54...<br>info: AgentSmith.Application.Commands.Handlers.GeneratePlanHandler[0]<br> Plan generated: Create a MIT LICENSE file at the repository root with standard MIT license text, current year, and placeholder author name (1 steps)<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> GeneratePlanContext completed: Plan generated with 1 steps<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [5/9] GeneratePlanCommand completed: Plan generated with 1 steps<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [6/9] Executing ApprovalCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing ApprovalContext...<br>info: AgentSmith.Application.Commands.Handlers.ApprovalHandler[0]<br> Plan summary: Create a MIT LICENSE file at the repository root with standard MIT license text, current year, and placeholder author name<br> [1] Create: Create LICENSE file with standard MIT license text using current year (2024) and placeholder author name<br>info: AgentSmith.Application.Commands.Handlers.ApprovalHandler[0]<br> Headless mode: auto-approving plan<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> ApprovalContext completed: Plan approved by user<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [6/9] ApprovalCommand completed: Plan approved by user<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [7/9] Executing AgenticExecuteCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing AgenticExecuteContext...<br>info: AgentSmith.Application.Commands.Handlers.AgenticExecuteHandler[0]<br> Executing plan with 1 steps...<br>info: AgentSmith.Infrastructure.Providers.Agent.ClaudeAgentProvider[0]<br> Running scout agent with model claude-haiku-4-5-20251001<br>info: AgentSmith.Infrastructure.Providers.Agent.ClaudeAgentProvider[0]<br> Scout agent starting file discovery with model claude-haiku-4-5-20251001<br>info: AgentSmith.Infrastructure.Providers.Agent.ClaudeAgentProvider[0]<br> Scout discovered 1 relevant files using 6276 tokens<br>info: AgentSmith.Infrastructure.Providers.Agent.ClaudeAgentProvider[0]<br> Agent completed after 4 iterations<br>info: AgentSmith.Infrastructure.Providers.Agent.ClaudeAgentProvider[0]<br> Token usage summary: 7978 input, 1110 output, 1564 cache-create, 4692 cache-read, Cache hit rate: 37.0 %, Iterations: 9<br>info: AgentSmith.Infrastructure.Providers.Agent.ClaudeAgentProvider[0]<br> Agentic execution completed with 1 file changes<br>info: AgentSmith.Infrastructure.Providers.Agent.ClaudeAgentProvider[0]<br> Token usage summary: 7978 input, 1110 output, 1564 cache-create, 4692 cache-read, Cache hit rate: 37.0 %, Iterations: 9<br>info: AgentSmith.Application.Commands.Handlers.AgenticExecuteHandler[0]<br> Agentic execution completed: 1 files changed<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> AgenticExecuteContext completed: Agentic execution completed: 1 files changed<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [7/9] AgenticExecuteCommand completed: Agentic execution completed: 1 files changed<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [8/9] Executing TestCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing TestContext...<br>info: AgentSmith.Application.Commands.Handlers.TestHandler[0]<br> Running tests for 1 changes...<br>warn: AgentSmith.Application.Commands.Handlers.TestHandler[0]<br> No test framework detected, skipping tests<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> TestContext completed: No test framework detected, skipping tests<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [8/9] TestCommand completed: No test framework detected, skipping tests<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [9/9] Executing CommitAndPRCommand...<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> Executing CommitAndPRContext...<br>info: AgentSmith.Application.Commands.Handlers.CommitAndPRHandler[0]<br> Creating PR for ticket 54 with 1 changes...<br>info: AgentSmith.Infrastructure.Providers.Source.AzureReposSourceProvider[0]<br> Committed and pushed changes: fix: Add a LICENSE file with MIT license text (#54)<br>info: AgentSmith.Infrastructure.Providers.Source.AzureReposSourceProvider[0]<br> Pull request created: https://dev.azure.com/holgerleichsenring/agent-smith-test/_git/agent-smith-test/pullrequest/4<br>info: AgentSmith.Application.Commands.Handlers.CommitAndPRHandler[0]<br> Pull request created: https://dev.azure.com/holgerleichsenring/agent-smith-test/_git/agent-smith-test/pullrequest/4<br>info: AgentSmith.Application.Commands.Handlers.CommitAndPRHandler[0]<br> Ticket 54 closed with summary<br>info: AgentSmith.Application.Commands.CommandExecutor[0]<br> CommitAndPRContext completed: Pull request created: https://dev.azure.com/holgerleichsenring/agent-smith-test/_git/agent-smith-test/pullrequest/4<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> [9/9] CommitAndPRCommand completed: Pull request created: https://dev.azure.com/holgerleichsenring/agent-smith-test/_git/agent-smith-test/pullrequest/4<br>info: AgentSmith.Application.Services.PipelineExecutor[0]<br> Pipeline completed successfully<br>info: AgentSmith.Application.UseCases.ProcessTicketUseCase[0]<br> Ticket 54 processed successfully: Pipeline completed successfully<br>Success: Pipeline completed successfully</code></pre> <blockquote>
<p><em><strong>And it worked like a charm. </strong></em></p>
</blockquote> <hr> <h2>What’s Next</h2> <p>Agent Smith currently works as a CLI tool and GitHub Action. <strong>Interactive chat interfaces for Slack, Teams, and other platforms are in progress</strong> — agents that run as <strong>ephemeral containers on K8s, stream progress in real time</strong>, and ask you <strong>questions</strong> when they need clarification.</p> <p>The code is open source. The prompts are in the repo. All 17 phases, the coding principles, the architecture docs — everything that makes it work is there for you to read, fork, and adapt.</p> <p><strong><a href="https://github.com/holgerleichsenring/agent-smith">github.com/holgerleichsenring/agent-smith</a></strong></p> </div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>