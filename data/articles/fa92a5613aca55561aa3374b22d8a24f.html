<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Introducing SignSaboteur: forge signed web tokens with ease</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Introducing SignSaboteur: forge signed web tokens with ease</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 5/22/2024 2:37:00 PM | Lang: EN |
    <a href="https://portswigger.net/research/introducing-signsaboteur-forge-signed-web-tokens-with-ease" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div> <div> <p><img alt="Zakhar Fedotkin" src="https://portswigger.net/content/images/profiles/callout_zakhar_fedotkin_114px.png"></p>
</div> <ul> <li> <p><span></span><strong>Published: </strong>22 May 2024 at 12:37 UTC</p> </li> <li> <p><strong>Updated: </strong>04 June 2024 at 07:25 UTC</p> </li> <li> </li> </ul> <p><img src="https://portswigger.net/cms/images/48/da/9ae0-article-d5e7c9cc-6a56-4700-88d7-15c3eddad95d.png" alt="SignSaboteur graphics">Signed web tokens are widely used for stateless authentication and authorization throughout the web. The most popular format is JSON Web Tokens (JWT) which we've already covered in depth, but beyond that a diverse ecosystem of standards thrives, each with its own implementation of data storage and security.<br></p><p>To help assess these, we've released a new open source extension for Burp Suite called SignSaboteur. This tool is designed to automate the attacks discussed here, ensuring that you no longer overlook any insecure configurations.</p><h2>Brief overview</h2><p>SignSaboteur is a Burp Suite extension for editing, signing, verifying, and attacking signed tokens. It supports different types of tokens, including Django, Flask, and Express. </p><p>The extension provides automatic detection and in-line editing of tokens within HTTP request / response pairs and WebSocket messages, signing of tokens and automation of brute force attacks. </p><p>SignSaboteur includes its own prebuilt word lists for known default secret keys and salts. You can extend them with your dictionary. JSON encoded strings are supported too, so you can include even non ASCII secrets keys. You can also save known keys for future brute force attacks.</p><p>You can modify the signed tokens in the Proxy and Repeater message editors. There are a number of built-in handy editors for JSON, timestamps and HEX strings.</p><p>But the true power of the tool is the unknown signed strings mode - more on that later.</p><h2>Methodology</h2><p> To exploit a signed token, you usually need to discover the secret key. These may be disclosed in source code, configuration files, documentation pages, and error messages.
</p><p>These papers provide a good overview of the different attacks:</p><ul> <li> <a href="https://ian.sh/airflow">Authentication Bypass in Apache Airflow CVE-2020-17526</a> </li> <li> <a href="https://blog.paradoxis.nl/defeating-flasks-session-management-65706ba9d3ce">Baking Flask cookies with your secrets</a> </li> <li> <a href="https://github.com/getredash/redash/security/advisories/GHSA-g8xr-f424-h2rv">Redash Insecure default configuration</a> </li> <li> <a href="https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/">Remote Code Execution on a Facebook server</a> </li></ul><p> To detect and exploit signed web tokens, we recommend the following methodology:
</p>
<ul> <li> Observe request/response cookie, url, body parameters for potential signed tokens: base64 encoded or hex strings of known length common for HMAC </li> <li> If a signed web token contains a timestamp, observe whether the signature changes when the token expires </li> <li>Try to identify any frameworks the target is using <ul> <li> If the framework was identified, search for common secret keys and salts, for example hardcoded values or configuration files, including docker environment variables </li> <li>Update your wordlists with found information</li> </ul> </li> <li>Try to brute force the token with different derivation techniques</li> <li>If you discover the secret key try the following attacks: <ul> <li> If the token structure is known, change id to high privilege account, usually <b>1</b> </li> <li> If the token structure is unknown, brute force parameters names with a commonly used list: <b>id</b>, <b>user_id</b>, <b>username</b>, etc. Note, that SignSaboteur extension supports some of the mentioned techniques </li> </ul> </li> <li> If you couldn't find the secret key, try to re-sign a message with a default key and send it to the application. If the server accepts your forged message that means that a vulnerability exists. Follow the steps mentioned for a known secret key. </li> <li> If the server accepts your forged message, visit all pages with a new token and also try to get access to administrative functionality. </li></ul> <h2>Configuring brute force attacks</h2><p>Brute force attacks are configured for each type of signed token. SignSaboteur enables you to use different strategies to find the secret key and salt:</p><ul><li>Known keys - SignSaboteur uses previously found secret keys only.</li><li>Fast - SignSaboteur uses the default hashing algorithm and key derivation.</li><li>Balanced - SignSaboteur uses all known key derivation techniques, except slow PBKDF2 Hmac with a big number of iterations.</li><li>Deep - SignSaboteur uses all key derivation techniques, including different types supported by Ruby on Rails framework.</li></ul><h2>Configuring authorization bypass attacks</h2><p>As soon as you've identified the secret key, you can use the extension to run a number of authorization bypass attacks. All of these attacks can be used together:</p><ul><li>User claims - A set of <a href="https://portswigger.net/web-security/oauth/openid">OpenID</a> Connect <a href="https://openid.net/specs/openid-connect-core-1_0.html%23StandardClaims">Standard Claims</a>. SignSaboteur tries to inject a collaborator payload for different potential <a href="https://portswigger.net/web-security/ssrf">SSRF</a> vulnerable claims, like the user's picture. For more information please see the Portswigger Web Security Academy <a href="https://portswigger.net/web-security/oauth/openid">OpenID Connect</a> labs.</li><li>Wrapped user claims - This is similar to the user claims attack but SignSaboteur injects the collaborator payload into the <span>user</span> JSON attribute.</li><li>Username and password claims - Another common way to store user details is using <span>username</span> and <span>password</span> JSON attributes. SignSaboteur generates a placeholder for the admin user. </li><li>Flask claims - Flask authenticated user session information if stored at client side should include <span>id</span> and <span>_id</span> and <span>user_id</span> or <span> _user_id </span>JSON attribute. SignSaboteur generates a session for the first user, usually admin.</li><li>Express claims - The Express framework uses the passport JSON attribute to store user details. SignSaboteur generates a placeholder for the admin user.</li><li>Account user claims - Some frameworks use account wrapper to store information about authenticated users. For exploitation, it might be required to use authenticated claims too.</li><li>Authenticated claims - Most known authenticated flags. </li><li>User access_token - SignSaboteur generates JWT OpenID connect ID token signed with the same key and same hashing algorithm without any key derivation performed.
</li></ul><h2>Getting started </h2><p>First you need to install SignSaboteur in Burp Suite. Do this from the BApp Store under the <b>Extensions</b> tab. Of course you can also build the extension from <a href="https://github.com/d0ge/sign-saboteur">source code</a>. </p><p>To use the extension, open any HTTP request / response pair with a signed web token, then go to the <b>SignSaboteur</b> tab. Messages that include signed web tokens are automatically highlighted in the <b>Proxy &gt; HTTP history</b> tab. </p><h2>Basic use case</h2><p>In the <b>SignSaboteur</b> tab, you can view all signed web tokens that are identified by the extension. These appear in the <b>Token</b> dropdown. Each web signed token’s type supports the fast brute force attack mode. That mode uses known message and derivation methods only. </p><p>If the extension finds a secret key and salt, you'll see a new secret key dialog. You can use known keys for future attacks. To do so, click <b>Brute Force &gt; Known keys </b> or click <b>Attack</b> and select the key from the Signing keys dropdown. </p><p>To change keys, go to the <b>SignSaboteur &gt; Wordlist</b> tab. </p><h2>Settings</h2><p>You can configure the search strategy to suit your preferences in the SignSaboteur &gt; Settings tab. A list of all supported tokens is available for your reference. Please note that some tokens are disabled by default to help reduce noise.</p><h2>Unknown signed web tokens use case</h2><p>When you select <b>Unknown</b> in the <b>Enabled signers</b> menu, the extension looks for patterns that match the size of common hashing functions. Some message payloads might be incorrectly identified by the SignSaboteur. You can manually change message and separator values to solve the issue. The extension supports different message and key derivation techniques with Brute Force attacks, so you don’t have to manually change them. </p><p>To find the secret key of an unknown signed token, go to the Unknown tab, click <b>Brute force</b> and choose from <b>Balanced</b> or <b>Deep</b> mode. </p><p>A word of caution, the deep brute force mode supports slow hashing functions like Password-Based Key Derivation Function 2. Use it with small wordlists only, otherwise the task will take too long.</p><p><img src="https://portswigger.net/cms/images/68/59/a6f3-article-signsaboteurrubybruteforce.png" alt="Ruby signed token at SignSaboteur's attack view"><br></p><p><img src="https://portswigger.net/cms/images/d7/0f/e094-article-signsaboteurrubywhitemessage.png" alt="Ruby signed token at SignSaboteur's editor view"><br></p><h2>Small demo</h2><p>This short GIF demonstrates how to find the unknown secret key of a Flask test application, modify the session token, and re-sign it.</p><p>
<img src="https://portswigger.net/cms/images/49/47/6cd2-article-high.gif" alt="SignSaboteur showcase"><br></p><h2>Final note</h2><p>You can try the extension in action on a self hosted lab available at Github <a href="https://github.com/PortSwigger/research-labs">repository</a>. Good luck and have fun!</p> <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollStep(-1)">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollStep(1)">▼</button>
  </div>
  <script>
    function scrollStep(direction) {
      var step = Math.max(220, Math.round(window.innerHeight * 0.72));
      window.scrollBy({ top: direction * step, behavior: 'smooth' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up') scrollStep(-1);
      if (data.direction === 'down') scrollStep(1);
      if (data.direction === 'top') window.scrollTo({ top: 0, behavior: 'smooth' });
      if (data.direction === 'bottom') window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
    });
  </script>
</body>
</html>