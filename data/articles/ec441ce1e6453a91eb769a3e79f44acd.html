<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bypassing WAFs with the phantom $Version cookie</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Bypassing WAFs with the phantom $Version cookie</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 12/4/2024 4:03:35 PM | Lang: EN |
    <a href="https://portswigger.net/research/bypassing-wafs-with-the-phantom-version-cookie" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div> <div> <p><img alt="Zakhar Fedotkin" src="https://portswigger.net/content/images/profiles/callout_zakhar_fedotkin_114px.png"></p>
</div> <ul> <li> <p><span></span><strong>Published: </strong>04 December 2024 at 15:03 UTC</p> </li> <li> <p><strong>Updated: </strong>30 June 2025 at 16:01 UTC</p> </li> <li> </li> </ul> <p> <img src="https://portswigger.net/cms/images/92/21/a237-article-64488e2d-1d5d-45d1-92e2-395fd491f11a.png" alt="Tossing cookies">HTTP cookies often control critical website features, but their long and convoluted history exposes them to parser discrepancy vulnerabilities. In this post, I'll explore some dangerous, lesser-known features of modern cookie parsers and show how they can be abused to bypass web application firewalls. This is the first part of a series of blog posts on cookie parsing. </p><h2>Downgrading cookie parsers with $Version</h2><p>
There have been many attempts to standardize HTTP cookies, starting with the first official standard: <a href="https://datatracker.ietf.org/doc/html/rfc2109">RFC2109</a>. Even though modern browsers do not support legacy RFCs, many web servers still do. Here's an example valid <span>Cookie</span> header:
</p><p><code><span>Cookie:</span> <span>$Version</span>=<span>1</span>; <span>foo</span>=<span>"bar"</span>; <span>$Path</span>=<span>"/"</span>; <span>$Domain</span>=<span>abc</span>;</code></p><p><span>$Version</span> is a required attribute, identifying the version of the state management specification to which the cookie conforms. Other interesting attributes include <span>$Domain</span> and <span>$Path</span>, which we’ll discuss later. According to the standard, a Cookie value can include special characters like spaces, semicolons, and equal signs if they are enclosed in double quotes: </p><p> Many HTTP/1.1 header field values consist of words separated by LWS (Linear White Space) or special characters. These special characters MUST be in a quoted string to be used within a parameter value. - <a href="https://datatracker.ietf.org/doc/html/rfc2068#section-2.2">RFC 2068</a>.
</p><p>Modern frameworks analyze that header in the following ways:</p><p><code><span>Flask: </span>{<span>"foo"</span>:<span>"bar"</span>,<span>"$Version"</span>:<span>"1"</span>,<span>"$Path"</span>:<span>"/"</span>,<span>"$Domain"</span>:<span>"abc"</span>}<br><span>Django: </span>{<span>"foo"</span>:<span>"bar"</span>,<span>"$Version"</span>:<span>"1"</span>,<span>"$Path"</span>:<span>"/"</span>,<span>"$Domain"</span>:<span>"abc"</span>}<br><span>PHP: </span>{<span>"foo"</span>:<span>"\"bar\""</span>,<span>"$Version"</span>:<span>"1"</span>,<span>"$Path"</span>:<span>"\"\/\""</span>,<span>"$Domain"</span>:<span>"abc"</span>}<br><span>Ruby: </span>{<span>"foo"</span>:<span>"\"bar\""</span>,<span>"$Version"</span>:<span>"1"</span>,<span>"$Path"</span>:<span>"\"\/\""</span>,<span>"$Domain"</span>:<span>"abc"</span>}<br><span>Spring: </span>{ <span>"foo"</span>: <span>"\"bar\""</span>}
<span>SimpleCookie:	</span>{ <span>"foo"</span>: <span>"bar"</span>}
</code></p><p>As we can see, the results are messy. This mess gives us a chance to look for security weaknesses. Let’s focus on Spring Boot Starter Web 2.x.x first. It uses Apache Tomcat v. 9.0.83 by default, which processes cookie headers in the following ways:
</p><ul><li>It handles both RFC6265 and RFC2109 standards, defaulting to legacy parsing logic if a string starts with the special <span>$Version</span> attribute.
</li><li>It also supports the <span>$Path</span> and <span>$Domain</span> attributes, which may enable users to change reflected cookie attributes if they aren’t checked properly before responding.
</li><li>The parser will also unescape any character starting with backslash (<span>\</span>), as shown in the following example.
</li></ul><p><code><span>Cookie: </span><span>$Version</span>=<span>1</span>; <span>foo</span>=<span>"\b\a\r"</span>; <span>$Path</span>=<span>/abc</span>; <span>$Domain</span>=<span>example.com</span> =&gt;<br><span>Set-Cookie: </span><span>foo</span>=<span>"bar"</span>; <span>Path</span>=<span>/abc</span>; <span>Domain</span>=<span>example.com</span></code></p><p>Another good example is the Python SimpleCookie parser, which supports legacy cookie request attributes when followed by key-value pairs. This enables the injection of malicious cookie attributes in the same manner demonstrated previously. All Python-based frameworks (Flask, Django, etc.) allow quoted cookie values but don't recognize the magic strings, like <span>$Version</span>, treating it as a normal cookie name instead. They also automatically decode octal escape sequences within quoted strings as follows: </p><p> Any non-text character is translated into a 4 character sequence: a forward-slash followed by the three-digit octal equivalent of the character. - <br><a href="https://github.com/python/cpython/blob/6fc643674983e27ec5cc312f2e83468050d1d364/Lib/http/cookies.py#L149">Cookies.py</a>
</p><p>For example:</p><p><code><span>"\012"</span> &lt;=&gt; <span>\n</span><br><span>"\015"</span> &lt;=&gt; <span>\r</span><br><span>"\073"</span> &lt;=&gt; <span>;</span></code></p><h2>Bypass Web Application Firewalls (WAFs)</h2><p>
Many WAFs are not equipped to detect the techniques described above, allowing malicious payloads to be hidden within quoted strings.
</p><h3>Bypassing value analysis with quoted-string encoding<br></h3><p>In addition, quoted cookies can facilitate injection vulnerabilities, such as <a href="https://portswigger.net/web-security/sql-injection/blind%23what-is-blind-sql-injection">SQL injection</a> or <a href="https://portswigger.net/web-security/os-command-injection%23ways-of-injecting-os-commands">command injection</a>. These types of attacks often use special command separators - such as semicolons (<span>;</span>), commas (<span>,</span>), newline characters (<span>\n</span>), and backslashes (<span>\</span>). While typically restricted in cookie values, these can sometimes be manipulated to trigger vulnerabilities. Implementing this type of quoted cookie encoding can be easily achieved using a Burp Suite extension with the <a href="https://github.com/PortSwigger/burp-extensions-montoya-api-examples/blob/main/httphandler/src/main/java/example/httphandler/MyHttpHandler.java">HttpHandler interface</a>:</p><p><code><span>def</span> handleHttpRequestToBeSent(requestToBeSent):<br> result = <span>"$Version=1; "</span><br> <span>for</span> param <span>in</span> requestToBeSent.parameters:<br> result += <span>f"{param.name}=\""</span><br> <span>for </span>char <span>in </span>param.value:<br> result += <span>f"\\{char}"</span><br> result += <span>"\"; "</span><br> <span>return</span> continueWith(requestToBeSent.withAddedHeader(<span>"Cookie"</span>,result))</code></p><p>For example, the Amazon Web Services WAF blocks any request that contains any parameter inside disallowed function:</p><p><code><span>eval() =&gt; allowed</span>
<span>eval('test') =&gt; forbidden</span>
<span>"\e\v\a\l\(\'\t\e\s\t\'\)" =&gt; allowed</span>
<span>"\145\166\141\154\050\047\164\145\163\164\047\051" =&gt; allowed</span></code></p><h3>Bypassing cookie-name blocklists</h3><p> Another crucial aspect of RFC2109: a server should also accept a comma (<span>,</span>) as a separator between cookie values. This can be exploited to bypass simple WAF signatures that may not anticipate a cookie name being concealed within the value. Additionally, the specification permits any number of space or tab characters before or after the equal sign in an injected attribute-value pair, which could also be used to avoid the detection. Consider the <span>Cookie</span> header example:</p><p><code><span>$Version</span>=<span>1</span>; <span>foo</span>=<span>bar, abc</span><span> </span><span>=</span><span> </span><span>qux</span> =&gt; <span>"abc"</span>: <span>"qux"</span></code></p><h3>Bypassing value analysis with cookie splitting</h3><p>Like many other HTTP headers, the <span>Cookie</span> header can be sent multiple times in a single request. The way how a server handles multiple identical headers may then vary. For example, I sent following GET request:
</p><p><code>GET / HTTP/1.1
Host: example.com
<span>Cookie:</span> <span>param1</span>=<span>value1</span>;<br><span>Cookie:</span> <span>param2</span>=<span>value2</span>;
</code></p><p>And got the following back:</p><p><code><span>Flask: </span>{ <span>"param1"</span>: <span>"value1"</span>, <span>"</span><span>,</span><span>param2"</span>: <span>"value2"</span>}<br><span>Django: </span>{ <span>"param1"</span>: <span>"value1"</span>, <span>"</span><span>,</span><span>param2"</span>: <span>"value2"</span>}<br><span>PHP: </span>{ <span>"param1"</span>: <span>"value1"</span>, <span>"</span><span>,_</span><span>param2"</span>: <span>"value2"</span>}<br><span>Ruby: </span>{ <span>"param1"</span>: <span>"value1"</span>, <span>"</span><span>, </span><span>param2"</span>: <span>"value2"</span>}<br><span>Spring: </span>{ <span>"param1"</span>: <span>"value1"</span>, <span>"param2"</span>: <span>"value2"</span>}
</code></p><p>As we can see, Ruby, PHP, and the Python frameworks Django and Flask combine headers into a single comma-separated string (with an optional space between parameters). Quoted cookie values are also supported, which allows hiding malicious payloads by using the <span>Cookie</span> header as a multiline header continuation.</p><p>Unfortunately, the quoted strings technique does not work with PHP and Ruby. To bypass the mentioned AWS signatures, you can use the following request:</p><p><code><span>Cookie: name=eval('test') =&gt; forbidden </span>
<span>Cookie: name=eval('test//</span>
<span>Cookie: comment')</span> <span>Resulting cookie: name=eval('test//, comment') =&gt; allowed</span></code></p><h3>Automation using Burp Extensions</h3><p>We've implemented the best of these techniques in <a href="https://portswigger.net/bappstore/17d2949a985c4b7ca092728dba871943" target="_blank">Param Miner</a> for you:</p><p><img src="https://portswigger.net/cms/images/22/25/09a8-article-python.png"><img src="https://portswigger.net/cms/images/2a/90/d0c2-article-springs.png"><br></p><h2>Preventing vulnerabilities</h2><p>You can take a range of steps to prevent parser discrepancy vulnerabilities in cookies, as follows:<br></p><ul><li>Ensure that legacy support for RFC2109 is disabled on the web server unless it is explicitly required. </li><li>Validate all user inputs rigorously to identify and mitigate potentially dangerous data. This helps ensure that inputs are safe for processing within your application or when interacting with other system components. </li><li>Avoid relying on assumptions about the presence or absence of specific characters in user inputs to reduce the risk of unexpected behavior.</li></ul><h2>Want to learn more?</h2><p>This blog post is just the first part of our exploration into cookie parsing logic. To learn how these techniques can be applied in real-world scenarios to escalate vulnerabilities, be sure to check out the <a href="https://portswigger.net/research/stealing-httponly-cookies-with-the-cookie-sandwich-technique"> Stealing HttpOnly cookies with the cookie sandwich technique</a>.</p><p>
For our latest blog posts and security insights, follow us on <a href="https://x.com/portswiggerres" target="_blank">X (formerly Twitter)</a> and <a href="https://bsky.app/profile/portswiggerres.bsky.social" target="_blank">Bluesky</a>, and join the&nbsp;<a href="https://discord.com/invite/portswigger" target="_blank">official PortSwigger Discord</a>.</p><p> If you're interested in learning more about quoted cookies, take a look at my earlier research on <a href="https://btlfry.gitlab.io/notes/posts/memcached-command-injections-at-pylibmc/">the Memcached Command Injections at Pylibmc</a>
</p> <p>If you're curious about invalid characters in cookie headers,I recommend April King's&nbsp;<a href="https://grayduck.mn/2024/11/21/handling-cookies-is-a-minefield/" target="_blank">Handling Cookies is a Minefield</a> research.
</p> <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'top') scrollToTop();
      if (data.direction === 'bottom') scrollToBottom();
    });
  </script>
</body>
</html>