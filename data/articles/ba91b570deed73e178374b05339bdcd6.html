<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>How we stopped giving our AI agents raw API keys</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>How we stopped giving our AI agents raw API keys</h1>
  <div class="metadata">
    Source: Dev.to Open Source | Date: 2/20/2026 12:00:42 PM | <a href="https://dev.to/rsdouglas/how-we-stopped-giving-our-ai-agents-raw-api-keys-3o3p" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div> <p><a href="https://dev.to/rsdouglas"><img src="https://media2.dev.to/dynamic/image/width=50,height=50,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F3765694%2Fce3f4c54-df5b-4a68-815c-9bce28ce9f93.jpeg" alt="Ross Douglas"></a> </p> </div><div> <p>Autonomous agents need API access to do useful work. Our creature Secure files security issues on GitHub. The voyager genome commits code. Future creatures will need Stripe, analytics, whatever.</p> <p>The naive solution is to inject API keys as environment variables. Every container runtime supports it, every SDK can read from <code>process.env</code>, and it works on day one. It also means every creature has every key, there's no audit trail, and a prompt injection can exfiltrate credentials in a single tool call.</p> <p>We needed something better.</p> <h2> <a name="janee-a-credential-proxy-for-agents" href="#janee-a-credential-proxy-for-agents"> </a> Janee: a credential proxy for agents
</h2> <p><a href="https://github.com/rsdouglas/janee" target="_blank">Janee</a> is an MCP server that sits between agents and APIs. You store your credentials in Janee (encrypted at rest with AES-256-GCM), define capabilities with access policies, and agents call APIs by capability name. They never see raw keys.<br>
</p> <div>
<pre><code>┌──────────┐ MCP/HTTP ┌────────┐ real creds ┌──────────┐
│ Creature │ ──────────────&gt; │ Janee │ ──────────────&gt; │ External │
│ │ │ │ proxied req │ API │
└──────────┘ └────────┘ └──────────┘ no keys encrypted at rest GitHub, etc.
</code></pre>
<div>
<p> Enter fullscreen mode Exit fullscreen mode </p>
</div>
</div> <p>A creature that needs to create a GitHub issue calls:<br>
</p> <div>
<pre><code><span>await</span> <span>janee</span><span>({</span> <span>action</span><span>:</span> <span>'</span><span>execute</span><span>'</span><span>,</span> <span>capability</span><span>:</span> <span>'</span><span>secure-seed</span><span>'</span><span>,</span> <span>method</span><span>:</span> <span>'</span><span>POST</span><span>'</span><span>,</span> <span>path</span><span>:</span> <span>'</span><span>/repos/openseed-dev/openseed/issues</span><span>'</span><span>,</span> <span>body</span><span>:</span> <span>JSON</span><span>.</span><span>stringify</span><span>({</span> <span>title</span><span>:</span> <span>'</span><span>Security finding</span><span>'</span><span>,</span> <span>body</span><span>:</span> <span>'</span><span>...</span><span>'</span> <span>})</span>
<span>});</span>
</code></pre>
<div>
<p> Enter fullscreen mode Exit fullscreen mode </p>
</div>
</div> <p>Janee looks up the <code>secure-seed</code> capability, decrypts the GitHub App private key, mints a short-lived installation token, injects it into the request, and proxies to GitHub. The creature never touches the key. Janee logs the request. If something goes wrong, you revoke access in one place.</p> <h2> <a name="identity-without-custom-plumbing" href="#identity-without-custom-plumbing"> </a> Identity without custom plumbing
</h2> <p>The tricky part with multiple agents is identity. Which creature is making the request? Early prototypes used custom HTTP headers (<code>X-Agent-ID</code>), but any client can set any header.</p> <p>We landed on something simpler: the MCP protocol already has an <code>initialize</code> handshake where clients send <code>clientInfo.name</code>. Each creature sets this to <code>creature:{name}</code> when it opens a session. Janee captures it from the transport layer, not from tool arguments the client controls.<br>
</p> <div>
<pre><code><span>const</span> <span>transport</span> <span>=</span> <span>new</span> <span>StreamableHTTPClientTransport</span><span>(</span><span>url</span><span>);</span>
<span>await</span> <span>client</span><span>.</span><span>connect</span><span>(</span><span>transport</span><span>);</span>
<span>// clientInfo.name = "creature:secure" sent during initialize</span>
</code></pre>
<div>
<p> Enter fullscreen mode Exit fullscreen mode </p>
</div>
</div> <p>Identity resolution uses the same mechanism regardless of transport: stdio, HTTP, in-memory. No extra headers, no extra arguments. Just MCP.</p> <h2> <a name="access-control-least-privilege-by-default" href="#access-control-least-privilege-by-default"> </a> Access control: least privilege by default
</h2> <p>With identity sorted, access control is straightforward. In <code>~/.janee/config.yaml</code>:<br>
</p> <div>
<pre><code><span>server</span><span>:</span> <span>defaultAccess</span><span>:</span> <span>restricted</span> <span>capabilities</span><span>:</span> <span>secure-seed</span><span>:</span> <span>service</span><span>:</span> <span>secure-seed</span> <span>allowedAgents</span><span>:</span> <span>[</span><span>"</span><span>creature:secure"</span><span>]</span> <span>autoApprove</span><span>:</span> <span>true</span>
</code></pre>
<div>
<p> Enter fullscreen mode Exit fullscreen mode </p>
</div>
</div> <p><code>defaultAccess: restricted</code> means capabilities without an explicit <code>allowedAgents</code> list are hidden from all agents. The <code>secure-seed</code> capability (backed by a GitHub App with repo access to openseed-dev/openseed) is only visible to <code>creature:secure</code>. Other creatures calling <code>list_services</code> won't even know it exists.</p> <p>If a creature creates a credential at runtime (via the <code>manage_credential</code> tool), it defaults to <code>agent-only</code>. Only the creating creature can use it. It can explicitly grant access to other creatures, but the default is isolation.</p> <h2> <a name="multiple-creatures-isolated-sessions" href="#multiple-creatures-isolated-sessions"> </a> Multiple creatures, isolated sessions
</h2> <p>OpenSeed runs multiple creatures concurrently. The orchestrator spawns Janee once as a child process in HTTP mode. Each creature gets its own MCP session. Janee creates a fresh Server and Transport instance per <code>initialize</code> handshake, following the <a href="https://github.com/modelcontextprotocol/typescript-sdk" target="_blank">official MCP SDK pattern</a>.</p> <p>Creature A's session state, identity, and access decisions are completely isolated from creature B's. No shared state, no last-writer-wins, no cross-talk.</p> <h2> <a name="the-real-example-secure-files-a-github-issue" href="#the-real-example-secure-files-a-github-issue"> </a> The real example: Secure files a GitHub issue
</h2> <p>Our creature Secure runs the dreamer genome. Its job is to audit OpenSeed for security issues. When it finds something, it needs to create a GitHub issue, which requires authenticating as a GitHub App installation.</p> <p>The flow:</p> <ol>
<li>We created a GitHub App (<code>secure-seed</code>) with repo access to <code>openseed-dev/openseed</code>
</li>
<li>The app's credentials (App ID, private key, installation ID) are stored in Janee</li>
<li>
<code>~/.janee/config.yaml</code> maps a <code>secure-seed</code> capability to this app, restricted to <code>creature:secure</code>
</li>
<li>Secure's genome includes a <code>janee</code> tool that handles MCP session management</li>
<li>When Secure finds an issue, it calls <code>execute</code> with the <code>secure-seed</code> capability</li>
<li>Janee mints a short-lived GitHub installation token (1hr TTL) and proxies the request</li>
</ol> <p>Secure never sees the private key. It can't mint tokens for repos it shouldn't access. If we need to rotate the key, we update Janee. No creature code changes.</p> <h2> <a name="whats-next" href="#whats-next"> </a> What's next
</h2> <p>This is the foundation. The obvious next steps:</p> <ul>
<li>
<strong>Web UI for secret management</strong>: manage Janee credentials from the OpenSeed dashboard instead of editing YAML</li>
<li>
<strong>GitHub App creation from the UI</strong>: the <a href="https://www.npmjs.com/package/@true-and-useful/create-gh-app" target="_blank"><code>create-gh-app</code></a> package already handles the manifest flow; wiring it into the UI would make onboarding new GitHub integrations trivial</li>
<li>
<strong>Hardened identity</strong>: today <code>clientInfo.name</code> is self-asserted. The MCP spec doesn't yet define authenticated identity, but when it does, Janee's identity priority chain is designed to slot in verified identity at the top</li>
</ul> <p>If you're building autonomous agents that need API access, consider putting a proxy in front of your keys. Your agents don't need them. They just need the responses.</p> <p><a href="https://github.com/rsdouglas/janee" target="_blank">Janee on GitHub</a> · <a href="https://www.npmjs.com/package/@true-and-useful/janee" target="_blank">Janee on npm</a> · <a href="https://github.com/openseed-dev/openseed" target="_blank">OpenSeed</a></p> </div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>