<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Shiro — Browser OS</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Shiro — Browser OS</h1>
  <div class="metadata">
    Source: Hacker News Show | Date: 2/18/2026 10:46:05 AM | <a href="https://shiro.computer/about" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: FR
  </div>
  <div class="content">
    <div><article> <a href="https://shiro.computer/">← shiro.computer</a> <p> A static HTML file that boots into something resembling a Unix shell.<span>~420 KB gzipped. All JavaScript and CSS are inlined into a single document — no external assets, no CDN, no build artifacts to coordinate.</span> It has pipes, redirects, a persistent filesystem, and over 200 commands — just enough to be useful, not enough to fool anyone into thinking it's a real operating system. </p> <p> Everything runs client-side. The shell, filesystem, editors, git, and npm are all JavaScript running in your browser — the page works with no server at all. But certain features need a network path: Claude Code calls the Anthropic API, <code>git clone</code> fetches remote repos, and <code>npm install</code> downloads packages. Those requests route through a CORS proxy on shiro.computer because browsers block direct cross-origin calls. </p> <p> It exists primarily as a host for <a href="https://docs.anthropic.com/en/docs/claude-code">Claude Code</a>. The idea was to shim enough of Node.js and enough of the standard tools that an AI coding agent could work inside a browser tab: reading files, making edits, searching code, serving apps. It mostly works. </p> <p> <strong>Experimental.</strong> Claude Code runs with <code>--dangerously-skip-permissions</code> — every tool call is auto-approved with no confirmation. Because API requests pass through the CORS proxy, your Anthropic credentials transit an intermediary. Do not use this with sensitive data, secrets, or anything you wouldn't paste into a public terminal. Performance is unreliable; shims break in unexpected ways. Treat this as a demo, not a production environment. </p> <p> If you'd rather just try it: <a href="https://shiro.computer/">shiro.computer</a>. </p> <p>loading shiro…</p> <section> <p><span>Pipes</span><span>pipes, redirects, and shell plumbing</span></p> <div> <h2>Pipes</h2> <p>Pipes, redirects, and the usual shell plumbing.</p> </div> </section> <section> <p><span>Files persist</span><span>stored in IndexedDB, survives reloads</span></p> <div> <h2>Files persist</h2> <p>Stored in IndexedDB. Survives page reloads.</p> </div> </section> <section> <p>The commands above are JavaScript reimplementations. The filesystem is IndexedDB wearing a POSIX costume.<span>stat, readdir, readFile, writeFile, mkdir, symlink, chmod, glob — enough of the POSIX surface that isomorphic-git and npm can work against it without modification.</span> Files survive page reloads, and each subdomain (<code>app.shiro.computer</code>, <code>game.shiro.computer</code>) gets its own isolated storage courtesy of the browser's same-origin policy.</p> </section> <section> <p><span>Text tools</span><span>grep, sort, cut, awk</span></p> <div> <h2>Text tools</h2> <p>grep, sort, cut, awk — the standard toolkit.</p> </div> </section> <section> <p><span>Git</span><span>local repository operations via isomorphic-git</span></p> <div> <h2>Git</h2> <p>Local repository operations via isomorphic-git.</p> </div> </section> <section> <p>Git operations use <a href="https://isomorphic-git.org/">isomorphic-git</a>, a pure-JavaScript implementation. Local operations — init, add, commit, diff, log, branch — need no server at all. Cloning from GitHub requires a CORS proxy, since browsers can't make cross-origin git HTTP requests directly.<span>The production server at shiro.computer is about 400 lines of Node.js. It serves the static file and proxies API routes (Anthropic, GitHub, OAuth), handles WebRTC signaling, git CORS, and a WebSocket relay for encrypted group networking.</span></p> </section> <section> <p><span>Serve a page</span><span>write HTML, serve it, edit in place</span></p> <div> <h2>Serve a page</h2> <p>Write HTML, serve it, edit in place.</p> </div> <div> <p>preview</p> <p><span>appears when demo runs</span></p> </div> </section> <section> <p>Web applications are served inside the browser using virtual servers that intercept fetch requests. No actual HTTP server is involved. The <code>page</code> command lets you interact with served apps programmatically — clicking buttons, reading text, evaluating JavaScript — which is how Claude Code tests the things it builds.</p> </section> <section> <p><span>Interact with an app</span><span>page command, click &amp; read DOM, then commit</span></p> <div> <h2>Interact with an app</h2> <p>Serve an app, use <code>page</code> to click and read DOM elements, then commit.</p> </div> </section> <section> <p><span>Vi editor</span><span>create, edit, search, and serve — all from vi</span></p> <div> <h2>Vi editor</h2> <p>Create a file with vi, edit it, serve it.</p> </div> </section> <section> <p><span>Nano editor</span><span>cut, paste, search, save with Ctrl shortcuts</span></p> <div> <h2>Nano editor</h2> <p>Edit files with nano. Cut, paste, search, save.</p> </div> </section> <section> <h2>Advanced workflow</h2> <p>The <code>hc</code> command navigates DOM trees with a token-efficient shorthand.<span>Hypercompact: <code>hc open</code> parses HTML from disk, <code>hc q</code> runs CSS selectors, <code>hc look</code> lists interactive elements. Designed for LLM agents that need to inspect pages without rendering them.</span> Combined with <code>page input</code>, <code>page eval</code>, and <code>grep -rn</code>, you get a full CLI-driven development loop: build a multi-file project, serve it, interact with it through the DOM, search the codebase, and commit — without leaving the terminal.</p> </section> <section> <p><span>Advanced</span><span>hc, page input/eval, grep -rn, multi-file project</span></p> <div> <h2>Advanced workflow</h2> <p>Build a todo app, serve it, interact with the DOM, search code, commit.</p> </div> </section> <section> <h2>IDE</h2> <p>The <code>ide</code> command opens a visual development environment.<span>LiteEditor is a zero-dependency textarea-based editor with syntax highlighting for JavaScript, TypeScript, CSS, HTML, JSON, and Markdown. The two layers — a transparent textarea on top, a highlighted pre below — are kept in pixel-perfect alignment by matching all font and spacing properties.</span> File tree, multi-tab editor with syntax highlighting, live preview, integrated terminal, git status, and a Claude chat panel. Everything runs through the same virtual filesystem — the IDE is just another way to look at the same files.</p> </section> <section> <p><span>IDE</span><span>visual development environment</span></p> <div> <h2>IDE</h2> <p>File tree, editor with syntax highlighting, terminal, live preview.</p> </div> </section> <section> <p><span>Seed GIF</span><span>snapshot one instance, drag to restore in another</span></p> <div> <div> <p>source</p> </div> <div> <p>target</p> </div> <div> <h2>Seed GIF</h2> <p>Snapshot one Shiro instance, drag the GIF to restore in another.</p> </div> </div> </section> <section> <h2>Claude Code</h2> <p>The real <a href="https://docs.anthropic.com/en/docs/claude-code">@anthropic-ai/claude-code</a> npm package runs inside a Node.js runtime shim.<span>The CLI is about 11 MB of bundled ESM. The runtime shim provides roughly 50 Node.js module stubs — fs, path, process, child_process, crypto, and so on. API calls route through a CORS proxy to api.anthropic.com since the browser can't reach it directly.</span> Not a reimplementation — the actual CLI, loaded and executed in the browser's JavaScript VM. The tools Claude Code depends on — file reads, edits, grep, glob, bash — are wired to the virtual filesystem. Both interactive mode and print mode work.</p> <p>It's good enough for reading, editing, and searching code. Building and testing work for simple projects. Complex workflows occasionally find the seams.</p> </section> <section> <h2>Remote control</h2> <p>An outer Claude Code instance — running on your actual machine — can control Shiro via <a href="https://modelcontextprotocol.io/">MCP</a> tools over WebRTC.<span>The server handles the initial WebRTC signaling handshake. After that, all data flows peer-to-peer between the browser and the outer Claude Code process. Connection codes have ~46 bits of entropy and expire in 5 minutes.</span> Run <code>remote start</code> in Shiro to get a connection code, then use the <code>shiro-mcp</code> package to exec commands, read and write files, and evaluate JavaScript in the browser.</p> </section> <section> <h2>Snapshots</h2> <p><code>seed gif</code> is perhaps the most unusual feature.<span>The GIF encoder is handwritten TypeScript — LZW compression, extension blocks, the whole format — with zero npm dependencies. The filesystem data is gzipped and stored in a SHIRO1.0 Application Extension block.</span> It captures a terminal screenshot, encodes it as a real GIF image, and embeds the entire filesystem in a custom extension block. The result looks like a screenshot but carries the complete state. Drag it back onto Shiro to restore everything.</p> <p><code>seed html</code> downloads a standalone HTML file — open it in any browser to boot Shiro with your filesystem already loaded.</p> </section> <section> <h2>Inject into any page</h2> <p><code>seed</code> (with no arguments) copies a JavaScript snippet to your clipboard. Open DevTools on any website, paste it into the console, and a floating Shiro window appears on top of the page.<span>The snippet creates a draggable, resizable iframe with macOS-style traffic lights (close, minimize), font size controls, and a title bar. It loads Shiro from shiro.computer and sends your entire filesystem + localStorage via postMessage.</span> Your files come with it. Everything you had in Shiro is available inside the injected window.</p> <p>More interesting: the snippet also installs an <code>hc</code> bridge into the host page. From inside the injected Shiro, run <code>hc outer</code> and all <code>hc</code> commands now operate on the host page's DOM.<span>The bridge communicates via postMessage. The Shiro iframe sends <code>shiro-hc</code> messages; the host-page bridge executes <code>q</code>, <code>look</code>, <code>@N</code>, <code>g</code>, and the rest of the HC command set against the real document, then posts the result back. No cross-origin issues because postMessage doesn't require same-origin.</span> <code>hc look</code> lists every button, link, and input on the page. <code>hc q .product-price</code> queries elements. <code>hc @3</code> clicks one. You can read text, grep content, inspect attributes — all from a shell prompt floating over the page you're examining.</p> <p>Since Claude Code runs inside Shiro, this means an AI coding agent can interact with any website: navigate a page, read its DOM, click buttons, extract data. The page doesn't need to cooperate or expose an API.</p> <p><code>seed blob</code> is the self-contained variant.<span>The blob variant inlines all of Shiro's HTML, JavaScript, and CSS, gzip-compresses everything, and base64-encodes it. At runtime it decompresses and creates a blob URL. No network request to shiro.computer, so it works even on pages with restrictive Content Security Policies.</span> Instead of loading Shiro from shiro.computer, it packs the entire application into the snippet itself — gzip-compressed and encoded as a blob URL. No external fetch, no CSP issues. It works offline, on intranets, behind firewalls.</p> </section> <section> <h2>Rough edges</h2> <p>Shell scripting handles basic constructs, not the full POSIX specification. npm installs real packages from the registry, but anything requiring native compilation won't work. There's no process isolation — everything runs in the main thread.<span>It's a browser pretending to be a computer. The pretense is good enough to be useful, not good enough to be invisible.</span></p> </section> </article></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>