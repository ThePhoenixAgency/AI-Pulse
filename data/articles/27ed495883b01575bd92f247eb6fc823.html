<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SAML roulette: the hacker always wins</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.8; color: #e2e8f0; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.5em; }
  .metadata { color: #94a3b8; font-size: 0.9em; margin-bottom: 2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 1em; }
  img { max-width: 100%; height: auto; border-radius: 8px; }
  a { color: #00d9ff; }
  p { margin-bottom: 1em; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 15px; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 15px; border-radius: 6px; overflow-x: auto; }

  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }

</style>
</head>
<body>
  <h1>SAML roulette: the hacker always wins</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 3/18/2025 | Lang: EN |
    <a href="https://portswigger.net/research/saml-roulette-the-hacker-always-wins" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div>
    
    
    
<div>
    <p><img alt="Gareth Heyes" src="https://portswigger.net/content/images/profiles/callout_gareth_heyes_114px.png" /></p>
</div>
    <ul>
        <li>
            <p><span></span><strong>Published: </strong>18 March 2025 at 14:55 UTC</p>
        </li>
        <li>
            <p><strong>Updated: </strong>31 March 2025 at 07:10 UTC</p>
        </li>
        <li>
        </li>
    </ul>
    <p><img src="https://portswigger.net/cms/images/89/2e/02d7-article-blog_header.png" alt="Multiple XML documents with arrows pointing in a circle to represent a round-trip attack" /></p><h2>Introduction</h2><p><b>In this post, we’ll show precisely how to chain round-trip attacks and namespace confusion to achieve unauthenticated admin access on GitLab Enterprise by exploiting the ruby-saml library.</b>
</p>
<p>While researching this, GitHub independently discovered and patched our vulnerabilities. However, their disclosure omits key technical details, including the specific mutation and how to exploit it without authentication.
</p><p><a href="https://github.blog/security/sign-in-as-anyone-bypassing-saml-sso-authentication-with-parser-differentials/">https://github.blog/security/sign-in-as-anyone-bypassing-saml-sso-authentication-with-parser-differentials/
</a>
</p>
<p>We believe sharing the full details on how these attacks work is crucial for improving security by empowering everyone with the knowledge needed to identify, mitigate, and defend against such threats effectively.
</p>
<p>This research began after we came across a fascinating post by <a href="https://mattermost.com/blog/securing-xml-implementations-across-the-web/">Juho Forsén
</a> detailing an XML round-trip vulnerability. What started as curiosity quickly spiraled into a deep dive into the intricacies of SAML, uncovering far more than we initially expected. We spent months exploring various round-trip attacks with the goal of presenting our findings at Black Hat. However, as luck would have it, we ran into a research collision with Alexander Tan (
<a href="https://hackerone.com/ahacker1/">ahacker1
</a>), leading to our discoveries being patched before we could submit. Despite that twist, we believe this work is still worth sharing, and while it may not be hitting Black Hat this year, we hope you find it just as compelling.</p>


<h2>Round-trip attacks 101</h2>

<p>SAML libraries often parse an XML document, store it as a string, and later re-parse it. In Ruby-SAML, this process involves two different parsers: REXML, which is used to parse the document and validate the signature, and Nokogiri, which is used to access attributes. If any mutations occur during this process, the document may not be identical when parsed a second time.</p>

<p>
For secure authorization, the document must be parsed and serialized consistently; otherwise, structural inconsistencies may arise. These inconsistencies can be exploited in a round-trip attack. By leveraging XML comments and CDATA sections, an attacker can manipulate the document’s structure during mutation, bypassing signature verification and effectively gaining unauthorized access by assuming another user's identity.
</p>

<h2>Round-trip attack on Ruby SAML/REXML</h2>

<p>To facilitate testing, we developed a testbed to identify round-trip vulnerabilities and efficiently evaluate multiple SAML libraries. I began by examining the document type definition (DOCTYPE), as similar vulnerabilities had been discovered in the past. My initial approach focused on analyzing how <a href="https://portswigger.net/web-security/xxe/xml-entities">XML entities</a> were parsed, so I conducted tests in that area.</p>

<p>
In Juho's original discovery, notation declarations were used to introduce inconsistencies in how quotes were interpreted. Building on this, I investigated whether any additional vulnerabilities had been overlooked. After extensive testing, I found that mutations could be introduced within the SYSTEM identifier.
</p>

<p>

During the initial parsing of the document, the first tag encountered is the original "assertion":

</p>

<p><img src="https://portswigger.net/cms/images/c1/ea/4da4-article-image1.png" alt="Code snippet showing the mutation initial discovery, the first time it's parsed" /></p><p>However, upon re-parsing the document, the outcome changes entirely, now reflecting the attacker's "assertion":</p>

<p><img src="https://portswigger.net/cms/images/b6/13/6783-article-image2.png" alt="A code snippet showing the second time it's parsed" /></p><p>As shown, the single-quoted system identifier is converted to double quotes. However, since the identifier contains double quotes internally, this alters the XML document’s syntax, causing the XML comment to be processed and resulting in an entirely different node. My highly skilled colleague, <a href="https://x.com/d4d89704243">Zak</a>, refined this mutation into a more streamlined and effective attack vector:
</p>

<p><img src="https://portswigger.net/cms/images/94/96/8d11-article-image3.png" alt="A more elegant vector" /></p><p>This vector allowed exploitation of GitLab and any other application using the Ruby-SAML library by manipulating the document and forging assertions, effectively enabling an attacker to log in as any user. However, this was only part of the attack. My colleague <b>Zak</b> will demonstrate how this can be escalated to achieve <b>unauthenticated administrator access</b> on <b>GitLab.</b></p>


<h2>Privilege escalation at Gitlab via Round-trip attack</h2>

<h3>Understanding the vulnerability</h3>

<p>GitLab relies on the Ruby-SAML library for SAML authentication. However, to achieve unauthenticated access, we need to take a closer look at the validation process, as it plays a critical role in the attack.</p>

<p>
Before a <b>round-trip</b> occurs, the library verifies whether the SAMLResponse contains a valid certificate embedded in the document. This is done by computing the hash of the certificate and comparing it with the fingerprint stored on the server. Later, this certificate is used to validate the signature. Keep in mind that the signature is a key aspect of this attack, as it allows for a <b>full account takeover</b> without access to an organization's credentials.
</p>

<h3>The Signature Validation Process</h3>

<p>Once the certificate is extracted from the SAMLResponse, the actual signature validation process begins. First, the document is converted back to XML format from its in-memory representation. This is where <b>Gareth's round trip attack</b> comes into play. At this stage, the library ignores <b>attacker assertion</b> and proceeds to validate the signature on the <b>original</b> element.</p>

<p>
If an attacker forges the assertion element in a way that bypasses signature validation, additional security checks come into play. The most critical checks include:
</p>

<ol><li>The <b>signed element's ID</b> should match in both documents.</li><li>Canonicalization properties (which normalize XML documents) must be identical in both versions.</li></ol>

<p>However, all other validation checks operate on the attacker assertion rather than the original signed document. This allows an attacker to arbitrarily modify validation fields without breaking the signature verification process:</p>
<p><img src="https://portswigger.net/cms/images/6e/6d/6913-article-image4.png" alt="A code snippet showing where each assertion goes" /></p><h2>Overcoming XML Schema Restrictions</h2>

<p>One challenge in forging a signed XML document is that XML schema validation is performed using Nokogiri with predefined schema files. This presents a limitation: for an attacker to forge a valid signed XML document, they must first obtain a document that passes XML schema validation.</p>

<h3>Understanding XML Schema Validation</h3>

<p>An XML schema defines the structure of SAML XML documents, specifying:</p>

<ul><li>Valid elements and attributes</li><li>The order and number of child elements</li><li>Data types for elements and attributes</li></ul>

<p>

In other words, the signed element must be a valid SAML protocol element—such as a login response, logout response, or metadata. You might find signed XML documents on developer forums, but that scenario is unlikely. Therefore, we will take a different approach. Instead, we introduce the <b>Namespace confusion</b> attack, which enables unauthenticated access to any application using Ruby-SAML.

</p>

<h2>Unauthenticated access to Gitlab</h2>

<p>Before diving into the attack, let's recall how SAML schema validation works. The Identity Provider (IdP) signs only the Signature node, not the entire assertion.

Since Ruby-SAML uses two XML parsers:</p>



<ul>
<li>REXML reads the Signature element.</li>
<li>Nokogiri reads the DigestValue.</li>
</ul>



<p>A discrepancy between these two parsers can allow us to bypass signature validation.

Ruby-SAML searches for the Signature element using an XPath query:

</p>

<p><img src="https://portswigger.net/cms/images/bc/8c/7933-article-image5.png" alt="Showing the XPath query" /></p><p>Here, <b>ds</b> refers to the XML namespace. Normally, namespaces prevent element name conflicts, but we exploit a discrepancy in how namespaces are interpreted in XPath searches.<br />
Consider the following scenario:

</p>

<p><img src="https://portswigger.net/cms/images/09/e1/815d-article-image6.png" alt="Showing the namespace confusion attack" /></p><p>First Signature element lacks a direct namespace declaration (xmlns="http://www.w3.org/2000/09/xmldsig#"). Instead, we use an XML Doctype trick:

Security experts often focus on !ENTITY declarations in <a href="https://portswigger.net/web-security/xxe">XXE</a> attacks, but !ATTLIST declarations can also be used for exploitation. The !ATTLIST defines the Signature element and assigns it a namespace attribute. Both REXML and Nokogiri support doctype-based namespace declarations, but REXML has a crucial flaw:

</p>

<ul><li>XML standards prohibit duplicate attributes with the same name.</li><li>However, REXML ignores this restriction in doctype declarations.</li></ul>

<p>This allows an attacker to define two conflicting namespace attributes, where the second one overrides the first.

As a result, REXML reads a FAKE digest value, while Nokogiri reads the REAL one.

</p>

<h3>Exploit Strategy</h3>

<p>To exploit this discrepancy:</p>
<ul><li>Create two Signature elements:
<ul><li>One with a valid Digest value.</li><li>One with a forged one.</li></ul></li></ul>


<p>

This allows the attacker to bypass Ruby-SAML's Digest Validation process.

</p>


<h2>
Exploiting Ruby &lt; 3.4.2 by combining Namespace Confusion with Round-trip attack
</h2>


<p>While Namespace Confusion alone can exploit Ruby-SAML, it faces one limitation:

REXML's poor handling of XML marshalling/unmarshalling introduces another round trip issue. Before Ruby 3.4.2, REXML truncated !ATTLIST strings in doctype declarations, making the exploit fragile. In GitLab, this breaks the attack, but a combination of both vulnerabilities can still be used:

</p>

<p><img src="https://portswigger.net/cms/images/b0/33/c00c-article-image7.png" alt="Combining namespace confusion with the round-trip attack" /></p><p>First XML parsing: REXML initially ignores the !ATTLIST value, treating it as a string literal. Second XML parsing: REXML then recognizes the !ATTLIST declaration, leading to full exploitation.</p>

<h3>Leveraging WS-Federation to Obtain Signed XML</h3>

<p>Finding a valid signed XML document can be challenging. Fortunately, Identity Providers (IdPs) silently support Single Sign-On protocol: <a href="https://learn.microsoft.com/en-us/entra/identity-platform/federation-metadata">WS-Federation</a> by default for every tenant. WS-Federation provides <b>signed metadata XML endpoints</b>, such as:
<a href="https://login.microsoftonline.com/contoso.onmicrosoft.com/FederationMetadata/2007-06/FederationMetadata.xml">https://login.microsoftonline.com/contoso.onmicrosoft.com...</a>. </p>


<p>Federation metadata documents are publicly accessible to any unauthorized user—all that’s required is the application's unique ID, which can be easily extracted from the Identity Provider's URL or found using a search engine.</p>

<p>While this metadata is not a valid SAML metadata document, a <b>namespace confusion</b> attack only requires a valid Signature element—one that is signed with the same certificate stored at the Service Provider. And it is.</p>

<p>By using this publicly available signed document, an attacker can:
</p>

<ul><li>Extract a legitimate Signature element.</li><li>Forge a fake signed assertion.</li><li>Completely bypass GitLab SAML authentication.</li></ul>

<h2>Conclusion</h2>

<p>

This attack highlights how combining round-trip attacks with namespace confusion can lead to unauthenticated access to GitLab. The vulnerability stems from inconsistencies in how different XML parsers handle document validation, allowing an attacker to manipulate signature verification.

</p>

<h3>Key Takeaways:</h3>

<ul><li>Differences in XML parsing can introduce exploitable inconsistencies.</li><li>Namespace confusion can be leveraged to bypass signature validation.</li><li>Legitimate signed WS-Federation metadata XML can be repurposed to forge assertions.</li></ul>

<h3>Mitigation</h3>

<p>To prevent this type of attack, ensure that the same library is used for both parsing and validating signed XML documents. Avoid marshaling and unmarshaling untrusted user data. These vulnerabilities where fixed in versions 17.9.2, 17.8.5, 17.7.7 for GitLab Community Edition (CE) and Enterprise Edition (EE). </p>

<p>
Make sure to follow us on <a href="https://x.com/PortSwiggerRes">X (formerly Twitter)</a> and <a href="https://bsky.app/profile/portswiggerres.bsky.social">Bluesky</a>, and join the official <a href="https://discord.com/channels/1159124119074381945/">PortSwigger Discord</a> to stay updated!
</p>
    
    <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
</body>
</html>