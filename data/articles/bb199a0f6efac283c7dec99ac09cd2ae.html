<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Your binary is no longer safe</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Your binary is no longer safe</h1>
  <div class="metadata">
    Source: Hacker News Show | Date: 2/16/2026 8:53:09 PM | Lang: EN |
    <a href="https://reorchestrate.com/posts/your-binary-is-no-longer-safe/" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div><p>This post is about the brute-force reverse engineering of binary (compiled) programs using <a href="https://en.wikipedia.org/wiki/Large_language_model" target="_blank">Large Language Models</a> (LLMs) to automate this two-part problem: decompilation and conversion to a modern programming language.</p><p>In this post an old <a href="https://en.wikipedia.org/wiki/Multi-user_dungeon" target="_blank">Multi-user Dungeon</a> (MUD) game binary has been targeted (see the reasoning below) but the approach applies equally well to other tasks, such as modernizing binaries or converting legacy <code>COBOL</code> to a modern language.</p><p>There are two reasons that LLMs should be good at this process, given their lineage:</p><ol><li><strong>Summarization</strong>: Large Language Models tend to be extremely good at <a href="https://arxiv.org/abs/2301.13848" target="_blank">summarization</a> where they are able to identify patterns across huge amounts of data. It is this skill that suggests, with a large enough <a href="https://en.wikipedia.org/wiki/Context_window" target="_blank">context window</a>, they should be able to identify patterns in decompiled code - perfect for identifying how variables and functions are used across a code base.</li><li><strong>Translation</strong>: Large Language Models evolved from <a href="https://en.wikipedia.org/wiki/Google_Translate" target="_blank">Google Translate</a> where they utilize <a href="https://en.wikipedia.org/wiki/Neural_machine_translation" target="_blank">neural machine translation</a> to translate from one language to another (i.e. English to French). This suggests they should be capable of performing accurate ’neural’ translation of one programming language to another.</li></ol><p>Ultimately this is a playground for me to learn about the real LLM capabilities (outside of standard benchmarks) where the journey is as interesting as the outcome.</p><h2>Intro to MUDs</h2><p>Back in the pre-internet days (yes, they existed) users would use a <a href="https://en.wikipedia.org/wiki/Modem" target="_blank">modem</a> and their phoneline to connect to <a href="https://en.wikipedia.org/wiki/Bulletin_board_system" target="_blank">Bulletin board systems</a> (BBS) where they could chat, transfer files and play games. These were a glimpse of the future where multiple ‘online’ users would be able to interact in real-time.</p><p>One of these BBS games was the <em>extremely addictive</em> <a href="https://www.majormud.com/" target="_blank">MajorMUD - Realm of Legends</a>: an online dungeons-and-dragons-esque fantasy game for the <a href="https://en.wikipedia.org/wiki/The_Major_BBS" target="_blank">Worldgroup/MajorBBS</a> platform. My friends and I were heavily invested in this game where - due to game balance design - the more time spent made your character more powerful and the game easier (our phone line was occupied for many hours). The game’s true strength was for groups of players to form parties and play the game together or against one another.</p><figure><img src="https://reorchestrate.com/img/2026/mmud.svg" alt="MUD gameplay"></figure><p>For all intents and purposes the <a href="https://www.reddit.com/r/MajorMUD/comments/4525pt/majormud_source_code/" target="_blank">source code has been lost</a> and only a Windows 32-bit <a href="https://en.wikipedia.org/wiki/Dynamic-link_library" target="_blank">Dynamic-link library</a> (DLL) remains. The GreaterMUD project was an independent ‘faithful rewrite’ but is also closed source. Therefore this 628KB DLL is perfect for doing brute-force reverse engineering via LLMs as we know the training process has not been compromised by ingesting this source code - so it can’t ‘cheat’ and replay <a href="https://arxiv.org/abs/2601.02671" target="_blank">memorized</a> code.</p><h2>Decompiling</h2><h3>From DLL to C?</h3><p>Initially I tried to get the LLM to take raw assembly and try to rewrite the logic. This proved a dead end however I suspect if you had the resources you could easily generate a huge amount of training data compiling with different compilers/compiler options and train a very strong model. This is an almost ideal situation for LLM finetuning - a closed system with a known-correct outcome where you can mass-produce training data cheaply.</p><p>I tried multiple commercial decompilers before settling on <a href="https://github.com/NationalSecurityAgency/ghidra" target="_blank">Ghidra</a>: an open-source decompiler built by the <a href="https://www.nsa.gov/" target="_blank">National Security Agency</a>. It is extremely powerful and it is clear a huge amount of effort has gone into the pattern matching required for it to do a solid job of producing <code>pseudo-C</code> - that is their <code>c</code> like language that doesn’t directly compile.</p><figure><img src="https://reorchestrate.com/img/2026/ghidra.png" alt="A screenshot of Ghidra"></figure><p>While its decompilation is amazing, depending on how the program has been compiled, a lot of information is lost in the process - like human-readable variable names (configuring the compiler to keep debug symbols in the binary would retain more of this information). So what you get is mostly logically-correct but not human-friendly code. Here is a randomly chosen (relatively short) function:</p><div><pre><code><span><span><span>/* monster_add_cast_spell_to_user */</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>__cdecl</span>
</span></span><span><span><span>monster_add_cast_spell_to_user</span>
</span></span><span><span> <span>(</span><span>int</span> <span>param_1</span><span>,</span><span>uint</span> <span>param_2</span><span>,</span><span>undefined2</span> <span>param_3</span><span>,</span><span>int</span> <span>param_4</span><span>,</span><span>int</span> <span>param_5</span><span>,</span><span>int</span> <span>param_6</span><span>,</span>
</span></span><span><span> <span>char</span> <span>param_7</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>{</span>
</span></span><span><span> <span>int</span> <span>iVar1</span><span>;</span>
</span></span><span><span> <span>int</span> <span>iVar2</span><span>;</span>
</span></span><span><span> <span>int</span> <span>iVar3</span><span>;</span>
</span></span><span><span> </span></span><span><span> <span>/* 0x25ea6 166 _monster_add_cast_spell_to_user */</span>
</span></span><span><span> <span>iVar1</span> <span>=</span> <span>get_player</span><span>(</span><span>param_1</span><span>);</span>
</span></span><span><span> <span>if</span> <span>((</span><span>iVar1</span> <span>!=</span> <span>0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>param_5</span> <span>!=</span> <span>0</span><span>))</span> <span>{</span>
</span></span><span><span> <span>iVar3</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span> <span>iVar2</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span> <span>do</span> <span>{</span>
</span></span><span><span> <span>if</span> <span>(</span><span>*</span><span>(</span><span>ushort</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x40</span> <span>+</span> <span>iVar2</span> <span>*</span> <span>2</span><span>)</span> <span>==</span> <span>param_2</span><span>)</span> <span>{</span>
</span></span><span><span> <span>if</span> <span>((</span><span>param_7</span> <span>!=</span> <span>'\0'</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>*</span><span>(</span><span>short</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x54</span> <span>+</span> <span>iVar2</span> <span>*</span> <span>2</span><span>)</span> <span>&lt;</span> <span>param_4</span><span>))</span> <span>{</span>
</span></span><span><span> <span>*</span><span>(</span><span>short</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x54</span> <span>+</span> <span>iVar2</span> <span>*</span> <span>2</span><span>)</span> <span>=</span> <span>(</span><span>short</span><span>)</span><span>param_4</span><span>;</span>
</span></span><span><span> <span>*</span><span>(</span><span>undefined2</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x68</span> <span>+</span> <span>iVar2</span> <span>*</span> <span>2</span><span>)</span> <span>=</span> <span>param_3</span><span>;</span>
</span></span><span><span> <span>monster_display_spell_success</span><span>(</span><span>param_1</span><span>,</span><span>param_5</span><span>,</span><span>param_6</span><span>,</span><span>iVar1</span> <span>+</span> <span>0x1e</span><span>,</span><span>param_4</span><span>);</span>
</span></span><span><span> <span>return</span> <span>iVar2</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>return</span> <span>-</span><span>2</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>if</span> <span>(</span><span>*</span><span>(</span><span>short</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x40</span> <span>+</span> <span>iVar2</span> <span>*</span> <span>2</span><span>)</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span> <span>iVar3</span> <span>=</span> <span>iVar2</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>iVar2</span> <span>=</span> <span>iVar2</span> <span>+</span> <span>1</span><span>;</span>
</span></span><span><span> <span>}</span> <span>while</span> <span>(</span><span>iVar2</span> <span>&lt;</span> <span>10</span><span>);</span>
</span></span><span><span> <span>if</span> <span>(</span><span>iVar3</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
</span></span><span><span> <span>*</span><span>(</span><span>undefined2</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x40</span> <span>+</span> <span>iVar3</span> <span>*</span> <span>2</span><span>)</span> <span>=</span> <span>(</span><span>undefined2</span><span>)</span><span>param_2</span><span>;</span>
</span></span><span><span> <span>*</span><span>(</span><span>undefined2</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x68</span> <span>+</span> <span>iVar3</span> <span>*</span> <span>2</span><span>)</span> <span>=</span> <span>param_3</span><span>;</span>
</span></span><span><span> <span>*</span><span>(</span><span>short</span> <span>*</span><span>)(</span><span>iVar1</span> <span>+</span> <span>0x54</span> <span>+</span> <span>iVar3</span> <span>*</span> <span>2</span><span>)</span> <span>=</span> <span>(</span><span>short</span><span>)</span><span>param_4</span><span>;</span>
</span></span><span><span> <span>monster_display_spell_success</span><span>(</span><span>param_1</span><span>,</span><span>param_5</span><span>,</span><span>param_6</span><span>,</span><span>iVar1</span> <span>+</span> <span>0x1e</span><span>,</span><span>param_4</span><span>);</span>
</span></span><span><span> <span>return</span> <span>iVar3</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>return</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>How do you turn it into human-friendly code?</p><p>How do you identify that <code>(iVar1 + 0x40 + iVar2 * 2)</code> = <code>(player_ptr-&gt;spell_ids[spell_slot_index] == _spell_id)</code>?</p><h3>Gemini enters the game …</h3><p>Google’s Gemini models (specifically from <code>flash-2.5</code> onwards with one million token <a href="https://cloud.google.com/blog/products/ai-machine-learning/the-needle-in-the-haystack-test-and-how-gemini-pro-solves-it" target="_blank">usable context length</a>) are absolutely amazing at crawling through code, identifying patterns and automating the task of renaming functions and variable names. <code>gemini-cli</code> supports tool calling so you can use a <a href="https://modelcontextprotocol.io/docs/getting-started/intro" target="_blank">model-context protocol</a> tool like <a href="https://github.com/jtang613/GhidrAssistMCP" target="_blank">GhidrAssistMCP</a> to automate the this loop.</p><p>For clarity lets walk through an example loop:</p><ol><li><p>Take a target function like <code>monster_add_cast_spell_to_user</code> and use the <code>decompile_function</code> tool to retrieve the current state of Ghidra’s decompiled view of the function.</p></li><li><p>Use the <code>function_xref</code> tool to identify which functions have references <em>to</em> <code>monster_add_cast_spell_to_user</code> and which functions are referenced <em>from</em> <code>monster_add_cast_spell_to_user</code>. So, for example, you can see that in the source above <code>get_player</code>, and <code>monster_display_spell_success</code> are referenced <em>from</em> <code>monster_add_cast_spell_to_user</code>.</p></li><li><p>Loop over the referenced functions and <code>decompile_function</code> to retreive their decompiled code.</p></li><li><p>Let’s look at <code>get_player</code>:</p><div><pre><code><span><span><span>/* get_player */</span>
</span></span><span><span>
</span></span><span><span><span>undefined4</span> <span>__cdecl</span> <span>get_player</span><span>(</span><span>int</span> <span>param_1</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>{</span>
</span></span><span><span> <span>char</span> <span>*</span><span>pcVar1</span><span>;</span>
</span></span><span><span> <span>undefined4</span> <span>uVar2</span><span>;</span>
</span></span><span><span> <span>undefined</span> <span>*</span><span>puVar3</span><span>;</span>
</span></span><span><span> <span>int</span> <span>iVar4</span><span>;</span>
</span></span><span><span>
</span></span><span><span> <span>/* 0x320d9 201 _get_player */</span>
</span></span><span><span> <span>if</span> <span>((</span><span>param_1</span> <span>&lt;=</span> <span>*</span><span>(</span><span>int</span> <span>*</span><span>)</span><span>_nterms_exref</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>-</span><span>1</span> <span>&lt;</span> <span>param_1</span><span>))</span> <span>{</span>
</span></span><span><span> <span>uVar2</span> <span>=</span> <span>ptrblok</span><span>(</span><span>DAT_0048201c</span><span>,</span><span>param_1</span><span>);</span>
</span></span><span><span> <span>return</span> <span>uVar2</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>iVar4</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span> <span>if</span> <span>((((</span><span>*</span><span>(</span><span>int</span> <span>*</span><span>)</span><span>_usrnum_exref</span> <span>&lt;</span> <span>0</span><span>)</span> <span>||</span> <span>(</span><span>*</span><span>(</span><span>int</span> <span>*</span><span>)</span><span>_nterms_exref</span> <span>&lt;=</span> <span>*</span><span>(</span><span>int</span> <span>*</span><span>)</span><span>_usrnum_exref</span><span>))</span> <span>||</span>
</span></span><span><span> <span>(</span><span>*</span><span>(</span><span>int</span> <span>*</span><span>)</span><span>_usaptr_exref</span> <span>==</span> <span>0</span><span>))</span> <span>||</span> <span>(</span><span>*</span><span>(</span><span>int</span> <span>*</span><span>)</span><span>_usaptr_exref</span> <span>==</span> <span>0</span><span>))</span> <span>{</span>
</span></span><span><span> <span>puVar3</span> <span>=</span> <span>&amp;</span><span>DAT_00482aab</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>else</span> <span>{</span>
</span></span><span><span> <span>puVar3</span> <span>=</span> <span>*</span><span>(</span><span>undefined</span> <span>**</span><span>)</span><span>_usaptr_exref</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>pcVar1</span> <span>=</span> <span>(</span><span>char</span> <span>*</span><span>)</span><span>spr</span><span>(</span><span>s_get_player</span><span>:</span><span>_</span><span>%</span><span>d</span><span>(</span><span>%</span><span>d</span><span>)</span><span>_</span><span>(</span><span>usrnum</span><span>:</span><span>_</span><span>%</span><span>d_</span><span>[</span><span>_00482a86</span><span>,</span><span>param_1</span><span>,</span>
</span></span><span><span> <span>*</span><span>(</span><span>undefined4</span> <span>*</span><span>)</span><span>_nterms_exref</span><span>,</span><span>*</span><span>(</span><span>undefined4</span> <span>*</span><span>)</span><span>_usrnum_exref</span><span>,</span><span>puVar3</span><span>);</span>
</span></span><span><span> <span>internal_error</span><span>(</span><span>pcVar1</span><span>,</span><span>iVar4</span><span>);</span>
</span></span><span><span> <span>return</span> <span>0</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>We can infer from the name <code>get_player</code> that we are expecting this to take some sort of <code>player_id</code> and return a <code>player</code>. What conclusions can we draw:</p><ul><li><code>uVar2 = ptrblok(DAT_0048201c,param_1); return uVar2;</code>. This means the return value, <code>uVar2</code>, is the <code>player</code> and it is being assigned with the <code>ptrblok</code>.</li><li>Without knowing anything except name <code>ptrblok</code> we can infer this is doing something to do with pointers that takes <code>DAT_0048201c</code> and the input argument <code>param_1</code> (but only if its less than or equal to <code>_nterms_exref</code> ) and then returns the <code>player</code> result - so its reasonable that <code>get_player</code> takes a <code>player_id</code> as the input parameter and it is used to index into some memory. You can also infer that <code>_usrnum_exref</code> is some sort of maximum players value.</li><li>To be sure we can use <code>xref</code> tool to see what is reading/writing to <code>DAT_0048201c</code>. Sure enough the <code>allocate_buffers</code> function has this line <code>DAT_0048201c = alcblok(*(undefined2 *)_nterms_exref,0x7ec);</code>.</li><li>This is a goldmine. It says that <code>DAT_0048201c</code> is an allocated memory region that contains contains <code>_nterms_exref</code> entries of <code>players</code> where each player is <code>0x7ec</code> (2028) bytes in size.</li></ul></li><li><p>With our new knowledge by investigating <code>get_player</code> we can now update the <code>monster_add_cast_spell_to_user</code> function: <code>iVar1</code> can be renamed to <code>player_ptr</code> and <code>param_1</code> to <code>player_id</code> using the <code>rename_symbol</code> tool.</p></li><li><p>Now if you call <code>decompile_function(monster_add_cast_spell_to_user)</code> again the source code will now return <code>player_ptr = get_player(player_id);</code> in that line and, like your IDE, those variables will be renamed throughout the entire function so subsequent lines like <code>if (*(ushort *)(iVar1 + 0x40 + iVar2 * 2) == param_2)</code> becomes <code>if (*(ushort *)(player_ptr + 0x40 + iVar2 * 2) == param_2)</code> and we immediately know we are doing some operation involving a <code>player</code> - hugely informative to make the next renaming decisions.</p></li></ol><p>Now you can have <code>gemini-cli</code> run this in a loop and you can see how it will, over time, be able to “peel back the layers” of the original code and produce a more-and-more complete view of the code base.</p><p>This is the LLM party-trick #1: <strong>summarization</strong> of a huge amount of context - far exceeding the human brain’s capacity - to identify patterns.</p><div><p>Ghidra</p><p>I don’t want this to be a Ghidra tutorial but you can also define data structures like <code>structs</code> and <code>enums</code> in Ghidra. <a href="https://github.com/jtang613/GhidrAssistMCP" target="_blank">GhidrAssistMCP</a> has tools like the <code>structs</code> tool that will allow it to <code>create</code> and <code>update</code> data structures. Once correctly defined Ghidra will automatically update the decompiled code to show: <code>player_ptr-&gt;spell_ids</code>.</p></div><p>Now the problem becomes one of just cost and time to produce: (note this is still in Ghidra <code>pseudo-c</code>)</p><div><pre><code><span><span>
</span></span><span><span><span>/* Adds a cast spell effect to a player's active spell list. This function attempts to find an
</span></span></span><span><span><span> existing spell by `spell_id`. If found and `can_overwrite_if_stronger` is true, the spell's
</span></span></span><span><span><span> duration and value are updated if the new value is higher. Otherwise, it searches for an empty
</span></span></span><span><span><span> spell slot to add the new spell. A success message is displayed to the player upon successful
</span></span></span><span><span><span> spell addition or update. */</span>
</span></span><span><span>
</span></span><span><span><span>int</span> <span>__cdecl</span>
</span></span><span><span><span>monster_add_cast_spell_to_user</span>
</span></span><span><span> <span>(</span><span>int</span> <span>player_id</span><span>,</span><span>ushort</span> <span>spell_id</span><span>,</span><span>short</span> <span>duration</span><span>,</span><span>int</span> <span>value</span><span>,</span><span>spell</span> <span>*</span><span>spell_ptr</span><span>,</span>
</span></span><span><span> <span>monster</span> <span>*</span><span>monster_ptr</span><span>,</span><span>bool</span> <span>can_overwrite_if_stronger_flag</span><span>)</span>
</span></span><span><span>
</span></span><span><span><span>{</span>
</span></span><span><span> <span>player</span> <span>*</span><span>player_ptr</span><span>;</span>
</span></span><span><span> <span>int</span> <span>spell_slot_index</span><span>;</span>
</span></span><span><span> <span>int</span> <span>empty_spell_slot_index</span><span>;</span>
</span></span><span><span> <span>undefined2</span> <span>unused_stack_var</span><span>;</span>
</span></span><span><span> </span></span><span><span> <span>/* 0x25ea6 166 _monster_add_cast_spell_to_user */</span>
</span></span><span><span> <span>player_ptr</span> <span>=</span> <span>get_player</span><span>(</span><span>player_id</span><span>);</span>
</span></span><span><span> <span>if</span> <span>((</span><span>player_ptr</span> <span>!=</span> <span>(</span><span>player</span> <span>*</span><span>)</span><span>0x0</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>spell_ptr</span> <span>!=</span> <span>(</span><span>spell</span> <span>*</span><span>)</span><span>0x0</span><span>))</span> <span>{</span>
</span></span><span><span> <span>empty_spell_slot_index</span> <span>=</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span> <span>spell_slot_index</span> <span>=</span> <span>0</span><span>;</span>
</span></span><span><span> <span>do</span> <span>{</span>
</span></span><span><span> <span>if</span> <span>(</span><span>player_ptr</span><span>-&gt;</span><span>spell_ids</span><span>[</span><span>spell_slot_index</span><span>]</span> <span>==</span> <span>_spell_id</span><span>)</span> <span>{</span>
</span></span><span><span> <span>if</span> <span>((</span><span>can_overwrite_if_stronger_flag</span><span>)</span> <span>&amp;&amp;</span> <span>(</span><span>player_ptr</span><span>-&gt;</span><span>spell_values</span><span>[</span><span>spell_slot_index</span><span>]</span> <span>&lt;</span> <span>value</span><span>)</span>
</span></span><span><span> <span>)</span> <span>{</span>
</span></span><span><span> <span>player_ptr</span><span>-&gt;</span><span>spell_values</span><span>[</span><span>spell_slot_index</span><span>]</span> <span>=</span> <span>(</span><span>short</span><span>)</span><span>value</span><span>;</span>
</span></span><span><span> <span>player_ptr</span><span>-&gt;</span><span>spell_durations</span><span>[</span><span>spell_slot_index</span><span>]</span> <span>=</span> <span>duration</span><span>;</span>
</span></span><span><span> <span>monster_display_spell_success</span>
</span></span><span><span> <span>(</span><span>player_id</span><span>,</span><span>spell_ptr</span><span>,</span><span>monster_ptr</span><span>,</span><span>player_ptr</span><span>-&gt;</span><span>given_name</span><span>,(</span><span>char</span> <span>*</span><span>)</span><span>value</span><span>);</span>
</span></span><span><span> <span>return</span> <span>spell_slot_index</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>return</span> <span>-</span><span>2</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>if</span> <span>(</span><span>player_ptr</span><span>-&gt;</span><span>spell_ids</span><span>[</span><span>spell_slot_index</span><span>]</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
</span></span><span><span> <span>empty_spell_slot_index</span> <span>=</span> <span>spell_slot_index</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>spell_slot_index</span> <span>=</span> <span>spell_slot_index</span> <span>+</span> <span>1</span><span>;</span>
</span></span><span><span> <span>}</span> <span>while</span> <span>(</span><span>spell_slot_index</span> <span>&lt;</span> <span>10</span><span>);</span>
</span></span><span><span> <span>if</span> <span>(</span><span>empty_spell_slot_index</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
</span></span><span><span> <span>player_ptr</span><span>-&gt;</span><span>spell_ids</span><span>[</span><span>empty_spell_slot_index</span><span>]</span> <span>=</span> <span>spell_id</span><span>;</span>
</span></span><span><span> <span>player_ptr</span><span>-&gt;</span><span>spell_durations</span><span>[</span><span>empty_spell_slot_index</span><span>]</span> <span>=</span> <span>duration</span><span>;</span>
</span></span><span><span> <span>player_ptr</span><span>-&gt;</span><span>spell_values</span><span>[</span><span>empty_spell_slot_index</span><span>]</span> <span>=</span> <span>(</span><span>short</span><span>)</span><span>value</span><span>;</span>
</span></span><span><span> <span>monster_display_spell_success</span>
</span></span><span><span> <span>(</span><span>player_id</span><span>,</span><span>spell_ptr</span><span>,</span><span>monster_ptr</span><span>,</span><span>player_ptr</span><span>-&gt;</span><span>given_name</span><span>,(</span><span>char</span> <span>*</span><span>)</span><span>value</span><span>);</span>
</span></span><span><span> <span>return</span> <span>empty_spell_slot_index</span><span>;</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>}</span>
</span></span><span><span> <span>return</span> <span>-</span><span>1</span><span>;</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Now that we have a semi-human-friendly decompiled binary in <code>pseudo-c</code>, on to LLM party trick #2: <strong>translation</strong>.</p><h2>Claude enters the game …</h2><p>Here is a 1:1 translation produced by <code>claude-opus-4.5</code>. You can see that my implementation does have a different signature to deal with the <code>rust</code> borrow-checker - but you can safely ignore this for this discussion.</p><p>To produce this conversion you can basically ask <code>claude</code> to (in reality is is not <em>quite</em> this simple but this is good enough for demonstration purpose):</p><div><pre><code><span><span>retrieve the monster_add_cast_spell_to_user <span>function</span> from ghidra and rewrite-it-in-rust </span></span></code></pre></div><p>… and it produces:</p><div><pre><code><span><span><span>/// Adds a spell cast by a monster to a player's active spells.
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// Handles checking if a spell already exists and optionally overwriting it
</span></span></span><span><span><span>/// if the new value is stronger. Uses the last available empty slot.
</span></span></span><span><span><span>///
</span></span></span><span><span><span>/// Returns Some(slot_index) on success, or None on failure.
</span></span></span><span><span><span>pub</span><span> </span><span>fn</span> <span>monster_add_cast_spell_to_user</span><span>(</span><span>
</span></span></span><span><span><span> </span><span>&amp;</span><span>self</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>player_id</span>: <span>PlayerId</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>spell</span>: <span>&amp;</span><span>'static</span> <span>Spell</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>duration</span>: <span>i16</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>value</span>: <span>i16</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>can_overwrite_if_stronger</span>: <span>bool</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>game</span>: <span>&amp;</span><span>mut</span><span> </span><span>Game</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>messages</span>: <span>&amp;</span><span>'static</span> <span>Messages</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>players</span>: <span>&amp;</span><span>mut</span><span> </span><span>Players</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>rooms</span>: <span>&amp;</span><span>Rooms</span><span>,</span><span>
</span></span></span><span><span><span>)</span><span> </span>-&gt; <span>Option</span><span>&lt;</span><span>usize</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>player</span><span> </span><span>=</span><span> </span><span>players</span><span>.</span><span>get</span><span>(</span><span>&amp;</span><span>player_id</span><span>)</span><span>?</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Find existing spell or last empty slot
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>mut</span><span> </span><span>empty_slot</span><span> </span><span>=</span><span> </span><span>None</span><span>;</span><span>
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>mut</span><span> </span><span>existing_slot</span><span> </span><span>=</span><span> </span><span>None</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>for</span><span> </span><span>(</span><span>i</span><span>,</span><span> </span><span>active_spell_opt</span><span>)</span><span> </span><span>in</span><span> </span><span>player</span><span>.</span><span>active_spells</span><span>.</span><span>iter</span><span>().</span><span>enumerate</span><span>()</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>match</span><span> </span><span>active_spell_opt</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>Some</span><span>(</span><span>active_spell</span><span>)</span><span> </span><span>if</span><span> </span><span>active_spell</span><span>.</span><span>spell</span><span>.</span><span>id</span><span> </span><span>==</span><span> </span><span>spell</span><span>.</span><span>id</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>existing_slot</span><span> </span><span>=</span><span> </span><span>Some</span><span>((</span><span>i</span><span>,</span><span> </span><span>active_spell</span><span>.</span><span>value</span><span>));</span><span>
</span></span></span><span><span><span> </span><span>break</span><span>;</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span> </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>empty_slot</span><span> </span><span>=</span><span> </span><span>Some</span><span>(</span><span>i</span><span>),</span><span>
</span></span></span><span><span><span> </span><span>_</span><span> </span><span>=&gt;</span><span> </span><span>{}</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Determine which slot to use and whether to proceed
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>slot</span><span> </span><span>=</span><span> </span><span>match</span><span> </span><span>existing_slot</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>Some</span><span>((</span><span>i</span><span>,</span><span> </span><span>existing_value</span><span>))</span><span> </span><span>=&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>if</span><span> </span><span>can_overwrite_if_stronger</span><span> </span><span>&amp;&amp;</span><span> </span><span>existing_value</span><span> </span><span>&lt;</span><span> </span><span>value</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>i</span><span>
</span></span></span><span><span><span> </span><span>}</span><span> </span><span>else</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>return</span><span> </span><span>None</span><span>;</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span> </span><span>None</span><span> </span><span>=&gt;</span><span> </span><span>empty_slot</span><span>?</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Get player name before mutable borrow, then update the spell slot
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>player_name</span><span> </span><span>=</span><span> </span><span>player</span><span>.</span><span>given_name</span><span>.</span><span>clone</span><span>();</span><span>
</span></span></span><span><span><span> </span><span>players</span><span>.</span><span>get_mut</span><span>(</span><span>&amp;</span><span>player_id</span><span>).</span><span>unwrap</span><span>().</span><span>active_spells</span><span>[</span><span>slot</span><span>]</span><span> </span><span>=</span><span>
</span></span></span><span><span><span> </span><span>Some</span><span>(</span><span>PlayerActiveSpell</span><span> </span><span>{</span><span> </span><span>spell</span><span>,</span><span> </span><span>value</span><span>,</span><span> </span><span>duration</span><span> </span><span>});</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>self</span><span>.</span><span>monster_display_spell_success</span><span>(</span><span>
</span></span></span><span><span><span> </span><span>Some</span><span>(</span><span>player_id</span><span>),</span><span>
</span></span></span><span><span><span> </span><span>spell</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>&amp;</span><span>player_name</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>&amp;</span><span>value</span><span>.</span><span>to_string</span><span>(),</span><span>
</span></span></span><span><span><span> </span><span>game</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>messages</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>players</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>rooms</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>Some</span><span>(</span><span>slot</span><span>)</span><span>
</span></span></span><span><span><span>}</span><span>
</span></span></span></code></pre></div><div><p>Why Rust?</p><p>To prepare for the inevitable question: because I enjoy writing <a href="https://rust-lang.org/" target="_blank">Rust</a>. I like its tooling, I like thinking about how efficiency/allocations/deallocations/ownership work, I like writing <a href="https://doc.rust-lang.org/book/ch00-00-introduction.html?highlight=zero-cost#people-who-value-speed-and-stability" target="_blank">functional code</a> and I like being able to mentally delegate a huge amount of work to the compiler.</p></div><h2>How do we know it works?</h2><p>The million dollar question now becomes one of verification: how do we know that we translated it correctly?</p><div><p>The confident accountant</p><div><p>Interviewer: “I heard you are extremely quick at math.”</p><p>Me: “That’s correct.”</p><p>Interviewer: “What is 14 multiplied by 27?”</p><p>Me: “600!”</p><p>Interviewer: “That’s not even close.”</p><p>Me: “Yeah, but it was fast.”</p></div></div><p>Large Language Models, when used in agentic loops, achieve their best results when they can ‘close the loop’, i.e., they have a way of evaluating a success condition.</p><figure><img src="https://reorchestrate.com/img/2026/agentic-loop.webp" alt="Agentic Loop"><figcaption>Source: <a href="https://www.anthropic.com/engineering/building-effective-agents" target="_blank">Anthropic</a></figcaption></figure><p>At their core Large Language Models, while highly advanced, are <a href="https://garymarcus.substack.com/p/humans-versus-machines-the-hallucination" target="_blank">statistically reconstructing</a> patterns from the training data. Statistical reconstruction proves effective on known problems but is susceptible to <a href="https://en.wikipedia.org/wiki/Hallucination_%28artificial_intelligence%29" target="_blank">hallucinations</a> when faced with novel problems (data that is out of distribution in the training data). So, if you are writing a React App connecting to a RESTful backend they are <em>likely</em> to so with few hallucinations as they have ingested millions? of code bases that do largely the same operations. But how many people are silly enough to embark on translating 80,000 lines of obfuscated <code>pseudo-C</code> (… and to make my life worse I also changed the storage to a relational database). Hallucinations are a problem <em>unless</em> you can close that feedback loop.</p><p>My answer is <a href="https://en.wikipedia.org/wiki/Differential_testing" target="_blank">differential</a>, <a href="https://en.wikipedia.org/wiki/Software_testing#Property_testing" target="_blank">property</a> testing.</p><h3>The Setup</h3><h4>Problem:</h4><p>To be able to setup a harness we first need to solve a few problems:</p><ol><li>The Ghidra <code>pseudo-C</code> does not produce <code>c</code> so we cant easily compile it and use codegen to create bindings to call it now as a native binary.</li><li>Even if we could compile the Ghidra <code>pseudo-C</code> there are many <code>WGSERVER</code>/<code>MajorBBS</code> API calls which would need to be <a href="https://www.mbbsemu.com/" target="_blank">implemented</a> for it to be usable.</li></ol><p>What I need is a way to run the original Win32 x86 code … on my Macbook?</p><h4>Solution:</h4><p>My solution is a miracle of engineering (read: <a href="https://en.wikipedia.org/wiki/QEMU" target="_blank">QEMU</a> magic):</p><figure><img src="https://reorchestrate.com/img/2026/architecture.svg" alt="Infrastructure"></figure><ol><li>Development occurs within an aarch64 <a href="https://containers.dev/" target="_blank">devcontainer</a> - so the MacOS Docker engine is running an aarch64 Linux 6.17.8 kernel in a virtual machine.</li><li>Inside the container <a href="https://www.winehq.org/" target="_blank">Wine</a> can run Windows 32-bit x86 binaries produced by the Rust <code>i686-pc-windows-gnu</code> target - transparently spawning another layer of virtual machines.</li><li>The DLL is reflectively loaded into memory - headers are parsed, sections are mapped, and base relocations are applied if the preferred address (<code>0x400000</code>) is unavailable.</li><li>Calls to <code>WGSERVER</code>/<code>MajorBBS</code> APIs (like <code>prf</code>, <code>alcmem</code>, <code>dfaQuery</code>, <code>genrdn</code>) are resolved to Rust mock implementations, making operations like random number generation deterministic.</li><li>Inline hooks redirect <code>get_*_data()</code> functions so the DLL reads/writes boxed <code>#[repr(C, packed)]</code> structs owned by Rust - enabling bidirectional mutation of both implementations.</li><li>Function addresses are calculated from known <a href="https://en.wikipedia.org/wiki/Base_address" target="_blank">Relative Value Address</a> (RVA) offsets, allowing each DLL function to be invoked in isolation.</li><li>Rust entities are converted via <code>entity.to_wcc_*()</code> to C-compatible structs matching the original DLL byte layout, then inserted into shared state before test execution.</li></ol><figure><img src="https://reorchestrate.com/img/2026/setup.svg" alt="Setting up a harness"></figure><p>This is an extremely complex setup that was <em>fully implemented by Claude Opus 4.5</em> (with quite a bit of steering) - but it <strong>works</strong>.</p><h3>The testing</h3><p>Now we have a way to execute the original and re-implemented implementations alongside each other, how do we know <em>what</em> to test?</p><h4>Problem:</h4><p>Again, let’s discuss problems:</p><ol><li>The <code>Wine</code> executor allows us to execute the DLL but it prevents us from measuring <code>coverage</code> (due to the execution model) to ensure we have covered all the code paths within the a function.</li><li>If we generate coverage from only the translated Rust side how do we know we have covered all the code paths?</li></ol><figure><img src="https://reorchestrate.com/img/2026/test.svg" alt="The testing"></figure><h4>Solution:</h4><p>My answer is a loop using a combination of <a href="https://github.com/proptest-rs/proptest" target="_blank">property testing</a> and <a href="https://en.wikipedia.org/wiki/Differential_testing" target="_blank">differential testing</a> combined with the Rust-only coverage to inform when to add additional property tests. This will not guarantee all paths are hit but side-effects (i.e. game state mutation) not covered in the Rust coverage should be caught by differential testing allowing them to be debugged and added to the test.</p><p>So let’s take a tiny function:</p><div><pre><code><span><span><span>impl</span><span> </span><span>Player</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>/// Adds a delay to the player's delay counter.
</span></span></span><span><span><span> </span><span>pub</span><span> </span><span>fn</span> <span>add_delay</span><span>(</span><span>&amp;</span><span>mut</span><span> </span><span>self</span><span>,</span><span> </span><span>delay</span>: <span>u8</span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>self</span><span>.</span><span>delay</span><span> </span><span>=</span><span> </span><span>self</span><span>.</span><span>delay</span><span>.</span><span>wrapping_add</span><span>(</span><span>delay</span><span>);</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span>}</span><span>
</span></span></span></code></pre></div><p>and review the tests:</p><div><pre><code><span><span><span>#[cfg(test)]</span><span>
</span></span></span><span><span><span>mod</span> <span>tests</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>use</span><span> </span><span>proptest</span>::<span>prelude</span>::<span>*</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>use</span><span> </span><span>crate</span>::<span>game</span>::<span>{</span><span>
</span></span></span><span><span><span> </span><span>enums</span>::<span>{</span><span>ClassType</span><span>,</span><span> </span><span>RaceType</span><span>},</span><span>
</span></span></span><span><span><span> </span><span>players</span>::<span>Player</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>runtime</span>::<span>get_test_runtime</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>proptest!</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>#![proptest_config(ProptestConfig::with_cases(256))]</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>/// Property-based differential test for add_delay.
</span></span></span><span><span><span> </span><span>///
</span></span></span><span><span><span> </span><span>/// Generates random player delay and addition values, comparing Rust vs DLL.
</span></span></span><span><span><span> </span><span>#[test]</span><span>
</span></span></span><span><span><span> </span><span>fn</span> <span>test_add_delay_differential</span><span>(</span><span>
</span></span></span><span><span><span> </span><span>initial_delay</span><span> </span><span>in</span><span> </span><span>any</span>::<span>&lt;</span><span>u8</span><span>&gt;</span><span>(),</span><span>
</span></span></span><span><span><span> </span><span>delay_to_add</span><span> </span><span>in</span><span> </span><span>any</span>::<span>&lt;</span><span>u8</span><span>&gt;</span><span>(),</span><span>
</span></span></span><span><span><span> </span><span>)</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>// Create the rust state
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>mut</span><span> </span><span>rt</span><span> </span><span>=</span><span> </span><span>get_test_runtime</span><span>();</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Create the player
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>mut</span><span> </span><span>player</span><span> </span><span>=</span><span> </span><span>Player</span>::<span>new</span><span>(</span><span>
</span></span></span><span><span><span> </span><span>"PropTestPlayer"</span><span>.</span><span>to_string</span><span>(),</span><span>
</span></span></span><span><span><span> </span><span>&amp;</span><span>mut</span><span> </span><span>rt</span><span>.</span><span>game</span><span>,</span><span>
</span></span></span><span><span><span> </span><span>&amp;</span><span>rt</span><span>.</span><span>races</span><span>[</span><span>&amp;</span><span>RaceType</span>::<span>Human</span><span>],</span><span>
</span></span></span><span><span><span> </span><span>&amp;</span><span>rt</span><span>.</span><span>classes</span><span>[</span><span>&amp;</span><span>ClassType</span>::<span>Warrior</span><span>],</span><span>
</span></span></span><span><span><span> </span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Mutate the player
</span></span></span><span><span><span> </span><span>player</span><span>.</span><span>delay</span><span> </span><span>=</span><span> </span><span>initial_delay</span><span>;</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Create the Windows world from the Rust world
</span></span></span><span><span><span> </span><span>#[cfg(target_os = </span><span>"windows"</span><span>)]</span><span>
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>mut</span><span> </span><span>harness</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>crate</span>::<span>differential</span>::<span>dll_harness</span>::<span>DllHarness</span>::<span>from_runtime</span><span>(</span><span>&amp;</span><span>rt</span><span>)</span><span>
</span></span></span><span><span><span> </span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Inject the player to match Rust
</span></span></span><span><span><span> </span><span>#[cfg(target_os = </span><span>"windows"</span><span>)]</span><span>
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>harness_slot</span><span> </span><span>=</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>slot</span><span> </span><span>=</span><span> </span><span>player</span><span>.</span><span>id</span><span>.</span><span>0</span><span> </span><span>as</span><span> </span><span>u16</span><span>;</span><span>
</span></span></span><span><span><span> </span><span>harness</span><span>.</span><span>state</span><span>.</span><span>players</span><span>.</span><span>insert</span><span>(</span><span>slot</span><span>,</span><span> </span><span>Box</span>::<span>new</span><span>(</span><span>player</span><span>.</span><span>to_wcc_player</span><span>()));</span><span>
</span></span></span><span><span><span> </span><span>slot</span><span>
</span></span></span><span><span><span> </span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Run Rust implementation
</span></span></span><span><span><span> </span><span>player</span><span>.</span><span>add_delay</span><span>(</span><span>delay_to_add</span><span>);</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>// Windows: Run DLL and compare
</span></span></span><span><span><span> </span><span>#[cfg(target_os = </span><span>"windows"</span><span>)]</span><span>
</span></span></span><span><span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>unsafe</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>harness</span><span>.</span><span>add_delay</span><span>(</span><span>harness_slot</span><span>,</span><span> </span><span>delay_to_add</span><span>);</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>let</span><span> </span><span>dll_player</span><span> </span><span>=</span><span> </span><span>unsafe</span><span> </span><span>{</span><span> </span><span>harness</span><span>.</span><span>get_player</span><span>(</span><span>harness_slot</span><span>).</span><span>unwrap</span><span>()</span><span> </span><span>};</span><span>
</span></span></span><span><span><span>
</span></span></span><span><span><span> </span><span>prop_assert_eq!</span><span>(</span><span>player</span><span>,</span><span> </span><span>dll_player</span><span>);</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span>}</span><span>
</span></span></span></code></pre></div><p>In this example the two variables <code>initial_delay in any::&lt;u8&gt;()</code> and <code>delay_to_add in any::&lt;u8&gt;()</code> will be tested with different combinations of only <code>u8</code> values (so 256 * 256 = 65,536 possibilities). For more interesting data types the <a href="https://docs.rs/proptest/latest/proptest/arbitrary/trait.Arbitrary.html" target="_blank">Arbitrary</a> trait can be implemented to restrict the random range (<a href="https://docs.rs/proptest/latest/proptest/arbitrary/fn.any.html" target="_blank">any</a> implements <code>Arbitrary</code>). For example there is no point generating a full range of <code>u16</code> foreign-key values if only <code>0..1398</code> exist:</p><div><pre><code><span><span><span>#[cfg(test)]</span><span>
</span></span></span><span><span><span>impl</span><span> </span><span>SpellId</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>/// Generate a random valid spell ID (hardcoded range from game database: 1..=1398).
</span></span></span><span><span><span> </span><span>pub</span><span> </span><span>fn</span> <span>arbitrary</span><span>()</span><span> </span>-&gt; <span>impl</span><span> </span><span>proptest</span>::<span>strategy</span>::<span>Strategy</span><span>&lt;</span><span>Value</span><span> </span><span>=</span><span> </span><span>SpellId</span><span>&gt;</span><span> </span><span>{</span><span>
</span></span></span><span><span><span> </span><span>use</span><span> </span><span>proptest</span>::<span>prelude</span>::<span>*</span><span>;</span><span>
</span></span></span><span><span><span> </span><span>(</span><span>1</span><span>u32</span><span>..=</span><span>1398</span><span>).</span><span>prop_map</span><span>(</span><span>SpellId</span><span>)</span><span>
</span></span></span><span><span><span> </span><span>}</span><span>
</span></span></span><span><span><span>}</span><span>
</span></span></span></code></pre></div><p>The use of the <code>target_os</code> means this test will run as a purely property based test when executed via a normal Rust build to calculate coverage and be a basic smoke-test. Then the <code>Wine</code> Windows build can do differential testing of Rust vs the DLL to uncover differences in translation.</p><p>I’ve written <a href="http://localhost:1313/posts/sqlite-transactions/#foundationdb" target="_blank">previously</a> about my admiration of the FoundationDB’s <a href="https://www.youtube.com/watch?v=4fFDFbi3toc" target="_blank">deterministic-simulation</a> and that is what this harness allows. PropTest provides the <a href="https://docs.rs/proptest/latest/proptest/test_runner/struct.Config.html#structfield.rng_seed" target="_blank">PROPTEST_RNG_SEED</a> and <a href="https://docs.rs/proptest/latest/proptest/test_runner/struct.Config.html#structfield.rng_algorithm" target="_blank">PROPTEST_RNG_ALGORITHM</a> environment variables so you can easily create deterministic test cases that are reproducible in the event of test-case failure (and can easily be distributed on multiple machines):</p><div><pre><code><span><span><span>#!/bin/bash
</span></span></span><span><span><span>for</span> seed in <span>$(</span>seq <span>0</span> 100<span>)</span><span>;</span> <span>do</span>
</span></span><span><span> <span>echo</span> <span>"=== seed=</span><span>$seed</span><span> ==="</span>
</span></span><span><span> <span>PROPTEST_FORK</span><span>=</span><span>true</span> <span>PROPTEST_VERBOSE</span><span>=</span><span>1</span> <span>PROPTEST_RNG_SEED</span><span>=</span><span>$seed</span> <span>PROPTEST_RNG_ALGORITHM</span><span>=</span>cc <span>PROPTEST_CASES</span><span>=</span><span>1</span> <span>\
</span></span></span><span><span> cargo <span>test</span> --release -- --nocapture
</span></span><span><span> <span>if</span> <span>[</span> <span>$?</span> -ne <span>0</span> <span>]</span><span>;</span> <span>then</span>
</span></span><span><span> <span>echo</span> <span>"FAILED at seed=</span><span>$seed</span><span>"</span>
</span></span><span><span> <span>exit</span> <span>1</span>
</span></span><span><span> <span>fi</span>
</span></span><span><span><span>done</span>
</span></span><span><span><span>echo</span> <span>"All seeds passed"</span>
</span></span></code></pre></div><h2>So what’s next?</h2><p>As I said, this process is mainly for my learning and benchmarking the core foundation model’s evolving capabilities. A year ago Claude and Gemini were simply far, far worse at this task - next year, will they be able to one-shot this?</p><p>I would really love to be able to run this on my own infrastructure. We know local models are getting better but hardware is simply too expensive - but a local NVIDIA RTX PRO 6000 Blackwell Workstation Edition would be nice (hint NVIDIA) or an AMD Strix Halo 128GB (hint AMD).</p><p>Note: I will not be releasing the code as I don’t own the underlying intellectual property and I ask that you do not either if you also perform this task on the same binary.</p></div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
  </script>
</body>
</html>