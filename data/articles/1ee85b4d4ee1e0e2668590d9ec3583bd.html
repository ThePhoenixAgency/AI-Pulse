<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>AI in Multiple GPUs: How GPUs Communicate</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>AI in Multiple GPUs: How GPUs Communicate</h1>
  <div class="metadata">
    Source: Towards Data Science | Date: 2/19/2026 12:00:00 PM | <a href="https://towardsdatascience.com/how-gpus-communicate/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div>
<p>is part of a series about distributed AI across multiple GPUs:</p> <ul>
<li><a href="https://towardsdatascience.com/understanding-the-host-and-device-paradigm/">Part 1: Understanding the Host and Device Paradigm</a></li> <li><a href="https://towardsdatascience.com/point-to-point-and-collective-operations/">Part 2: Point-to-Point and Collective Operations</a></li> <li><strong>Part 3: How GPUs Communicate</strong>&nbsp;(this article)</li> <li>Part 4: Gradient Accumulation &amp; Distributed Data Parallelism (DDP) <em>(coming soon)</em></li> <li>Part 5: ZeRO <em>(coming soon)</em></li> <li>Part 6: Tensor Parallelism&nbsp;<em>(coming soon)</em></li>
</ul> <h2>Introduction</h2> <p>Before diving into advanced parallelism techniques, we need to understand the key technologies that enable GPUs to communicate with each other.</p> <p>But why do GPUs need to communicate in the first place? When training AI models across multiple GPUs, each GPU processes different data batches but they all need to stay synchronized by sharing gradients during backpropagation or exchanging model weights. The specifics of what gets communicated and when depends on your parallelism strategy, which we’ll explore in depth in the next blog posts. For now, just know that modern AI training is communication-intensive, making efficient GPU-to-GPU data transfer critical for performance.</p> <h2>The Communication Stack</h2> <h3>PCIe<a href="http://localhost:7044/posts/2025-10-01-how-gpus-communicate/index.html#pcie"></a></h3> <p>PCIe (Peripheral Component Interconnect Express) connects expansion cards like GPUs to the motherboard using independent point-to-point serial lanes. Here’s what different PCIe generations offer for a GPU using 16 lanes:</p> <ul>
<li><strong>Gen4 x16</strong>: ~32 GB/s bidirectional</li> <li><strong>Gen5 x16</strong>: ~64 GB/s bidirectional</li> <li><strong>Gen6 x16</strong>: ~128 GB/s bidirectional (FYI 16 lanes × 8 GB/s/lane = 128 GB/s)</li>
</ul> <p>High-end server CPUs typically offer 128 PCIe lanes, and modern GPUs need 16 lanes for optimal bandwidth. This is why you usually see 8 GPUs per server (128 = 16 x 8). Power consumption and physical space in server chassis also make it impractical to go beyond 8 GPUs in a single node.</p> <h3>NVLink<a href="http://localhost:7044/posts/2025-10-01-how-gpus-communicate/index.html#nvlink"></a></h3> <p>NVLink enables direct GPU-to-GPU communication within the same server (node), bypassing the CPU entirely. This NVIDIA-proprietary interconnect creates a direct memory-to-memory pathway between GPUs with huge bandwidth:</p> <ul>
<li><strong>NVLink 3 (A100)</strong>: ~600 GB/s per GPU</li> <li><strong>NVLink 4 (H100)</strong>: ~900 GB/s per GPU</li> <li><strong>NVLink 5 (Blackwell)</strong>: Up to 1.8 TB/s per GPU</li>
</ul> <figure><img src="https://contributor.insightmediagroup.io/wp-content/uploads/2026/02/1Qty8oEjinArM-wIAly_ZdA-1024x523.webp" alt=""><figcaption>Source:&nbsp;<a href="https://github.com/amirgholami/ai_and_memory_wall/blob/main/imgs/pngs/hw_scaling.png">GitHub</a> (MIT license)</figcaption></figure> <blockquote>
<p><strong>Note: on NVLink for CPU-GPU communication</strong></p> <p>Certain CPU architectures support NVLink as a PCIe replacement, dramatically accelerating CPU-GPU communication by overcoming the PCIe bottleneck in data transfers, such as moving training batches from CPU to GPU. This CPU-GPU NVLink capability makes CPU-offloading (a technique that saves VRAM by storing data in RAM instead) practical for real-world AI applications. Since scaling RAM is typically more cost-effective than scaling VRAM, this approach offers significant economic advantages.</p> <p>CPUs with NVLink support include IBM POWER8, POWER9, and NVIDIA Grace.</p>
</blockquote> <p>However, there’s a catch. In a server with 8x H100s, each GPU needs to communicate with 7 others, splitting that 900 GB/s into seven point-to-point connections of about 128 GB/s each. That’s where NVSwitch comes in.</p> <h3>NVSwitch<a href="http://localhost:7044/posts/2025-10-01-how-gpus-communicate/index.html#nvswitch"></a></h3> <p>NVSwitch acts as a central hub for GPU communication, dynamically routing (switching if you will) data between GPUs as needed. With NVSwitch, every Hopper GPU can communicate at 900 GB/s with all other Hopper GPUs simultaneously, i.e.&nbsp;peak bandwidth doesn’t depend on how many GPUs are communicating. This is what makes NVSwitch “non-blocking”. Each GPU connects to several NVSwitch chips via multiple NVLink connections, ensuring maximum bandwidth.</p> <p>While NVSwitch started as an intra-node solution, it’s been extended to interconnect multiple nodes, creating GPU clusters that support up to 256 GPUs with all-to-all communication at near-local NVLink speeds.</p> <p>The generations of NVSwitch are:</p> <ul>
<li><strong>First-Generation</strong>: Supports up to 16 GPUs per server (compatible with Tesla V100)</li> <li><strong>Second-Generation</strong>: Also supports up to 16 GPUs with improved bandwidth and lower latency</li> <li><strong>Third-Generation</strong>: Designed for H100 GPUs, supports up to 256 GPUs</li>
</ul> <h3>InfiniBand<a href="http://localhost:7044/posts/2025-10-01-how-gpus-communicate/index.html#infiniband"></a></h3> <p>InfiniBand handles inter-node communication. While much slower (and cheaper) than NVSwitch, it’s commonly used in datacenters to scale to thousands of GPUs. Modern InfiniBand supports NVIDIA GPUDirect RDMA (Remote Direct Memory Access), letting network adapters access GPU memory directly without CPU involvement (no expensive copying to host RAM).</p> <p>Current InfiniBand speeds include:</p> <ul>
<li><strong>HDR</strong>: ~25 GB/s per port</li> <li><strong>NDR</strong>: ~50 GB/s per port</li> <li><strong>NDR200</strong>: ~100 GB/s per port</li>
</ul> <p>These speeds are significantly slower than intra-node NVLink due to network protocol overhead and the need for two PCIe traversals (one at the sender and one at the receiver).</p> <h2>Key Design Principles</h2> <h3>Understanding Linear Scaling<a href="http://localhost:7044/posts/2025-10-01-how-gpus-communicate/index.html#understanding-linear-scaling"></a></h3> <p>Linear scaling is the holy grail of distributed computing. In simple terms, it means doubling your GPUs should double your throughput and halve your training time. This happens when communication overhead is minimal compared to computation time, allowing each GPU to operate at full capacity. However, perfect linear scaling is rare in AI workloads because communication requirements grow with the number of devices, and it’s usually impossible to achieve perfect compute-communication overlap (explained next).</p> <h3>The Importance of Compute-Communication Overlap<a href="http://localhost:7044/posts/2025-10-01-how-gpus-communicate/index.html#the-importance-of-compute-communication-overlap"></a></h3> <p>When a GPU sits idle waiting for data to be transferred before it can be processed, you’re wasting resources. Communication operations should overlap with computation as much as possible. When that’s not possible, we call that communication an “exposed operation”.</p> <h3>Intra-Node vs.&nbsp;Inter-Node: The Performance Cliff<a href="http://localhost:7044/posts/2025-10-01-how-gpus-communicate/index.html#intra-node-vs.-inter-node-the-performance-cliff"></a></h3> <p>Modern server-grade motherboards support up to 8 GPUs. Within this range, you can often achieve near-linear scaling thanks to high-bandwidth, low-latency intra-node communication.</p> <p>Once you scale beyond 8 GPUs and start using multiple nodes connected via InfiniBand, you’ll see a large performance degradation. Inter-node communication is much slower than intra-node NVLink, introducing network protocol overhead, higher latency, and bandwidth limitations. As you add more GPUs, each GPU must coordinate with more peers, spending more time idle waiting for data transfers to complete.</p> <h2>Conclusion</h2> <blockquote>
<p>Follow me on X for more free AI content <a href="https://x.com/l_cesconetto">@l_cesconetto</a></p>
</blockquote> <p>Congratulations on making it to the end! In this post you learned about:</p> <ul>
<li>The CPU-GPU and GPU-GPU communication fundamentals:
<ul>
<li>PCIe, NVLink, NVSwitch, and InfiniBand</li>
</ul>
</li> <li>Key design principles for distributed GPU computing</li> <li>You’re now able to make much more informed decisions when designing your AI workloads</li>
</ul> <p><strong>In the next&nbsp;blog post, we’ll dive into our first parallelism technique, the Distributed Data Parallelism.</strong></p> <h2>References</h2> <ol>
<li><a href="https://developer.nvidia.com/blog/nvidia-nvlink-and-nvidia-nvswitch-supercharge-large-language-model-inference/" target="_blank">NVIDIA Blog</a></li> <li><a href="https://developer.nvidia.com/gpudirect" target="_blank">GPU Direct</a></li>
</ol> </div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>