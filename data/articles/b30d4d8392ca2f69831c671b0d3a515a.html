<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Show HN: Vexp – Local-first context engine for AI coding agents</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Show HN: Vexp – Local-first context engine for AI coding agents</h1>
  <div class="metadata">
    Source: Hacker News Show | Date: 2/23/2026 3:52:12 PM | <a href="https://news.ycombinator.com/item?id=47123966" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div><div><p>I built vexp to solve two problems I kept hitting with AI coding agents (Claude Code, Cursor, etc.):</p><p>1. Token waste: agents read entire files linearly to understand a codebase. On a medium TypeScript project, a single query was consuming ~18k tokens of context when only ~2.4k were relevant.</p><p>2. Session amnesia: every new session starts from zero. The agent re-reads the same files, re-discovers the same architecture, re-traces the same dependencies.</p><p>How it works:</p><p>- tree-sitter parses the codebase and extracts symbols + relationships into a SQLite dependency graph
- When an agent requests context, vexp serves a token-budgeted "capsule" containing only the relevant nodes: the target function, its callers, imported types, cross-file dependencies — not entire files
- Session memory: every agent interaction is auto-captured as an observation linked to specific graph nodes. Next session, relevant observations surface automatically via MCP
- Staleness detection: when code changes, observations linked to modified symbols are flagged stale. The agent sees "I learned X about this function, but it's changed since then"
- Cross-repo: detects API contracts, shared types, and env contracts across multiple repos, all locally via workspace config</p><p>Architecture: native Rust binary + SQLite. No cloud, no embedding model, no external dependencies. Talks to agents via MCP (Model Context Protocol) stdio. Currently distributed as a VS Code extension but the MCP server is standalone.</p><p>The dependency graph is fully deterministic — AST structural analysis, not vector embeddings. Code relationships are facts (imports, calls, type references), not similarity scores. This means zero hallucination risk in the retrieval layer and trivial staleness detection (you know exactly which nodes changed).</p><p>Hybrid search for memory: FTS5 BM25 + TF-IDF cosine similarity + recency decay (7-day half-life) + graph proximity scoring - staleness penalty.</p><p>Supports 11 languages, 12+ MCP-compatible agents. Free tier includes context capsules + all session memory tools.</p><p><a href="https://vexp.dev/">https://vexp.dev</a></p><p>Happy to discuss the architectur; the most interesting design decisions were around the scoring algorithm for pivot node selection and how to link observations to graph nodes without making the staleness detection too aggressive or too lenient.</p></div></div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>