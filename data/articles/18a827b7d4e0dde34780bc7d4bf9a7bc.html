<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>The single-packet attack: making remote race-conditions 'local'</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>The single-packet attack: making remote race-conditions 'local'</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 10/18/2023 2:54:01 PM | Lang: EN |
    <a href="https://portswigger.net/research/the-single-packet-attack-making-remote-race-conditions-local" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div> <div> <p><img alt="James Kettle" src="https://portswigger.net/content/images/profiles/callout_james_kettle_112px.png"></p>
</div> <ul> <li> <p><span></span><strong>Published: </strong>18 October 2023 at 12:54 UTC</p> </li> <li> <p><strong>Updated: </strong>18 October 2023 at 12:59 UTC</p> </li> <li> </li> </ul> <p><img src="https://portswigger.net/cms/images/0c/e7/b25f-article-single-packet-attacks-article.png"><br></p><p>The single-packet attack is a new technique for triggering web <a href="https://portswigger.net/web-security/race-conditions">race conditions</a>. It works by completing multiple HTTP/2 requests with a single TCP packet, which effectively eliminates network jitter and means the requests get processed extremely close together. This makes <i>remote</i> race conditions just as easy to exploit as if they were <i>local</i>.</p>
<p>It's been great to see the community having a lot of success finding race conditions with the single-packet attack over the last two months. One person even used it to <a href="https://twitter.com/albinowax/status/1707732002483368118">exploit a website I made myself</a>. Quite a few people have asked what other network protocols it might work on, so in this post I'll explore protocols including HTTP/3, HTTP/1.1, <a href="https://portswigger.net/web-security/websockets">WebSockets</a>, and SMTP. Where it's not viable, I'll look at what the best alternatives are. I'll also provide guidelines for adapting it to your protocol of choice.</p>
<h3>Single-packet attack recap</h3><p>I introduced the single-packet attack in <a href="https://portswigger.net/research/smashing-the-state-machine#single-packet-attack">Smashing the state machine: the true potential of web race conditions</a>. If you're already familiar with it, you can skip this section.</p>
<h4>Why jitter hides race conditions</h4><p>To trigger a race condition, you typically need a website to receive and process multiple HTTP requests in a very small time-window. Requests sent to remote systems simultaneously don't reliably arrive simultaneously thanks to network jitter; unpredictable, network-induced delays in packet transmission:</p><p><img src="https://portswigger.net/cms/images/f9/1e/4365-article-blackhat_diagrams-07.png"></p><p>This makes detecting race conditions on remote systems much harder than on local systems.</p>
<h4>Solving jitter with the single-packet attack</h4>
<p>The single-packet solves network jitter by adapting and combining the 'last byte sync' and 'timeless timing attack' techniques:</p><ul><li>Issue all the requests over a single HTTP/2 connection, withholding a tiny fragment from each so the server doesn't start to process it</li><li>Wait for a short time for the packets to arrive on the target server</li><li>Issue the final fragment of each of the requests</li><li>Your operating system will group these into a single TCP packet</li></ul>
<p>You can visualise the result as something like this:</p><p><img src="https://portswigger.net/cms/images/b6/d6/9239-article-blackhat_diagrams-08.png"></p><p>The use of a single TCP packet to complete all the requests means that they always get processed at the same time, regardless of how much network jitter delayed their delivery. This approach easily scales to 20-30 requests, and is shockingly easy to implement. It's available in Burp Suite's Repeater via the tab group functionality, and also in my open source extension Turbo Intruder.</p><p>If you'd like to try the technique out for yourself, try out our free&nbsp;<a href="https://portswigger.net/web-security/race-conditions" target="_blank">race condition labs</a>.</p>
<p>For further details on the development and implementation of this technique, and some benchmarks, check out the <a href="https://portswigger.net/research/smashing-the-state-machine" target="_blank">original whitepaper</a> or <a href="https://www.youtube.com/watch?v=tKJzsaB1ZvI&amp;start=396" target="_blank">this presentation clip</a>.</p>
<h2>Applying the single-packet attack to other protocols</h2>
<p>Given how powerful the single-packet attack is, it's natural to wonder if it can be adapted to other network protocols, perhaps enabling an HTTP/3 login limit-overrun, a WebSocket race condition, or an SMTP timing attack. Let's take a look and see.</p>
<h4>HTTP/3</h4>
<p>First off, let's take a look at HTTP/3. The main difference between HTTP/2 and HTTP/3 is that HTTP/2 is layered on top of TLS and TCP, whereas HTTP/3 is built on QUIC and UDP. </p>
<p>To apply the single-packet attack over HTTP/3, we need to complete multiple HTTP requests with a single UDP datagram. HTTP/3's support for multiplexing means this is definitely possible, but there's one limitation. UDP has a maximum packet size of ~1,500 bytes, as opposed to TCP's 65,535. This might make HTTP/3 sound terrible for the single-packet attack, but in practice, TCP has a soft limit of 1,500 bytes as well and I never explored how to push beyond this because 20-30 requests is sufficient for most race conditions.</p>
<p>Ultimately, HTTP/3 does support the single-packet attack but it's probably not worth the development effort right now. If you want to push the state of the art of race condition exploits over HTTP forward, you'd probably be better off trying to improve the HTTP/2 implementation to get closer to TCP's max packet size. This could enable around 800 requests completed simultaneously, which would be quite entertaining.</p>
<h4>HTTP/1.1</h4>
<p>HTTP/1.1 lets you send multiple requests over a single TCP connection, and thanks to TCP buffering on many servers you don't need to wait for a response before sending the next message. Stuffing multiple requests down a connection without waiting for a reply is known as <a href="https://datatracker.ietf.org/doc/html/rfc7230#section-6.3.2">pipelining</a>, and it's the key feature that makes <a href="https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack" target="_blank">Turbo Intruder</a> so fast. Using pipelining, it's technically possible to stuff multiple entire HTTP requests into a single TCP packet.</p>
<p>Unfortunately, the RFC dictates that the server must send the responses in the order that the requests were received in. This means that although it's technically possible for a HTTP server to process multiple pipelined requests simultaneously, it wouldn't give the server much of a speed boost since the response to the first request would end up blocking the response to the second. This is sometimes referred to as the 'head of line blocking' problem.</p>
<p>Thanks to this problem, I think you'll find that although plenty of webservers support pipelined requests, they'll get processed sequentially and if you want to do a race condition attack you'd be better off using parallel connections with last-byte sync. Burp Repeater will do this automatically for HTTP/1.1 connections.</p>
<h4>SMTP</h4>
<p>Just like HTTP/1.1, you can stuff multiple SMTP messages into a single packet, using the pipelining extension as defined in RFC 2920. Unfortunately, once again the responses must be sent in order, so it's unlikely that any implementations would process these requests in parallel. </p>
<p>This is a shame, because I expect there's some interesting race conditions hidden behind SMTP handlers.</p>
<h4>WebSocket</h4>
<p>The WebSocket protocol is much more promising than HTTP/1.1 because there's no concept of a 'response'. This means servers can process multiple messages sent over a single connection concurrently without worrying about what order to send any resulting messages in. Of course, some implementations may still choose not to do this, to avoid the complexity.</p>
<p>Unlike HTTP/2, you can't abuse fragmentation to increase the number of messages you can complete with the critical packet. This is because although you're allowed to fragment messages, you can't have multiple fragmented messages in-flight at the same time:</p>
<blockquote>The fragments of one message MUST NOT be interleaved between the fragments of another message RFC6455</blockquote> <p>The good news is, there's a solution waiting in <a href="https://www.rfc-editor.org/rfc/rfc8441.html" target="_blank">RFC 8441 - Bootstrapping WebSockets with HTTP/2</a>. This proposes nesting WebSocket connections inside HTTP/2 streams, and would enable full power single-packet attacks on servers that support it.</p>
<p>I think WebSocket race conditions are widely overlooked due to little tooling targeting this niche, so the area has a lot of potential even without the single-packet attack.</p>
<h4>Other protocols?</h4>
<p>The key feature that enables the single-packet attack is multiplexing - support for multiple concurrent messages on a single connection. Many protocols support multiple sequential messages in a single packet, sometimes unintentionally, but they're generally let down by server implementation choices.</p>
<p>Support for interleaved fragments is a crucial performance factor, as it increases the number of messages that can be squeezed into a packet. The other major performance factor is the maximum packet size of the underlying protocol.</p>
<h4>Coalescing at different layers</h4>
<p>Coalescing the final request fragments into a single TCP packet isn't the only viable option. You could alternatively place the final fragments in a single TLS record. Since TLS is layered over TCP, this would work even if the record was delivered via multiple distinct TCP packets. </p>
<p>I believe this would enable the attack to work reliably through non-decrypting tunnels like SOCKS proxies. However, it would probably require a customised TLS implementation so ultimately it'd be trickier to implement than the classic TCP approach. </p>
<h3>Conclusion</h3>
<p>Right now, there's a bunch of web race conditions on HTTP/2 websites that were near-impossible to detect and exploit are now ripe for the taking. We've used RFC-based analysis to evaluate which other protocols might support the variants of single-packet attack. The next step for any of these would be to create a proof of concept tool, and then do some probing on popular server implementations to see if they're compatible. As ever, if there's no proof of concept, it's not really proven!</p>
<p>New tooling would potentially expose a bunch more vulnerabilities affecting WebSockets, and perhaps some more HTTP-based ones that require over 30 simultaneous requests to detect.&nbsp;</p><p>If you missed it, you might also like&nbsp;<a href="https://portswigger.net/research/how-to-build-custom-scanners-for-web-security-research-automation" target="_blank">building custom scanners for web security automation</a>.</p> <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
  </script>
</body>
</html>