<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Repeater Strike: manual testing, amplified</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.8; color: #e2e8f0; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.5em; }
  .metadata { color: #94a3b8; font-size: 0.9em; margin-bottom: 2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 1em; }
  img { max-width: 100%; height: auto; border-radius: 8px; }
  a { color: #00d9ff; }
  p { margin-bottom: 1em; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 15px; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 15px; border-radius: 6px; overflow-x: auto; }
</style>
</head>
<body>
  <h1>Repeater Strike: manual testing, amplified</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 7/15/2025 | Lang: EN |
    <a href="https://portswigger.net/research/repeater-strike-manual-testing-amplified" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div>
    
    
    
<div>
    <p><img alt="Gareth Heyes" src="https://portswigger.net/content/images/profiles/callout_gareth_heyes_114px.png" /></p>
</div>
    <ul>
        <li>
            <p><span></span><strong>Published: </strong>15 July 2025 at 13:46 UTC</p>
        </li>
        <li>
            <p><strong>Updated: </strong>15 July 2025 at 13:46 UTC</p>
        </li>
        <li>
        </li>
    </ul>
    <p><img src="https://portswigger.net/cms/images/5a/b1/e508-article-repeater_strike_new_demo.gif" alt="Repeater Strike demo showing an IDOR Academy lab being solved" /><br /></p><p>Manual testing doesn't have to be repetitive. In this post, we're introducing Repeater Strike - a new AI-powered Burp Suite extension designed to automate the hunt for <a href="https://portswigger.net/web-security/access-control/idor">IDOR</a> and similar vulnerabilities. By analyzing your Repeater traffic, Repeater Strike generates smart regular expressions based on the requests and responses you're testing. It then applies these regexes across your proxy history to uncover related issues, letting you turn a single vulnerability into a broader set of actionable findings with minimal effort.
</p><p>At PortSwigger research we're experimenting with AI to produce semi-automated tools that help enhance your security testing. One of the ideas I had was to use AI to find variations and so I built 
<a href="https://portswigger.net/research/shadow-repeater-ai-enhanced-manual-testing">Shadow Repeater
</a>. This turned out to be quite cool and it fit nicely into what AI is good at. I wondered if I could do more than just generate variations. I had a thought of taking what you do in Repeater and scanning your proxy history to discover more of it.
</p><p>I experimented with three different methods of finding the vulnerability: Java compilation, regular expression and differential based analysis. I spent some time generating scan checks using a dynamically generated Java class but soon realised that you use multiple regular expressions to accomplish the same thing. I turned my focus to regexes instead.
</p><p>The first step was to use the AI to identify the vulnerability and produce a JSON object to help the next agent:
</p><p><code>
Â Â Â "param": {<br />Â Â Â Â Â Â Â Â "values": ["wiener"],<br />Â Â Â Â Â Â Â Â "name": "id",<br />Â Â Â Â Â Â Â Â "type": "URL",<br />Â Â Â Â Â Â Â Â "vulnerabilityClass": "IDOR"<br />Â Â Â Â }
</code></p><p>The AI correctly identified what you may be testing for and noticed that based on the requests you sent to it you are testing the URL with a parameter called id. The initial probe was to probe for wiener ðŸ˜‚. The AI then takes this probe and tries to find something uniquely identifiable in the response:
</p><p><code>
"responseRegexes": [[<br />Â Â Â Â Â "Your username is: wiener",<br />Â Â Â Â Â Â "Your API Key is: [A-Za-z0-9]{32}",<br />Â Â Â Â Â Â "&lt;a href=\"/my-account\\?id=wiener\"&gt;My account&lt;\/a&gt;"<br />Â Â ]]
</code></p><p>Pretty cool the AI has identified the username reflection and the API key and I told it to match the structure of the data so it can find more rather than the specific key. Now it tries to reproduce the finding by making the request with the probe before it generates the new Strike Rule. If the replication was successful, Repeater Strike then prompts you for a Strike Rule name.
</p><p>The next step is to mutate the probes and response regexes. This wouldn't have been possible a year ago but now the AI models are super smart. They can take the data and mutate it very cleverly. It's worth noting that I haven't told it specific instructions about the vulnerability it can work it out from the JSON structure I gave to it:
</p><p><code>{<br />"mutatedProbesToUse": [<br />Â Â Â Â Â Â Â Â Â Â Â Â "admin",<br />Â Â Â Â Â Â Â Â Â Â Â Â "testuser",<br />Â Â Â Â Â Â Â Â Â Â Â Â "anonymous",<br />Â Â Â Â Â Â Â Â Â Â Â Â "user123",<br />            ...<br />],<br />Â Â Â Â Â Â Â Â "mutatedResponsesRegexes": [<br />Â Â Â Â Â Â Â Â Â Â Â Â [<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your username is: admin",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your API Key is: [A-Za-z0-9]{32}",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "&lt;a href=\"/my-account\\?id=admin\"&gt;My account&lt;\/a&gt;"<br />Â Â Â Â Â Â Â Â Â Â Â Â ],<br />Â Â Â Â Â Â Â Â Â Â Â Â [<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your username is: testuser",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your API Key is: [A-Za-z0-9]{32}",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "&lt;a href=\"/my-account\\?id=testuser\"&gt;My account&lt;\/a&gt;"<br />Â Â Â Â Â Â Â Â Â Â Â Â ],<br />Â Â Â Â Â Â Â Â Â Â Â Â [<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your username is: anonymous",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your API Key is: [A-Za-z0-9]{32}",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "&lt;a href=\"/my-account\\?id=anonymous\"&gt;My account&lt;\/a&gt;"<br />Â Â Â Â Â Â Â Â Â Â Â Â ],<br />Â Â Â Â Â Â Â Â Â Â Â Â [<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your username is: user123",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "Your API Key is: [A-Za-z0-9]{32}",<br />Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "&lt;a href=\"/my-account\\?id=user123\"&gt;My account&lt;\/a&gt;"<br />Â Â Â Â Â Â Â Â Â Â Â Â ],<br />Â Â Â Â Â Â Â Â Â Â Â Â ...<br />}
</code></p><p>Once the AI has mutated the probes and regexes, it can then scan your proxy history looking for this behaviour. You can even set up Repeater Strike to dynamically create Strike Rules on every Repeater request sent. You might expect this to burn through a load of AI tokens but actually to create this particular Strike Rule it only cost me 61 tokens and once the rule has been generated it uses no further tokens!
</p><p>If the AI generated regular expressions failed, no problem I created a Strike Rule editor that lets you edit the generated Strike Rule, hit save and then scan your proxy history all without further tokens.
</p><h2>Challenges</h2><p>During development, I ran into several challenges. One of the major issues was handling large responses - while the AI could interpret smaller ones effectively, it struggled with longer responses from sites like Facebook. I initially truncated the data, but this led to important context being lost.
</p><p>Another hurdle was inconsistent output from the AI. For example, when generating regular expressions, it sometimes failed to properly escape metacharacters, leading to runtime errors. A workaround was to programmatically escape these characters when exceptions occurred.</p><p>The broader concept also proved difficult to generalise too. While the system could detect issues like IDOR on specific sites, it was hard to create regular expression patterns flexible enough to work across different sites without being too site-specific.
</p><p>I experimented with response diffing as a way to extract meaningful information by filtering out noise - such as insignificant headers - and focusing only on the parts that change.
</p><p>In the end I ran out of time to fully solve it - but maybe you can.
</p><p>Can you find an elegant solution to reliably isolate meaningful UI changes and feed them to the AI? Let's push this further.
</p><p>I hope I've inspired you to 
<a href="https://portswigger.net/burp/documentation/desktop/extend-burp/extensions/creating/creating-ai-extensions"><span>create your own Burp AI extensions.
</span></a> It really is super easy to get started. If you need help on how to use Repeater Strike please 
<a href="https://github.com/hackvertor/repeat-strike">consult the readme
</a>. </p><p><b>Please note to use this extension you need to be on the Early Adopter channel. It is currently considered experimental and is far from a finished product.</b></p>
    
    <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
</body>
</html>