<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.8; color: #e2e8f0; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.5em; }
  .metadata { color: #94a3b8; font-size: 0.9em; margin-bottom: 2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 1em; }
  img { max-width: 100%; height: auto; border-radius: 8px; }
  a { color: #00d9ff; }
  p { margin-bottom: 1em; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 15px; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 15px; border-radius: 6px; overflow-x: auto; }
</style>
</head>
<body>
  <h1>WebSocket Turbo Intruder: Unearthing the WebSocket Goldmine</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 9/17/2025 | Lang: EN |
    <a href="https://portswigger.net/research/websocket-turbo-intruder-unearthing-the-websocket-goldmine" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div>
    
    
    
<div>
    <p><img alt="Zakhar Fedotkin" src="https://portswigger.net/content/images/profiles/callout_zakhar_fedotkin_114px.png" /></p>
</div>
    <ul>
        <li>
            <p><span></span><strong>Published: </strong>17 September 2025 at 12:40 UTC</p>
        </li>
        <li>
            <p><strong>Updated: </strong>18 September 2025 at 07:50 UTC</p>
        </li>
        <li>
        </li>
    </ul>
    <p><img src="https://portswigger.net/cms/images/3b/26/078c-article-ws.png" /><br /></p><p>Many testers and tools give up the moment a protocol upgrade to WebSocket occurs, or only perform shallow analysis. This is a huge blind spot, leaving many bugs like <a href="https://portswigger.net/web-security/access-control">Broken Access Controls</a>, <a href="https://portswigger.net/web-security/race-conditions">Race conditions</a>, and <a href="https://portswigger.net/web-security/sql-injection">SQL injection</a> undetected. In this post, we look at the new version of WebSocket Turbo Intruder, a Burp Suite extension that brings <a href="https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack">Turbo Intruder</a>’s fast attack engine to WebSocket testing. We will also talk about why auto-scanning WebSocket apps is hard, and how this tool helps fix those problems.</p><h2>Outline</h2>    <ul>
<li><a href="#introduction">Introduction</a></li><ul><li><a href="#key-features">Key features</a>
</li><li><a href="#getting-started">Getting started</a>
</li></ul><li><a href="#basic-use">Basic use</a></li><ul><li><a href="#filtering-boring-content">Filtering boring content</a>
</li><li><a href="#automated-testing">Automated testing</a>
</li></ul><li><a href="#exploiting-vulnerabilities">Exploiting vulnerabilities</a></li><ul><li><a href="#server-side-prototype-pollution">Server-side prototype pollution</a> 
</li><li><a href="#race-conditions">Race Conditions</a>  
</li><li><a href="#ping-of-death">Ping of death</a> 
</li></ul><li><a href="#advanced-features">Advanced features</a></li><ul><li><a href="#command-line-interface">Command line interface</a>
</li><li><a href="#debug-mode">Debug mode</a></li></ul><li><a href="#references">References</a></li></ul>
<h2>Introduction</h2>
<p>WebSocket Turbo Intruder is a Burp Suite extension for fuzzing WebSocket messages with custom Python code. It extends the Burp Suite engine so it can exploit the WebSocket protocol specific vulnerabilities.</p>
<h3>Key features</h3><ul><li>High speed - supports thousands of messages per second
</li><li>HTTP adapter - automate testing by integrating with existing HTTP scanners  
</li><li>Smart filtering - hides boring responses so you can focus on interesting results 
</li></ul>
<p>While WebSocket Turbo Intruder includes a custom engine for speed, it’s not as battle-tested as Burp’s built-in engine. If you see errors or connection issues, try switching back to the default engine. Also, this tool is designed for high-volume testing against a single target - since WebSocket connections must stay open, testing large scopes is tricky and not well supported.</p>

<h3>Getting started</h3><p>You can install WebSocket Turbo Intruder directly from the <a href="https://portswigger.net/bappstore/ba292c5982ea426c95c9d7325d9a1066">BApp Store</a>, which is the easiest way to get started. Go to Extensions → BApp Store → WebSocket Turbo Intruder and click Install. If you prefer to build it yourself or want to explore the source code, the project is available on <a href="https://github.com/d0ge/WebSocketTurboIntruder" target="_blank">GitHub</a>. Once installed, the extension will appear as a new menu item when you right click on any message in Burp Suite.</p>
<h2>Basic use</h2><p>The extension comes with two built-in tools: Turbo Intruder and HTTP Middleware. The first one is best when you want to send thousands of WebSocket messages to a single target and look for interesting behavior. The second one is made for automating scanning, we’ll return to that later.</p>
<p>Let’s start with a basic example python script. We will use it to test the PortSwigger Academy lab: <a href="https://portswigger.net/web-security/websockets/lab-manipulating-messages-to-exploit-vulnerabilities">Manipulating WebSocket messages to exploit vulnerabilities</a>.</p><p><img src="https://portswigger.net/cms/images/78/f5/02eb-article-turbo_intruder_2.png" /></p><p>This script sends 10 different numeric values as part of the message JSON value when the Attack button is clicked. The resulting table, shown in the screenshot, will contain all requests (outgoing messages) and responses (incoming messages) handled by the extension.</p><p><img src="https://portswigger.net/cms/images/0c/35/b511-article-turbo_results_2.png" /></p><h3>Filtering boring content</h3><p>Unlike HTTP, the WebSocket protocol can send multiple incoming messages for one outgoing message. This makes testing much harder, because the table quickly fills with noise. In our case, a single "request" triggers three different "responses". To handle this, the extension includes powerful filters. These let you hide irrelevant traffic and lock requests to only the responses you care about. Here’s an example decorator that keeps only messages from the user Hal Pline and filters out everything else:</p><p><code><span>def</span> <span>queue_websockets</span>(upgrade_request, message):
    connection = websocket_connection.create(upgrade_request)
    <span>for</span> i <span>in</span> <span>range</span>(<span>10</span>):
        connection.queue(message, <span>str</span>(i))
<span>def</span> <span>handle_outgoing_message</span>(websocket_message):
    results_table.add(websocket_message)
@<span>MatchRegex</span>(r'<span>{"user":"Hal Pline"</span>')
<span>def</span> <span>handle_incoming_message</span>(websocket_message):
    results_table.add(websocket_message)
</code></p><h3>Automated testing</h3><p>If manual review of the result table is not your style, you can wrap a WebSocket connection inside an HTTP request using WebSocket Turbo Intruder HTTP Middleware. Select any WebSocket message from Proxy History, then right-click and choose Extensions → WebSocket Turbo Intruder → Send to WebSocket HTTP Middleware. This lets you use filters to capture only the traffic you care about while interacting with the server through a local HTTP endpoint.</p>

<p>For example, here we use the included <b>ServerExample.py</b> script to create a WebSocket connection and filter the incoming messages to only show the ones echoed back from the PortSwigger Academy lab:</p>
<p><code><span>def</span> <span>create_connection</span>(upgrade_request):
    connection = websocket_connection.create(upgrade_request)
    <span>return</span> connection
<span>def</span> <span>handle_outgoing_message</span>(websocket_message):
    results_table.add(websocket_message)
@<span>MatchRegex</span>(r'<span>{"user":"You"</span>')
<span>def</span> <span>handle_incoming_message</span>(websocket_message):
    results_table.add(websocket_message)
</code></p><p>From now on, we can send an HTTP POST request to localhost, with the request body treated as a WebSocket message. This allows you to scan any WebSocket using an automated scanner like <a href="https://portswigger.net/burp/pro">Burp Suite Pro</a>.</p><p><code>POST /proxy?url=https%3A%2F%2F0a7c00a903d17c5a801d35d8008a007a.web-security-academy.net%2Fchat HTTP/1.1
Host: 127.0.0.1:9000
Content-Length: 16

{"message":"hi"}
</code></p><p>You can customize this code to match the logic of your target application. This setup is ideal for finding server-side vulnerabilities like <a href="https://portswigger.net/web-security/sql-injection">SQL injection</a>, authentication bypass, or <a href="https://portswigger.net/web-security/os-command-injection">command injection</a>.</p>
<h2>Exploiting vulnerabilities</h2>
<p>In addition to the usual application bugs, <a href="https://portswigger.net/web-security/websockets">WebSockets</a> bring their own unique attack surface. We will look at some of these next.</p>
<h3>WebSocket Server-side prototype pollution</h3><p><a href="https://socket.io/docs/v4/socket-io-protocol/" target="_blank">Socket.IO</a> is a popular JavaScript framework that comes with its own WebSocket implementation. This makes testing more complicated - but with WebSocket Turbo Intruder you can work around these limitations.</p>
<p>The easiest way to confirm that a server uses Socket.IO is by checking the mandatory query parameter EIO, which specifies the protocol version. If it equals 4, the server sends ping packets. We can automate this process with the built-in Ping and Pong decorators. After that, the script sends the initial message <b>"40"</b> to start the conversation, and the rest of the logic works as usual.</p>
<p><code><span>import</span> burp.api.montoya.http.message.params.HttpParameter <span>as</span> HttpParameter;
<span>def</span> <span>queue_websockets</span>(upgrade_request, message):
    connection = websocket_connection.create(
        upgrade_request.withUpdatedParameters(HttpParameter.urlParameter(<span>"EIO"</span>, <span>"4"</span>)))
    connection.queue(<span>'40'</span>)
    connection.queue(<span>'42["message","hello"]'</span>)
@<span>Pong</span>(<span>"3"</span>)
<span>def</span> <span>handle_outgoing_message</span>(websocket_message):
    results_table.add(websocket_message)
@<span>PingPong</span>(<span>"2"</span>, <span>"3"</span>)
<span>def</span> <span>handle_incoming_message</span>(websocket_message):
    results_table.add(websocket_message)
</code></p><p>HTTP adapter script for the Socket.IO protocol:</p><p><code><span>import</span> burp.api.montoya.http.message.params.HttpParameter <span>as</span> HttpParameter;
<span>def</span> <span>create_connection</span>(upgrade_request):
    connection = websocket_connection.create(
        upgrade_request.withUpdatedParameters(HttpParameter.urlParameter(<span>"EIO"</span>, <span>"4"</span>)))
    connection.queue(<span>'40'</span>)
    connection.decIn()
    <span>return</span> connection

@<span>Pong</span>(<span>"3"</span>)
<span>def</span> <span>handle_outgoing_message</span>(websocket_message):
    results_table.add(websocket_message)
@<span>PingPong</span>(<span>"2"</span>, <span>"3"</span>)
<span>def</span> <span>handle_incoming_message</span>(websocket_message):
    results_table.add(websocket_message)
</code></p><p>Interestingly, some protocol quirks in Socket.IO make it a good candidate for server-side <a href="https://portswigger.net/web-security/prototype-pollution">prototype pollution</a>. As shown in <a href="https://x.com/garethheyes" target="_blank">Gareth’s</a> earlier research <a href="https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers">Server-side prototype pollution: Black-box detection without the DoS</a>, it’s possible to abuse Express server features to detect successful pollution. Using the same technique here, we can trick Socket.IO into returning a new greeting message by polluting the <b>initialPacket</b> property with: <code>{"__proto__":{"initialPacket":"Polluted"}}</code></p>
<p>Exploit in action:</p><p><img src="https://portswigger.net/cms/images/ca/54/08e2-article-screenshot_2025-09-16_at_10.42.00.png" /></p><h3>WebSocket Race Conditions</h3>
<p>The default Intruder script sends messages in chunks over a single connection. This is great for performance, but not useful when testing for race condition vulnerabilities, where timing and concurrency matter.</p>
<p>To help with that, WebSocket Turbo Intruder includes a special engine type called THREADED. This engine starts multiple worker threads, each with its own WebSocket connection, and sends messages in parallel. This makes it possible to trigger classic race conditions like logic bypasses, token reuse, or state desync bugs.</p>
<p>Don’t worry if you’re not familiar with Python threading - the included <a href="https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/RaceConditionExample.py" target="_blank">RaceConditionExample.py</a> script needs only small changes to fit your target. The most important settings are defined in the config() method: the number of threads to control how many simultaneous connections are opened.</p>
<p>This threaded model gives you better control over concurrency and lets you experiment with timing-sensitive issues that are invisible to single-connection fuzzing.</p>
<h3>WebSocket ping of death</h3><p>While testing for race conditions, I came across an unexpected denial-of-service vulnerability in a Java WebSocket implementation.</p><p>According to the RFC, a WebSocket frame begins with a header specifying the opcode and payload length. But what happens if the length doesn’t match the actual payload - or the payload is never sent at all?</p><p>Using the TURBO engine, we can send any kind of WebSocket frame, including malformed ones. This allows us to manually adjust the payload length in the header without needing to send gigabytes of data. Java WebSocket implementation has the following issue. It reads the message header and allocates a huge buffer on the server using user specified value at header payload length field, leading to an Out Of Memory crash if that value is Integer Max Value. After that the server is no longer responding to any connection attempts. You can find the full source code in <a href="https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/resources/examples/PingOfDeathExample.py" target="_blank">PingOfDeathExample.py</a> included with the extension.</p>
<h2>Advanced features</h2><h3>Command line interface</h3><p>WebSocket Turbo Intruder also includes a standalone CLI, perfect for automation, scripting, or running attacks outside Burp Suite. Here’s a basic usage example:</p><p><code>java -jar WebSocketFuzzer-2.0.0.jar &lt;scriptFile&gt; &lt;requestFile&gt; &lt;endpoint&gt; &lt;baseInput&gt;
</code></p><p>Command-line support is pretty basic. But it’s great for running long attacks on a single target, especially in background jobs.</p>
<h3>Debug mode</h3><p>WebSocket Turbo Intruder includes a built-in WS Logger feature that records up to 1,000 WebSocket messages. This is especially useful when debugging scripts that use HTTP Middleware, where matching outgoing and incoming messages correctly is key.</p>
<p>With the logger enabled on WebSocket Turbo Intruder → Logger On, you can track both message contents and their internal IDs. These IDs are used to pair requests and responses - so if something breaks or a message gets mismatched, you can inspect the logs to figure out what went wrong.</p>
<p>If needed, you can also fine-tune how message IDs are handled by using dec* and inc* methods from the <a href="https://github.com/d0ge/WebSocketTurboIntruder/blob/main/src/main/java/connection/Connection.java">Connection interface</a>. This gives you full control over how messages are assigned and grouped.</p>
<h2>References</h2><p>Whilst working on the WebSocket Turbo Intruder, I drew inspiration from some excellent work, including <a href="https://x.com/albinowax" target="_blank">@albinowax</a> - <a href="https://portswigger.net/research/turbo-intruder-embracing-the-billion-request-attack%20">Turbo Intruder: Embracing the billion-request attack</a>, <a href="https://x.com/garethheyes" target="_blank">@garethheyes</a> - <a href="https://portswigger.net/research/server-side-prototype-pollution#safe-detection-methods-for-manual-testers">Server-side prototype pollution: Black-box detection without the DoS</a> and <a href="https://x.com/vah_13" target="_blank">@vah_13</a> - <a href="https://github.com/redrays-io/WS_RaceCondition_PoC">Race Conditions in Websockets</a>.</p><h3>A word of caution</h3><p>A quick word of caution - WebSocket Turbo Intruder is powerful. It can send thousands of messages per second and open many connections in parallel. If you’re not careful, you might overload the server or trigger denial-of-service conditions. Always use it on targets where automated scanning is allowed, and try not to take down the internet while you’re at it.</p>
<h3>Reporting bugs and feature requests</h3>
<p>WebSocket Turbo Intruder also supports features like automatic Ping/Pong messages and built-in filtering using the isInteresting() method. You can learn more about these and other advanced options in the <a href="https://github.com/d0ge/WebSocketTurboIntruder">Github repository</a>. If you find a bug or have a feature request, feel free to open <a href="https://github.com/d0ge/WebSocketTurboIntruder/issues" target="_blank">a new issue</a>.</p><p>The recording of the presentation will be available shortly on the Black Hat Arsenal channel.</p><p>Good luck, have fun.</p>
    
    <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
</body>
</html>