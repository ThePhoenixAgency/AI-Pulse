<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Tricks from OpenAI gpt-oss YOU can use with transformers</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Tricks from OpenAI gpt-oss YOU can use with transformers</h1>
  <div class="metadata">
    Source: Hugging Face Blog | Date: 9/11/2025 2:00:00 AM | Lang: EN |
    <a href="https://huggingface.co/blog/faster-transformers" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div> <p><a href="https://huggingface.co/blog"> Back to Articles</a></p> <div><div> <p><span><span><a href="https://huggingface.co/ariG23498"><img alt="Aritra Roy Gosthipaty's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/608aabf24955d2bfc3cd99c6/-YxmtpzEmf3NKOTktODRP.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/sergiopaniego"><img alt="Sergio Paniego's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/61929226ded356549e20c5da/ONUjP2S5fUWd07BiFXm0i.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/reach-vb"><img alt="Vaibhav Srivastav's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1655385361868-61b85ce86eb1f2c5e6233736.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/pcuenq"><img alt="Pedro Cuenca's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1617264212503-603d25b75f9d390ab190b777.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/ArthurZ"><img alt="Arthur Zucker's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1674683851722-62441cb7456803e95009a08f.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/SaylorTwift"><img alt="Nathan Habib's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1678663263366-63e0eea7af523c37e5a77966.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/cyrilvallez"><img alt="Cyril Vallez's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/649a943906690b959319d192/k8ZlmJWF3GNpYLHrdpejY.jpeg"></a> </span> </span></p> </div></div> <p>OpenAI recently released their <a href="https://huggingface.co/collections/openai/gpt-oss-68911959590a1634ba11c7a4">GPT-OSS series of models</a>. The models feature some novel techniques like MXFP4 quantization, efficient kernels, a brand new chat format, and more. To enable the release of gpt-oss through <code>transformers</code>, we have upgraded the <a href="https://github.com/huggingface/transformers/">library</a> considerably. The updates make it very efficient to <strong>load</strong>, <strong>run</strong>, and <strong>fine-tune</strong> the models.</p>
<p>In this blog post, we talk about all the upgrades in-depth, and how they become part of the transformers toolkit so other models (current and future) can benefit from them. Providing clean implementations of new methods in transformers also allows the community to quickly understand and adopt them. Frameworks such as <a href="https://github.com/ml-explore/mlx-lm/pull/354"><code>MLX</code></a>, <a href="https://github.com/ggml-org/llama.cpp/discussions/15396"><code>llama.cpp</code></a> or <a href="https://docs.vllm.ai/projects/recipes/en/latest/OpenAI/GPT-OSS.html"><code>vLLM</code></a> can use the transformers code as a reference to build their own implementations.</p>
<p>For this release, we worked on:</p>
<ul>
<li><a href="#zero-build-kernels-downloadable-from-the-hub">Zero-build Kernels, downloadable from the Hub</a></li>
<li><a href="#mxfp4-quantization">MXFP4 Quantization</a></li>
<li><a href="#tensor-parallelism">Tensor Parallelism</a></li>
<li><a href="#expert-parallelism">Expert Parallelism</a></li>
<li><a href="#dynamic-sliding-window-layer--cache">Dynamic Sliding Window Layer &amp; Cache</a></li>
<li><a href="#continuous-batching--paged-attention">Continuous Batching &amp; Paged Attention</a></li>
<li><a href="#load-larger-models-faster">Load larger models faster</a></li>
</ul>
<blockquote>
<p>Best part: Most of these features should work across all major models within <code>transformers</code>!</p>
</blockquote>
<h2> <a href="#zero-build-kernels-downloadable-from-the-hub"> </a> <span> Zero-build Kernels, downloadable from the Hub </span>
</h2>
<p>A kernel is a <em><strong>specialized</strong></em>, compact program that runs on accelerators to execute tasks like matrix multiplications, activations, or normalizations. In eager PyTorch, operations trigger individual kernels sequentially, which is straightforward but can incur extra memory transfers and launch overheads. PyTorch 2.0's <code>torch.compile</code> with backends like <code>TorchInductor</code> addresses this by automatically fusing and optimizing kernels, delivering <code>2–10×</code> performance gains.</p>
<p>In addition, the community has created custom kernels for frequent combinations of operations, <em>not just individual PyTorch ops like matmul</em>. For example, Flash Attention was created to optimize the critical attention block that defines the transformers architecture, and is present in many models including most LLMs. By carefully combining all the attention operations inside a single kernel, memory transfers are minimized, memory use is reduced, and speedups can be achieved.</p>
<p>The problem is that all these various kernels are available in separate libraries, which creates a dependency bloat if they were to be added to the transformers library. Furthermore, these kernels are not just Python code, they consist of low-level cuda code, glued together with C++ and exposed through a Python layer. This means they have to be compiled in the target system, which in turn requires whatever build system is required by each kernel library.</p>
<p>The <a href="https://huggingface.co/blog/hello-hf-kernels">kernels package</a> solves this problem by downloading pre-built binaries of supported kernels from the Hub. You just indicate the kernel you want to use, and <code>kernels</code> will look for a version compatible with your system and download it on first use.</p>
<h3> <a href="#custom-kernels-for-gpt-oss"> </a> <span> Custom Kernels for GPT-OSS </span>
</h3>
<p><a href="https://github.com/huggingface/transformers/blob/0f1b128d3359a26bd18be99c26d7f04fb3cba914/src/transformers/models/gpt_oss/modeling_gpt_oss.py">GPT-OSS</a>, a Mixture of Experts (MoE) model, is a big user of Kernels from the Hub. It leverages several custom kernels:</p>
<ol>
<li>Liger RMSNorm, used as <a href="https://github.com/huggingface/transformers/blob/0f1b128d3359a26bd18be99c26d7f04fb3cba914/src/transformers/models/gpt_oss/modeling_gpt_oss.py#L46"><code>@use_kernel_forward_from_hub("RMSNorm")</code></a>`</li>
<li>Megablocks MoE kernels: <a href="https://github.com/huggingface/transformers/blob/0f1b128d3359a26bd18be99c26d7f04fb3cba914/src/transformers/models/gpt_oss/modular_gpt_oss.py#L160"><code>@use_kernel_forward_from_hub("MegaBlocksMoeMLP")</code></a></li>
<li>Flash Attention 3 with <a href="https://huggingface.co/kernels-community/vllm-flash-attn3">support for attention sinks</a>.</li>
<li>MXFP4 triton kernels (covered <a href="#mxfp4-in-transformers">later</a>)</li>
</ol>
<p>Let's take a look at the first two ones.</p>
<p>Behind the scenes, the decorators (1 and 2) simply point to community-contributed kernels. For example, <code>RMSNorm</code> comes from <a href="https://huggingface.co/kernels-community/liger_kernels"><code>liger_kernels</code></a>, while the <code>MegaBlocksMoeMLP</code> kernel comes from <a href="https://huggingface.co/kernels-community/megablocks"><code>megablocks</code></a>. Depending on your device (CUDA or ROCm) and whether you’re training or running inference, the right kernel is pulled in automatically.</p>
<p>This design is both <strong>specific and general</strong>: the RMSNorm liger kernels are already being reused across multiple models, and the MoE kernel could be applied to future MoEs as well.</p>
<p>Because <code>kernels</code> pulls code from the Hub, you have to opt-in to this feature by passing <code>use_kernels=True</code> in your model instantiation, as shown below. We enable <code>INFO</code> logging in the example so you can easily verify that downloadable kernels are in use.</p>
<blockquote>
<p>These kernels are not compatible with <code>mxfp4</code>, so inference will happen in <code>bfloat16</code> if you use them. Please, benchmark your system for the best combination in memory and throughput that suits your project!</p>
</blockquote>
<pre><code><span>from</span> transformers <span>import</span> AutoTokenizer, AutoModelForCausalLM <span>import</span> logging
logging.basicConfig(level=logging.INFO) model_id = <span>"openai/gpt-oss-20b"</span>
tokenizer = AutoTokenizer.from_pretrained(model_id) model = AutoModelForCausalLM.from_pretrained( model_id, dtype=<span>"auto"</span>, device_map=<span>"auto"</span>, use_kernels=<span>True</span>,
)
</code></pre>
<p>Running a quick generation yields log messages like</p>
<pre><code>INFO:root:Using layer `LigerRMSNorm` from repo `kernels-community/liger_kernels`
INFO:root:Using layer `MegaBlocksMoeMLP` from repo `kernels-community/megablocks`
</code></pre>
<p><strong>Figure 1</strong> shows that, in the system we tested, these kernels work best for larger batch sizes. We always recommend to benchmark any performance-related changes as closely to your production conditions as possible.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/benchmark-kernels-with-without.png"><img alt="benchmark with and without kernels" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/benchmark-kernels-with-without.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 1: Benchmarking results of custom kernels</td>
</tr>
</tbody> </table>
</div>
<blockquote>
<p>You can explore and play with the benchmarking script <a href="https://huggingface.co/datasets/ariG23498/faster-transformers-scripts/blob/main/benchmark-kernels-with-without.py">here</a></p>
</blockquote>
<h3> <a href="#flash-attention-3"> </a> <span> Flash Attention 3 </span>
</h3>
<p>OpenAI gpt-oss models use <em>attention sinks</em>, which improves quality and facilitates the use of longer contexts. The vLLM team added this feature to the latest version of Flash Attention (Flash Attention 3), and the resulting custom kernel is available <a href="https://huggingface.co/kernels-community/vllm-flash-attn3">on the Hub</a>. Currently, this kernel is compatible with the Hopper architecture. If you have one, this is the way to enable it:</p>
<pre><code>model = AutoModelForCausalLM.from_pretrained( model_id, dtype="auto", device_map="auto",
<span>+ # Flash Attention with Sinks</span>
<span>+ attn_implementation="kernels-community/vllm-flash-attn3",</span>
)
</code></pre>
<h2> <a href="#mxfp4-quantization"> </a> <span> MXFP4 Quantization </span>
</h2>
<p>Large language models are memory-hungry. Quantization reduces memory footprint by storing weights (and sometimes activations) in lower-precision formats. For reference, <code>FP32</code> uses 32 bits per number and <code>BF16</code> uses 16. By reducing bit width, we trade some precision for smaller models and faster memory movement.</p>
<p>If you want a visual primer on quantization trade-offs, <a href="https://huggingface.co/MaartenGr">Maarten Grootendorst’s</a> article is excellent: <a href="https://newsletter.maartengrootendorst.com/p/a-visual-guide-to-quantization"><em>A Visual Guide to Quantization</em></a>.</p>
<h3> <a href="#what-is-mxfp4"> </a> <span> What is MXFP4 </span>
</h3>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/mxfp4.png"><img alt="explanation of mxfp4 format" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/mxfp4.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 2: The E2M1 format used in the MXFP4 format</td>
</tr>
</tbody> </table>
</div>
<p><code>MXFP4</code> is a 4-bit floating format with E2M1 layout: 1 sign bit, 2 exponent bits, and 1 mantissa bit, as shown in <strong>Figure 2</strong>. On its own, E2M1 is very coarse. MXFP4 compensates with <strong>blockwise scaling</strong>:</p>
<ul>
<li>Vectors are grouped into blocks of 32 elements.</li>
<li>Each block stores a shared scale that restores dynamic range when dequantizing.</li>
<li>Inside each block, 4-bit values represent numbers relative to that scale.</li>
</ul>
<p>This blockwise scheme lets <code>MXFP4</code> keep range while using very few bits. In practice, GPT-OSS 20B fits in roughly <code>16 GB</code> of VRAM and GPT-OSS 120B fits in roughly <code>80 GB</code> when <code>MXFP4</code> is active, which is the difference between “cannot load” and “can run on a single GPU.” The catch is that matrix multiplies now have to respect block scales. Doing this efficiently at scale requires dedicated kernels.</p>
<h3> <a href="#mxfp4-in-transformers"> </a> <span> MXFP4 in <code>transformers</code> </span>
</h3>
<p><code>transformers</code> now includes native support for MXFP4, leveraging optimized <code>triton</code> (MXFP4) kernels for enhanced performance. This builds on the community-driven kernel distribution <a href="#zero-build-kernels-downloadable-from-the-hub">discussed earlier</a>, utilizing pre-compiled kernels from the Hub to simplify deployment.</p>
<p>Key implementation details:</p>
<ul>
<li>Quantizer logic: Found in the <a href="https://github.com/huggingface/transformers/blob/0997c2f2ab08c32c8e2f90aaad06e29a7108535b/src/transformers/quantizers/quantizer_mxfp4.py">MXFP4 quantizer file</a>, this handles the core quantization process for MXFP4.</li>
<li>Integration hooks: The <a href="https://github.com/huggingface/transformers/blob/0997c2f2ab08c32c8e2f90aaad06e29a7108535b/src/transformers/integrations/mxfp4.py">MXFP4 integration file</a> enables seamless use of MXFP4 within the transformers framework.</li>
</ul>
<p>To check if a model supports <code>MXFP4</code>, inspect its configuration:</p>
<pre><code><span>from</span> transformers <span>import</span> GptOssConfig model_id = <span>"openai/gpt-oss-120b"</span>
cfg = GptOssConfig.from_pretrained(model_id)
<span>print</span>(cfg.quantization_config) <span># Example output:</span>
<span># {</span>
<span># 'modules_to_not_convert': [</span>
<span># 'model.layers.*.self_attn',</span>
<span># 'model.layers.*.mlp.router',</span>
<span># 'model.embed_tokens',</span>
<span># 'lm_head'</span>
<span># ],</span>
<span># 'quant_method': 'mxfp4'</span>
<span># }</span>
</code></pre>
<p>If <code>'quant_method': 'mxfp4'</code> is present, the model will automatically use the MXFP4 pathway with Triton kernels when supported.</p>
<blockquote>
<p>Thanks to this <a href="https://github.com/huggingface/transformers/pull/40176">pull request</a>, you can fine-tune gpt-oss models and save them directly to the Hub in MXFP4 format, streamlining deployment with optimized performance.</p>
</blockquote>
<h3> <a href="#requirements-and-fallbacks"> </a> <span> Requirements and fallbacks </span>
</h3>
<p>To run <code>MXFP4</code> on GPU you need:</p>
<ol>
<li><code>accelerate</code>, <code>kernels</code>, and <code>triton&gt;=3.4</code> installed. Note that <code>Pytorch 2.8</code> already comes with <code>triton 3.4</code>, so you only need to manually install triton if using <code>Pytorch 2.7</code>.</li>
<li>NVIDIA GPU with compute capability <code>≥ 7.5</code>. This goes all the way back to Tesla, so you can run <code>gpt-oss-20b</code> on the free tiers of Google Colab and Kaggle, and on many consumer GPUs.</li>
</ol>
<p>If these constraints are not met, <code>transformers</code> falls back to a higher-precision path (<code>bfloat16</code> is used by default), which requires about 4× the memory of MXFP4.</p>
<p>The <a href="https://huggingface.co/datasets/ariG23498/faster-transformers-scripts/blob/main/memory-requirements-quantized-vs-dequantized.py">snippet</a> loads GPT-OSS twice on CUDA: once with <code>Mxfp4Config(dequantize=True)</code> (memory intensive) and once in the default quantized path (memory efficient). <strong>Figure 3</strong> shows the amount of used VRAM after each load so you can visualize the savings.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/quantization.png"><img alt="memory used with quantized vs dequantized models" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/quantization.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 3: Memory requirements for the quantized and dequantized models</td>
</tr>
</tbody> </table>
</div>
<h3> <a href="#kernels-for-mxfp4"> </a> <span> Kernels for MXFP4 </span>
</h3>
<p>Efficient <code>MXFP4</code> requires kernels that understand 32-element blocks and their scales during GEMMs and fused ops. This is where <strong>Kernels from the Hub</strong> comes in again. <code>transformers</code> automatically pulls in the <code>MXFP4</code>-aware
Triton kernels from the community repository when you load a model that needs them. The repository will appear in your local cache and will be used during the forward pass. For the <code>MXFP4</code> kernels one does not need to use the <code>use_kernels=True</code> parameter like before, it is set to default in <code>transformers</code>.</p>
<p>Quick sanity check with the Hugging Face cache CLI, after running <code>gpt-oss-20b</code> on a GPU compatible with the triton MXFP4 kernels:</p>
<pre><code>hf cache scan
</code></pre>
<p>Sample output:</p>
<pre><code>REPO ID REPO TYPE SIZE ON DISK
-------------------------------- --------- ------------
kernels-community/triton_kernels model 536.2K
openai/gpt-oss-20b model 13.8G
</code></pre>
<p>This indicates the MXFP4 kernels were fetched and are available for execution.</p>
<p>Let's run some benchmarks and see how well the MXFP4 kernels perform. In <strong>Figure 4</strong>, we see that the <code>MXFP4</code> kernels are even better than the custom MoE and RMSNorm kernels for larger batches.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/benchmark-mxfp4.png"><img alt="benchmark mxfp4 kernels" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/benchmark-mxfp4.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 4: MXFP4 kernel benchmark</td>
</tr>
</tbody> </table>
</div>
<blockquote>
<p>You can explore and play with the benchmarking script <a href="https://huggingface.co/datasets/ariG23498/faster-transformers-scripts/blob/main/benchmark-mxfp4-kernels.py">here</a></p>
</blockquote>
<h2> <a href="#tensor-parallelism"> </a> <span> Tensor Parallelism </span>
</h2>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/tgi/TP.png"><img alt="explaining tensor parallelism" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/tgi/TP.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 5: Explanation of tensor parallelism.</td>
</tr>
</tbody> </table>
</div>
<p>Tensor Parallelism (TP) splits <strong>tensors inside a layer</strong> across multiple GPUs (as shown in <strong>Figure 5</strong>). Each GPU multiplies its shard in parallel, and then partial results are collected using all-gather or all-reduce operations.
This reduces per-GPU memory and keeps all GPUs working on the <strong>same layer</strong>, which improves throughput as sequence length or batch size grow. TP is communication-intensive and generally works best on a <strong>single machine with fast intra-node links</strong>.</p>
<h3> <a href="#what-this-enables-in-transformers"> </a> <span> What this enables in <code>transformers</code> </span>
</h3>
<p><code>transformers</code> implements TP directly in <code>from_pretrained</code>. You can start with the predefined plan:</p>
<pre><code><span># run with: torchrun --nproc-per-node 4 tp_gpt_oss.py</span>
<span>import</span> torch
<span>from</span> transformers <span>import</span> PreTrainedTokenizerFast, GptOssForCausalLM model_id = <span>"openai/gpt-oss-120b"</span>
tokenizer = PreTrainedTokenizerFast.from_pretrained(model_id)
model = GptOssForCausalLM.from_pretrained( model_id, tp_plan=<span>"auto"</span>, <span># built in TP support</span> dtype=<span>"auto"</span>,
).<span>eval</span>() messages = [ {<span>"role"</span>: <span>"system"</span>, <span>"content"</span>: <span>"Be concise."</span>}, {<span>"role"</span>: <span>"user"</span>, <span>"content"</span>: <span>"Explain KV caching briefly."</span>},
]
inputs = tokenizer.apply_chat_template( messages, add_generation_prompt=<span>True</span>, return_tensors=<span>"pt"</span>, return_dict=<span>True</span>, reasoning_effort=<span>"low"</span>,
).to(model.device) <span>with</span> torch.inference_mode(): generations = model.generate(**inputs, max_new_tokens=<span>128</span>) <span>print</span>(tokenizer.decode(generations[<span>0</span>][inputs[<span>"input_ids"</span>].shape[-<span>1</span>]:]))
</code></pre>
<p>If you don’t have the infrastructure to run the above, you can just spawn a process on our GPUs using <a href="https://huggingface.co/docs/huggingface_hub/en/guides/jobs">Hugging Face Jobs</a>!</p>
<pre><code>hf <span>jobs</span> run --detach --flavor l4x4 ghcr.io/astral-sh/uv:debian /bin/bash -c \ <span>"uv venv .venv --python 3.12 &amp;&amp; \</span>
<span> source .venv/bin/activate &amp;&amp; \</span>
<span> uv pip install --upgrade torch numpy transformers accelerate triton kernels &amp;&amp; \</span>
<span> wget https://huggingface.co/datasets/ariG23498/distributed/raw/main/tp_gpt_oss.py &amp;&amp; \</span>
<span> torchrun --nproc-per-node=4 tp_gpt_oss.py"</span>
</code></pre>
<blockquote>
<p><a href="https://huggingface.co/docs/huggingface_hub/guides/jobs"><code>hf jobs</code></a> is available for all Hugging Face PRO &amp; Enterprise users.</p>
</blockquote>
<p>Under the hood, <code>tp_plan="auto"</code> selects a predefined sharding recipe for each layer and wires the necessary <a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook?section=a0:_parallel_programming_crash_course">collectives</a>. You can inspect the active plan with <code>print(model._tp_plan)</code> if you want to verify what is being sharded.</p>
<h3> <a href="#when-to-reach-for-tp"> </a> <span> When to reach for TP </span>
</h3>
<p>Use TP when the model is too large for one GPU and you want <strong>parallel compute</strong>, not only memory placement. TP tends to scale throughput with more GPUs, especially for long sequences or larger batches.</p>
<blockquote>
<p>If you are curious about how TP differs from <code>device_map="auto"</code> (memory placement), this short <a href="https://stackoverflow.com/questions/78852192/choose-available-gpu-devices-with-device-map">Stack Overflow answer</a> explains the distinction and when to use each.</p>
</blockquote>
<p>To learn more about TP, here are two must-read resources:</p>
<ul>
<li><a href="https://huggingface.co/docs/transformers/en/perf_infer_gpu_multi"><code>transformers</code> guide</a>: Tensor parallelism, supported models, plans, and extension points.</li>
<li><a href="https://huggingface.co/spaces/nanotron/ultrascale-playbook?section=tensor_parallelism">Ultra-Scale Playbook</a>: background on TP and its relationship to other parallelism modes.</li>
</ul>
<h2> <a href="#expert-parallelism"> </a> <span> Expert Parallelism </span>
</h2>
<p>Expert Parallelism (EP) shards <strong>experts inside MoE layers</strong> across GPUs. Each token is routed to one or a few experts, so only those experts run their feed-forward pass. Since experts are independent MLPs, we can place different experts on different ranks and exchange only the hidden states for the routed tokens. This keeps the matrix multiplies intact on each rank and replaces tensor slicing with routing and collectives.</p>
<p>Run with multiple processes using <code>torchrun</code>. EP is enabled via the distributed configuration and works with GPT-OSS MoE layers out of the box in transformers.</p>
<pre><code><span># run with: torchrun --nproc-per-node 4 ep_gpt_oss.py</span>
<span>import</span> torch
<span>from</span> transformers <span>import</span> PreTrainedTokenizerFast, GptOssForCausalLM
<span>from</span> transformers.distributed <span>import</span> DistributedConfig model_id = <span>"openai/gpt-oss-120b"</span>
tokenizer = PreTrainedTokenizerFast.from_pretrained(model_id)
model = GptOssForCausalLM.from_pretrained( model_id, distributed_config=DistributedConfig(enable_expert_parallel=<span>True</span>), <span># enabling EP</span> dtype=<span>"auto"</span>,
).<span>eval</span>() messages = [ {<span>"role"</span>: <span>"system"</span>, <span>"content"</span>: <span>"Be concise."</span>}, {<span>"role"</span>: <span>"user"</span>, <span>"content"</span>: <span>"Explain KV caching briefly."</span>},
]
inputs = tokenizer.apply_chat_template( messages, add_generation_prompt=<span>True</span>, return_tensors=<span>"pt"</span>, return_dict=<span>True</span>, reasoning_effort=<span>"low"</span>,
).to(model.device) <span>with</span> torch.inference_mode(): generations = model.generate(**inputs, max_new_tokens=<span>128</span>) <span>print</span>(tokenizer.decode(generations[<span>0</span>][inputs[<span>"input_ids"</span>].shape[-<span>1</span>]:]))
</code></pre>
<p>Here is how you would run using <code>hf jobs</code></p>
<pre><code>hf <span>jobs</span> run --detach --flavor l4x4 ghcr.io/astral-sh/uv:debian /bin/bash -c \ <span>"uv venv .venv --python 3.12 &amp;&amp; \</span>
<span> source .venv/bin/activate &amp;&amp; \</span>
<span> uv pip install --upgrade torch numpy transformers accelerate triton kernels &amp;&amp; \</span>
<span> wget https://huggingface.co/datasets/ariG23498/distributed/raw/main/ep_gpt_oss.py &amp;&amp; \</span>
<span> torchrun --nproc-per-node=4 ep_gpt_oss.py"</span>
</code></pre>
<blockquote>
<p>When you enable Expert Parallelism, Tensor Parallelism is also activated. This means you enjoy the best of both worlds!</p>
</blockquote>
<h2> <a href="#dynamic-sliding-window-layer--cache"> </a> <span> Dynamic Sliding Window Layer &amp; Cache </span>
</h2>
<p>Many recent LLMs use <em>sliding window</em> attention, or a combination of sliding and global attention layers, as a means to save memory and reduce those expensive quadratic matmuls that grow with sequence length. However, the dynamic KV cache implementation in transformers used to continue to allocate space according to sequence length, without looking at the individual attention layers. You could always optimize memory using compilation (meaning, fixed shapes), but that's a separate scenario altogether.</p>
<p><code>transformers</code> now has a <a href="https://github.com/huggingface/transformers/blob/64ae6e6b1de2c6822a53be46aba9db68f75ec595/src/transformers/cache_utils.py#L165"><strong><code>DynamicSlidingWindowLayer</code></strong></a> and a <em>config‑aware</em> <a href="https://github.com/huggingface/transformers/blob/64ae6e6b1de2c6822a53be46aba9db68f75ec595/src/transformers/cache_utils.py#L959"><code>DynamicCache</code></a>. If the model config declares sliding‑window or hybrid attention (both sliding and global attention layers are used), the cache <strong>stops growing past the window</strong> for the sliding layers. If you don’t pass the config, behavior stays as before (full, ever‑growing KV as sequence length grows).</p>
<p>For models that only use sliding window layers, such as Mistral 7B, cache memory stops growing when the sequence reaches the window size (4096, in this case). This makes sense, because the sliding layers can't look past the previous 4K tokens anyway.</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/mistral-dynamic-cache-with-config.png"><img alt="mistral cache behaviour comparison" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/mistral-dynamic-cache-with-config.png"></a></p>
<p>OpenAI gpt-oss alternates between sliding and global attention layers, which results in total KV cache memory being <em>halved</em>, as we'll see, as sequence length increases.
This provides us with:</p>
<ul>
<li><strong>Much lower KV‑cache memory</strong> for models with sliding or hybrid attention (e.g. GPT‑OSS). Cache growth plateaus once the window is reached (e.g., 4K for Mistral; 128 for GPT‑OSS sliding layers), instead of scaling linearly with total generated tokens. (<a href="https://github.com/huggingface/transformers/pull/40039">GitHub</a>, <a href="https://huggingface.co/docs/transformers/en/model_doc/mistral">Transformers</a>)</li>
<li><strong>Speed/latency wins</strong> on long prompts/long generations: smaller KV tensors mean lighter attention reads/writes and less memory bandwidth pressure, especially after the window is hit. (This is the central motivation behind sliding‑window/hybrid LLMs.) (<a href="https://www.ai21.com/blog/rise-of-hybrid-llms/">AI21</a>, <a href="https://blog.vllm.ai/2025/08/05/gpt-oss.html">vLLM Blog</a>)</li>
</ul>
<h3> <a href="#how-to-use-it"> </a> <span> How to use it </span>
</h3>
<p>The optimized cache is set by default, that means <strong>you don't have to make any changes</strong> to your existing code. If you want to create the <code>DynamicCache</code> explicitly here is how you would do it:</p>
<pre><code><span>from</span> transformers <span>import</span> AutoModelForCausalLM, AutoTokenizer, DynamicCache model_id = <span>"openai/gpt-oss-20b"</span> tokenizer = AutoTokenizer.from_pretrained(model_id)
model = AutoModelForCausalLM.from_pretrained( model_id, dtype=<span>"auto"</span>, device_map=<span>"auto"</span>,
).<span>eval</span>() messages = [ {<span>"role"</span>: <span>"system"</span>, <span>"content"</span>: <span>"Always respond in riddles"</span>}, {<span>"role"</span>: <span>"user"</span>, <span>"content"</span>: <span>"What is the weather like in Madrid?"</span>},
] inputs = tokenizer.apply_chat_template( messages, add_generation_prompt=<span>True</span>, return_tensors=<span>"pt"</span>, return_dict=<span>True</span>, reasoning_effort=<span>"low"</span>,
).to(model.device) cache = DynamicCache(config=model.config) <span># create the cache with the model's config</span> generated = model.generate( **inputs, max_new_tokens=<span>500</span>, past_key_values=cache
)
<span>print</span>(tokenizer.decode(generated[<span>0</span>][inputs[<span>"input_ids"</span>].shape[-<span>1</span>]:]))
</code></pre>
<p><strong>Figure 6</strong> showcases how much of a difference it makes for us to use the Dynamic KV Cache with sliding window attention.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/dynamic-cache.png"><img alt="sliding window cache" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/dynamic-cache.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 6: The memory analysis of dynamic cache with sliding window attention</td>
</tr>
</tbody> </table>
</div>
<h2> <a href="#continuous-batching--paged-attention"> </a> <span> Continuous Batching &amp; Paged Attention </span>
</h2>
<p>A typical autoregressive generation process looks like <strong>Figure 7</strong>. You input the prefill tokens, and the model predicts each new token one after the other until it predicts the EOS (End of Sequence) token.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/prefill-tokens.png"><img alt="prefilling" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/prefill-tokens.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 7: Autoregressive token generation</td>
</tr>
</tbody> </table>
</div>
<p>Let’s see what the generation process looks like when we pass a <strong>batch</strong> of inputs. In <strong>Figure 8</strong> you notice that some generations finish off earlier than the others. This mismatch of length underutilizes the GPUs.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/static-batching.png"><img alt="static batching" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/static-batching.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 8: Static batching of sequences</td>
</tr>
</tbody> </table>
</div>
<p>This type of batching sequences is called <em>static batching</em>. While this is simple and easy to understand, it inherently comes with inefficiencies. Only after each sentence is completely generated can we move on to the next batch.</p>
<p>To bypass this issue, we use <strong>dynamic batching</strong> (also known as <em>continuous batching</em>). Instead of waiting for all the generation to finish, we schedule incoming requests to the completed generations. That way, as soon as a generation in a batch is complete, we prefill the batch with the next request. The process looks like <strong>Figure 9</strong>.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/dynamic-batching.png"><img alt="continuous batching" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/dynamic-batching.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 9: Continuous Batching of sequences</td>
</tr>
</tbody> </table>
</div>
<p>Transformers supports continuous batching with the <code>generate_batch</code> API. This is not meant for production-grade model serving –frameworks like vLLM and SGLang are great at that–, but can be very helpful for evaluation and experimentation. Here is an example <a href="https://github.com/huggingface/transformers/blob/0f1b128d3359a26bd18be99c26d7f04fb3cba914/examples/pytorch/continuous_batching_simple.py">script</a> that runs CB end to end on <code>Qwen/Qwen3-4B-Instruct-2507</code>.</p>
<p>We have also performed a benchmark between Continuous Batching and Static Batching with 100 samples. In Figure 9, we note that CB is quite faster than SB.</p>
<div> <table> <thead><tr>
<th><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/cb-sb.png"><img alt="" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/faster-transformers/cb-sb.png"></a></th>
</tr> </thead><tbody><tr>
<td>Figure 9: Continuous vs Static Batching Tokens/Second</td>
</tr>
</tbody> </table>
</div>
<blockquote>
<p>You can play around with the benchmark here: <a href="https://huggingface.co/datasets/ariG23498/faster-transformers-scripts/blob/main/sb-bench.py">SB</a>, <a href="https://huggingface.co/datasets/ariG23498/faster-transformers-scripts/blob/main/cb-bench.py">CB</a></p>
</blockquote>
<h2> <a href="#load-larger-models-faster"> </a> <span> Load larger models faster </span>
</h2>
<p>When you load a large model into your GPU, PyTorch needs to <strong>reserve GPU memory for each layer’s weights</strong>. Each of these requests (per layer) takes time, and for multi-billion-parameter models it can mean <strong>thousands of tiny memory allocations</strong>, adding up to a long wait before the model is ready. Instead of asking the GPU for new memory every single time, it can <strong>hold on to a big chunk once</strong> and then hand out slices from it quickly.</p>
<p>PyTorch allocators can do exactly this. The catch is that the allocator only gets fast <em>after</em> you’ve given it some memory to work with. If you don’t “stock the pantry” first, you still end up doing many slow trips to the market. This PR ( <a href="https://github.com/huggingface/transformers/pull/36380">#36380</a>) taught <code>transformers</code> to <strong>pre-stock the pantry</strong> before it starts copying model weights.</p>
<p>It:</p>
<ul>
<li>Looks at the <code>device_map</code> (where each layer will live).</li>
<li><strong>Pre-allocates a big enough block on each GPU</strong>.</li>
<li>Then, as layers are copied in, they just slot neatly into this pre-reserved space.</li>
</ul>
<p>You have to make no changes to your existing code, as this is default behaviour in <code>transformers</code>. If you use <strong><code>device_map="auto"</code></strong> or provide your own device map, your model will now load faster automatically. If you’re running with <strong>Tensor Parallel (<code>tp_plan="auto"</code>) and <code>torchrun</code></strong> you also benefit from companion changes that make multi-GPU loading smarter.</p>
<h2> <a href="#conclusion"> </a> <span> Conclusion </span>
</h2>
<p><code>transformers</code> moves quickly and it is community-first. The library evolves at the pace of the field because contributors shape it in the open. Pieces added for new models become part of the toolkit and are reused in future integrations.</p>
<p>This velocity enables day-zero integrations like the GPT-OSS series. As the stack becomes increasingly <a href="https://x.com/LysandreJik/status/1933201171130593530">PyTorch-first</a>, it trims bloat and doubles down on the PyTorch paths that matter in practice. The result is a cleaner core that unlocks new capabilities through community kernels, quantization, and parallelism plans, while also
<a href="https://huggingface.co/blog/transformers-model-definition">standardizing model definitions</a> so that architectures supported in transformers are a reference and extend across the wider ecosystem.</p>
<p>This post is a one-time snapshot of a process we repeatedly iterate on towards the same direction: serve the needs of the community. To be up to date with the latest additions to transformers, check the <a href="https://huggingface.co/docs/transformers/index">docs</a> and <a href="https://github.com/huggingface/transformers/releases">release notes</a>. And please, keep sharing your feedback and releasing your models in transformers for the community to enjoy </p>
<h2> <a href="#read-more"> </a> <span> Read More </span>
</h2>
<p>If you want to go further into particular topics, here is a list of links that one should visit:</p>
<ol>
<li><a href="https://github.com/huggingface/gpt-oss-recipes">Hugging Face GPT-OSS Recipes Repository</a></li>
<li><a href="https://huggingface.co/blog/welcome-openai-gpt-oss">Welcome GPT OSS: OpenAI's New Open-Source Model Family</a></li>
<li><a href="https://cookbook.openai.com/topic/gpt-oss">OpenAI Cookbook: GPT-OSS Topic</a></li>
<li><a href="https://huggingface.co/docs/transformers/en/perf_infer_gpu_multi">Transformers Documentation: Distributed Inference on Multiple GPUs</a></li>
<li><a href="https://x.com/carrigmat/status/1952779877569978797">Matthew Carrigan's X Thread on GPT OSS Innovations</a></li>
<li><a href="https://www.youtube.com/watch?v=bbkcEiUjehk">YouTube Video: OpenAI GPT OSS Announcement</a></li>
<li><a href="https://github.com/huggingface/transformers/pull/36380">Transformers PR #36380: Faster Model Loading on Accelerators</a></li>
<li><a href="https://github.com/huggingface/transformers/pull/36335">Transformers PR #36335: Update from_pretrained for Tensor Parallelism</a></li>
<li><a href="https://github.com/huggingface/transformers/pull/40039">Transformers PR #40039: New Dynamic Sliding Window Layer and Cache</a></li>
<li><a href="https://hanlab.mit.edu/blog/streamingllm">HAN Lab Blog: How Attention Sinks Keep Language Models Stable</a></li>
</ol>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollStep(-1)">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollStep(1)">▼</button>
  </div>
  <script>
    function scrollStep(direction) {
      var step = Math.max(220, Math.round(window.innerHeight * 0.72));
      window.scrollBy({ top: direction * step, behavior: 'smooth' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up') scrollStep(-1);
      if (data.direction === 'down') scrollStep(1);
      if (data.direction === 'top') window.scrollTo({ top: 0, behavior: 'smooth' });
      if (data.direction === 'bottom') window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
    });
  </script>
</body>
</html>