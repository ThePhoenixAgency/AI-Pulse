<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GitHub - maxritter/claude-pilot: Claude Code is powerful. Pilot makes it reliable. Start a task, grab a coffee, come back to production-grade code. Tests enforced. Context preserved. Quality automated.</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>GitHub - maxritter/claude-pilot: Claude Code is powerful. Pilot makes it reliable. Start a task, grab a coffee, come back to production-grade code. Tests enforced. Context preserved. Quality automated.</h1>
  <div class="metadata">
    Source: Hacker News Show | Date: 2/17/2026 4:55:29 AM | <a href="https://github.com/maxritter/claude-pilot" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div>
<a target="_blank" href="/maxritter/claude-pilot/blob/main/docs/img/logo.png"><img src="/maxritter/claude-pilot/raw/main/docs/img/logo.png" alt="Claude Pilot"></a>
<div><h3>Claude Code is powerful. Pilot makes it reliable.</h3><a href="#claude-code-is-powerful-pilot-makes-it-reliable"></a></div>
<p>Start a task, grab a coffee, come back to production-grade code.<br>
<strong>Tests enforced. Context preserved. Quality automated.</strong></p>
<p><a href="https://github.com/maxritter/claude-pilot/stargazers"><img src="https://camo.githubusercontent.com/4c9f132a1a2a19d0b3de665a6a504afd28c460e65ba1f35d3950b3b0f16258f7/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f73746172732f6d61787269747465722f636c617564652d70696c6f743f7374796c653d666c617426636f6c6f723d463539453042" alt="Stars"></a>
<a href="https://star-history.com/#maxritter/claude-pilot&amp;Date"><img src="https://camo.githubusercontent.com/7ed125ad26d4190622448cb79d82a94eba916ffd27bfe4c2ceec2047a386e72a/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f537461725f486973746f72792d63686172742d384235434636" alt="Star History"></a>
<a href="https://github.com/maxritter/claude-pilot/releases"><img src="https://camo.githubusercontent.com/191a1bff65db4c033ffd204eaeac0a8fed1874a4906adc73db6fbd41a854da55/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f646f776e6c6f6164732f6d61787269747465722f636c617564652d70696c6f742f746f74616c3f636f6c6f723d334238324636" alt="Downloads"></a>
<a href="https://github.com/maxritter/claude-pilot/pulls"><img src="https://camo.githubusercontent.com/78c5cac0771d65b3d5094556296f7277ec23bdd74402e1790125ab9548f6a9b9/68747470733a2f2f696d672e736869656c64732e696f2f62616467652f5052732d77656c636f6d652d3130423938312e737667" alt="PRs Welcome"></a></p>
<p> <a href="https://github.com/maxritter/claude-pilot">Star this repo</a> · <a href="https://claude-pilot.com">Website</a> · <a href="https://www.linkedin.com/in/rittermax/">Follow for updates</a> · <a href="https://pilot.openchangelog.com/">Changelog</a> · <a href="/maxritter/claude-pilot/blob/main/LICENSE">License</a></p>
<br>
<div><pre>curl -fsSL https://raw.githubusercontent.com/maxritter/claude-pilot/main/install.sh <span>|</span> bash</pre></div>
<p><strong>Works on macOS, Linux, and Windows (WSL2).</strong></p>
<br>
<a target="_blank" href="/maxritter/claude-pilot/blob/main/docs/img/demo.gif"><img src="/maxritter/claude-pilot/raw/main/docs/img/demo.gif" alt="Claude Pilot Demo"></a>
</div>
<hr>
<div><h2>Why I Built This</h2><a href="#why-i-built-this"></a></div>
<p>I'm a senior IT freelancer from Germany. My clients hire me to ship production-quality code — tested, typed, formatted, and reviewed. When something goes into production under my name, quality isn't optional.</p>
<p>Claude Code writes code fast. But without structure, it skips tests, loses context, and produces inconsistent results — especially on complex, established codebases where there are real conventions to follow and real regressions to catch. I tried other frameworks — they burned tokens on bloated prompts without adding real value. Some added process without enforcement. Others were prompt templates that Claude ignored when context got tight. None made Claude reliably produce production-grade code.</p>
<p>So I built Pilot. Instead of adding process on top, it bakes quality into every interaction. Linting, formatting, and type checking run as enforced hooks on every edit. TDD is mandatory, not suggested. Context is monitored and preserved across sessions. Every piece of work goes through verification before it's marked done.</p>
<hr>
<div><h2>Before &amp; After</h2><a href="#before--after"></a></div>
<table>
<thead>
<tr>
<th>Without Pilot</th>
<th>With Pilot</th>
</tr>
</thead>
<tbody>
<tr>
<td>Writes code, skips tests</td>
<td>TDD enforced — RED, GREEN, REFACTOR on every feature</td>
</tr>
<tr>
<td>No quality checks</td>
<td>Hooks auto-lint, format, type-check on every file edit</td>
</tr>
<tr>
<td>Context degrades mid-task</td>
<td>Hooks preserve and restore state across compaction cycles</td>
</tr>
<tr>
<td>Every session starts fresh</td>
<td>Persistent memory across sessions via Pilot Console</td>
</tr>
<tr>
<td>Hope it works</td>
<td>Verifier sub-agents perform code review before marking complete</td>
</tr>
<tr>
<td>No codebase knowledge</td>
<td>Production-tested rules loaded into every session</td>
</tr>
<tr>
<td>Generic suggestions</td>
<td>Coding standards activated conditionally by file type</td>
</tr>
<tr>
<td>Changes mixed into branch</td>
<td>Isolated worktrees — review and squash merge when verified</td>
</tr>
<tr>
<td>Manual tool setup</td>
<td>MCP servers + language servers pre-configured and ready</td>
</tr>
<tr>
<td>Requires constant oversight</td>
<td>Start a task, grab a coffee, come back to verified results</td>
</tr>
</tbody>
</table>
<hr>
<div><h2>Why This Approach Works</h2><a href="#why-this-approach-works"></a></div>
<p>There are other AI coding frameworks out there. I tried them. They add complexity — dozens of agents, elaborate scaffolding, thousands of lines of instruction files — but the output doesn't improve proportionally. More machinery burns more tokens, increases latency, and creates more failure modes. Complexity is not a feature.</p>
<p><strong>Pilot optimizes for output quality, not system complexity.</strong> The rules are minimal and focused. There's no big learning curve, no project scaffolding to set up, no state files to manage. You install it in any existing project — no matter how complex — run </p><pre><code>pilot</code></pre>, then <pre><code>/sync</code></pre> to learn your codebase, and the quality guardrails are just there — hooks, TDD, type checking, formatting — enforced automatically on every edit, in every session.<p></p>
<p>This isn't a vibe coding tool. It's built for developers who ship to production and need code that actually works. Every rule in the system comes from daily professional use: real bugs caught, real regressions prevented, real sessions where the AI cut corners and the hooks stopped it. The rules are continuously refined based on what measurably improves output.</p>
<p><strong>The result: you can actually walk away.</strong> Start a </p><pre><code>/spec</code></pre> task, approve the plan, then go grab a coffee. When you come back, the work is done — tested, verified, formatted, and ready to ship. Hooks preserve state across compaction cycles, persistent memory carries context between sessions, quality hooks catch every mistake along the way, and verifier agents review the code before marking it complete. No babysitting required.<p></p>
<p>The system stays fast because it stays simple. Quick mode is direct execution with zero overhead — no sub-agents, no plan files, no directory scaffolding. You describe the task and it gets done. </p><pre><code>/spec</code></pre> adds structure only when you need it: plan verification, TDD enforcement, independent code review, automated quality checks. Both modes share the same quality hooks. Both modes benefit from persistent memory and hooks that preserve state across compaction.<p></p>
<hr>
<div><h2>Getting Started</h2><a href="#getting-started"></a></div>
<div><h3>Prerequisites</h3><a href="#prerequisites"></a></div>
<p><strong>Claude Subscription:</strong> Solo developers should choose <a href="https://claude.com/pricing">Max 5x</a> for moderate usage or <a href="https://claude.com/pricing">Max 20x</a> for heavy usage. Teams and companies should use <a href="https://claude.com/pricing">Team Premium</a> which provides 6.25x usage per member plus SSO, admin tools, and billing management. Using the API instead may lead to much higher costs.</p>
<div><h3>Installation</h3><a href="#installation"></a></div>
<p><strong>Works with any existing project.</strong> Pilot doesn't scaffold or restructure your code — it installs alongside your project and adapts to your conventions. </p><pre><code>cd</code></pre> into your project folder, then run:<p></p>
<div><pre>curl -fsSL https://raw.githubusercontent.com/maxritter/claude-pilot/main/install.sh <span>|</span> bash</pre></div>
<p><strong>Choose your environment:</strong></p>
<ul>
<li><strong>Local Installation</strong> — Install directly on your system using Homebrew. Works on macOS, Linux, and Windows (WSL2).</li>
<li><strong>Dev Container</strong> — Pre-configured, isolated environment with all tools ready. No system conflicts and works on any OS.</li>
</ul>
<p>After installation, run </p><pre><code>pilot</code></pre> or <pre><code>ccp</code></pre> in your project folder to start Claude Pilot.<p></p> <b>What the installer does</b>
<p>8-step installer with progress tracking, rollback on failure, and idempotent re-runs:</p>
<ol>
<li><strong>Prerequisites</strong> — Checks Homebrew, Node.js, Python 3.12+, uv, git</li>
<li><strong>Dependencies</strong> — Installs Vexor, playwright-cli, mcp-cli, Claude Code</li>
<li><strong>Shell integration</strong> — Auto-configures bash, fish, and zsh with <pre><code>pilot</code></pre> alias</li>
<li><strong>Config &amp; Claude files</strong> — Sets up <pre><code>.claude/</code></pre> plugin, rules, commands, hooks, MCP servers</li> <li><strong>Dev Container</strong> — Auto-setup with all tools pre-configured</li>
<li><strong>Automated updater</strong> — Checks for updates on launch with release notes and one-key upgrade</li>
<li><strong>Cross-platform</strong> — macOS, Linux, Windows (WSL2)</li>
</ol> <div><h3>Installing a Specific Version</h3><a href="#installing-a-specific-version"></a></div>
<p>If the current version has issues, you can install a specific stable version (see <a href="https://github.com/maxritter/claude-pilot/releases">releases</a>):</p>
<div><pre><span>export</span> VERSION=6.7.5
curl -fsSL https://raw.githubusercontent.com/maxritter/claude-pilot/main/install.sh <span>|</span> bash</pre></div>
<hr>
<div><h2>How It Works</h2><a href="#how-it-works"></a></div>
<div><h3>/sync — Sync Rules &amp; Standards</h3><a href="#sync--sync-rules--standards"></a></div>
<p>Run </p><pre><code>/sync</code></pre> to learn your existing codebase and sync rules with it. Explores your project structure, builds a semantic search index, discovers your conventions and undocumented patterns, updates project documentation, and creates new custom skills. This is how Pilot adapts to your project — not the other way around. Run it once initially, then anytime again:<p></p>
<div><pre>pilot
<span>&gt;</span> /sync</pre></div> <b>What <pre><code>/sync</code></pre> does in detail</b>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>Load reference guidelines, output locations, error handling</td>
</tr>
<tr>
<td>1</td>
<td>Read existing rules and standards from <pre><code>.claude/</code></pre></td>
</tr>
<tr>
<td>2</td>
<td>Build Vexor semantic search index (first run may take 5-15 min)</td>
</tr>
<tr>
<td>3</td>
<td>Explore codebase with Vexor/Grep to find patterns</td>
</tr>
<tr>
<td>4</td>
<td>Compare discovered vs documented patterns</td>
</tr>
<tr>
<td>5</td>
<td>Sync/update <pre><code>project.md</code></pre> with tech stack and commands</td>
</tr>
<tr>
<td>6</td>
<td>Sync MCP server documentation</td>
</tr>
<tr>
<td>7</td>
<td>Update existing custom skills that have changed</td>
</tr>
<tr>
<td>8</td>
<td>Discover and document new undocumented patterns as rules</td>
</tr>
<tr>
<td>9</td>
<td>Create new skills via <pre><code>/learn</code></pre> command</td>
</tr>
<tr>
<td>10</td>
<td>Report summary of all changes</td>
</tr>
</tbody>
</table> <div><h3>/spec — Spec-Driven Development</h3><a href="#spec--spec-driven-development"></a></div> <div><pre>pilot
<span>&gt;</span> /spec <span><span>"</span>Add user authentication with OAuth and JWT tokens<span>"</span></span></pre></div>
<div><pre><code>Discuss → Plan → Approve → Implement → Verify → Done │ ↑ ↓ │ └─ Loop─┘ ▼ Task 1 (TDD) ▼ Task 2 (TDD) ▼ Task 3 (TDD)
</code></pre></div> <b>Plan Phase</b>
<ol>
<li>Explores entire codebase with semantic search (Vexor)</li>
<li>Asks clarifying questions before committing to a design</li>
<li>Writes detailed spec to <pre><code>docs/plans/</code></pre> as reviewed markdown with scope, tasks, and definition of done</li>
<li><strong>Plan-verifier sub-agent</strong> independently validates completeness and alignment with your request</li>
<li>Auto-fixes any issues found by the verifier</li>
<li>Waits for your approval — you can edit the plan first</li>
</ol> <b>Implement Phase</b>
<ol>
<li>Creates an isolated git worktree on a dedicated branch — main branch stays clean</li>
<li>Implements each task sequentially with strict TDD (RED → GREEN → REFACTOR)</li>
<li>Quality hooks auto-lint, format, and type-check every file edit</li>
<li>Runs full test suite after each task to catch regressions early</li>
<li>All tasks execute in the main context with full access to hooks and rules</li>
</ol> <b>Verify Phase</b>
<ol>
<li>Runs full test suite — unit, integration, and E2E</li>
<li>Type checking and linting across the entire project</li>
<li>Executes actual program to verify real-world behavior (not just tests)</li> <li>Auto-fixes all findings, then re-verifies until clean</li>
<li>Loops back to implementation if structural issues remain</li>
<li>On success, shows diff summary and offers to squash merge worktree back to main branch</li>
</ol> <div><h3>Smart Model Routing</h3><a href="#smart-model-routing"></a></div>
<p>Pilot uses the right model for each phase — Opus where reasoning quality matters most, Sonnet where speed and cost matter:</p>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Model</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Planning</strong></td>
<td>Opus</td>
<td>Exploring your codebase, designing architecture, and writing the spec requires deep reasoning. A good plan is the foundation of everything.</td>
</tr>
<tr>
<td><strong>Plan Verification</strong></td>
<td>Opus</td>
<td>Catching gaps, missing edge cases, and requirement mismatches before implementation saves expensive rework.</td>
</tr>
<tr>
<td><strong>Implementation</strong></td>
<td>Sonnet</td>
<td>With a solid plan, writing code is straightforward. Sonnet is fast, cost-effective, and produces high-quality code when guided by a clear spec.</td>
</tr>
<tr>
<td><strong>Code Verification</strong></td>
<td>Opus</td>
<td>Independent code review against the plan requires the same reasoning depth as planning — catching subtle bugs, logic errors, and spec deviations.</td>
</tr>
</tbody>
</table>
<p><strong>The insight:</strong> Implementation is the easy part when the plan is good and verification is thorough. Pilot invests reasoning power where it has the highest impact — planning and verification — and uses fast execution where a clear spec makes quality predictable.</p>
<div><h3>Quick Mode</h3><a href="#quick-mode"></a></div>
<p>Just chat. No plan file, no approval gate. All quality hooks and TDD enforcement still apply.</p>
<div><pre>pilot
<span>&gt;</span> Fix the null pointer bug <span>in</span> user.py</pre></div>
<div><h3>/learn — Online Learning</h3><a href="#learn--online-learning"></a></div>
<p>Capture non-obvious discoveries as reusable skills. Triggered automatically after 10+ minute investigations, or manually:</p>
<div><pre>pilot
<span>&gt;</span> /learn <span><span>"</span>Extract the debugging workflow we used for the race condition<span>"</span></span></pre></div>
<div><h3>/vault — Team Vault</h3><a href="#vault--team-vault"></a></div>
<p>Share rules, commands, and skills across your team via a private Git repository:</p>
<div><pre>pilot
<span>&gt;</span> /vault</pre></div>
<ul>
<li><strong>Private</strong> — Use any Git repo (GitHub, GitLab, Bitbucket — public or private)</li>
<li><strong>Pull</strong> — Install shared assets from your team's vault</li>
<li><strong>Push</strong> — Share your custom rules and skills with teammates</li>
<li><strong>Version</strong> — Assets are versioned automatically (v1, v2, v3...)</li>
</ul>
<div><h3>Pilot CLI</h3><a href="#pilot-cli"></a></div>
<p>The </p><pre><code>pilot</code></pre> binary (<pre><code>~/.pilot/bin/pilot</code></pre>) manages sessions, worktrees, licensing, and context. Run <pre><code>pilot</code></pre> or <pre><code>ccp</code></pre> with no arguments to start Claude with Pilot enhancements.<p></p> <b>Session &amp; Context</b>
<table>
<thead>
<tr>
<th>Command</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>pilot</code></pre></td>
<td>Start Claude with Pilot enhancements, auto-update, and license check</td>
</tr>
<tr>
<td><pre><code>pilot run [args...]</code></pre></td>
<td>Same as above, with optional flags (e.g., <pre><code>--skip-update-check</code></pre>)</td>
</tr>
<tr>
<td><pre><code>pilot check-context --json</code></pre></td>
<td>Get current context usage percentage</td>
</tr>
<tr>
<td><pre><code>pilot register-plan &lt;path&gt; &lt;status&gt;</code></pre></td>
<td>Associate a plan file with the current session</td>
</tr>
<tr>
<td><pre><code>pilot sessions [--json]</code></pre></td>
<td>Show count of active Pilot sessions</td>
</tr>
</tbody>
</table> <b>Worktree Isolation</b>
<table>
<thead>
<tr>
<th>Command</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>pilot worktree create --json &lt;slug&gt;</code></pre></td>
<td>Create isolated git worktree for safe experimentation</td>
</tr>
<tr>
<td><pre><code>pilot worktree detect --json &lt;slug&gt;</code></pre></td>
<td>Check if a worktree already exists</td>
</tr>
<tr>
<td><pre><code>pilot worktree diff --json &lt;slug&gt;</code></pre></td>
<td>List changed files in the worktree</td>
</tr>
<tr>
<td><pre><code>pilot worktree sync --json &lt;slug&gt;</code></pre></td>
<td>Squash merge worktree changes back to base branch</td>
</tr>
<tr>
<td><pre><code>pilot worktree cleanup --json &lt;slug&gt;</code></pre></td>
<td>Remove worktree and branch when done</td>
</tr>
<tr>
<td><pre><code>pilot worktree status --json</code></pre></td>
<td>Show active worktree info for current session</td>
</tr>
</tbody>
</table> <b>License &amp; Auth</b>
<table>
<thead>
<tr>
<th>Command</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>pilot activate &lt;key&gt;</code></pre></td>
<td>Activate a license key on this machine</td>
</tr>
<tr>
<td><pre><code>pilot deactivate</code></pre></td>
<td>Deactivate license on this machine</td>
</tr>
<tr>
<td><pre><code>pilot status [--json]</code></pre></td>
<td>Show current license status</td>
</tr>
<tr>
<td><pre><code>pilot verify [--json]</code></pre></td>
<td>Verify license (used by hooks)</td>
</tr>
<tr>
<td><pre><code>pilot trial --check [--json]</code></pre></td>
<td>Check trial eligibility</td>
</tr>
<tr>
<td><pre><code>pilot trial --start [--json]</code></pre></td>
<td>Start a trial</td>
</tr>
</tbody>
</table> <p>All commands support </p><pre><code>--json</code></pre> for structured output. Multiple Pilot sessions can run in parallel on the same project — each session tracks its own worktree and context state independently.<p></p>
<div><h3>Rules, Commands &amp; Skills</h3><a href="#rules-commands--skills"></a></div>
<p>Create your own in your project's </p><pre><code>.claude/</code></pre> folder:<p></p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Loaded</th>
<th>Best for</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Rules</strong></td>
<td>Every session, or conditionally by file type</td>
<td>Guidelines Claude should always follow</td>
</tr>
<tr>
<td><strong>Commands</strong></td>
<td>On demand via <pre><code>/command</code></pre></td>
<td>Specific workflows or multi-step tasks</td>
</tr>
<tr>
<td><strong>Skills</strong></td>
<td>On demand, created via <pre><code>/learn</code></pre></td>
<td>Reusable knowledge from past sessions</td>
</tr>
</tbody>
</table>
<p>Claude Pilot automatically installs best-practice rules, commands, and coding standards. Standards rules use </p><pre><code>paths</code></pre> frontmatter to activate only when you're working with matching file types (e.g., Python standards load only when editing <pre><code>.py</code></pre> files). Custom skills are created by <pre><code>/learn</code></pre> when it detects non-obvious discoveries, workarounds, or reusable workflows — and can be shared across your team via <pre><code>/vault</code></pre>.<p></p>
<div><h3>Custom MCP Servers</h3><a href="#custom-mcp-servers"></a></div>
<p>Add your own MCP servers in two locations:</p>
<table>
<thead>
<tr>
<th>Config File</th>
<th>How It Works</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>.mcp.json</code></pre></td>
<td>Instructions load into context when triggered</td>
<td>Lightweight servers (few tools)</td>
</tr>
<tr>
<td><pre><code>mcp_servers.json</code></pre></td>
<td>Called via mcp-cli; instructions never enter context</td>
<td>Heavy servers (many tools)</td>
</tr>
</tbody>
</table>
<p>Run </p><pre><code>/sync</code></pre> after adding servers to generate documentation.<p></p>
<hr>
<div><h2>Under the Hood</h2><a href="#under-the-hood"></a></div>
<div><h3>The Hooks Pipeline</h3><a href="#the-hooks-pipeline"></a></div>
<p><strong>15 hooks</strong> fire automatically across 6 lifecycle events:</p>
<div><h4>SessionStart (on startup, clear, or compact)</h4><a href="#sessionstart-on-startup-clear-or-compact"></a></div>
<table>
<thead>
<tr>
<th>Hook</th>
<th>Type</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td>Memory loader</td>
<td>Blocking</td>
<td>Loads persistent context from Pilot Console memory</td>
</tr>
<tr>
<td><pre><code>post_compact_restore.py</code></pre></td>
<td>Blocking</td>
<td>After auto-compaction: re-injects active plan, task state, and context</td>
</tr>
<tr>
<td>Session tracker</td>
<td>Async</td>
<td>Initializes user message tracking for the session</td>
</tr>
</tbody>
</table>
<div><h4>PreToolUse (before search, web, or task tools)</h4><a href="#pretooluse-before-search-web-or-task-tools"></a></div>
<table>
<thead>
<tr>
<th>Hook</th>
<th>Type</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>tool_redirect.py</code></pre></td>
<td>Blocking</td>
<td>Blocks WebSearch/WebFetch (MCP alternatives exist), EnterPlanMode/ExitPlanMode (/spec conflict). Hints vexor for semantic Grep patterns.</td>
</tr>
</tbody>
</table>
<div><h4>PostToolUse (after every Write / Edit / MultiEdit)</h4><a href="#posttooluse-after-every-write--edit--multiedit"></a></div>
<p>After <strong>every single file edit</strong>, these hooks fire:</p>
<table>
<thead>
<tr>
<th>Hook</th>
<th>Type</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>file_checker.py</code></pre></td>
<td>Blocking</td>
<td>Dispatches to language-specific checkers: Python (ruff + basedpyright), TypeScript (Prettier + ESLint + tsc), Go (gofmt + golangci-lint). Auto-fixes formatting.</td>
</tr>
<tr>
<td><pre><code>tdd_enforcer.py</code></pre></td>
<td>Non-blocking</td>
<td>Checks if implementation files were modified without failing tests first. Shows reminder to write tests. Excludes test files, docs, config, TSX, and infrastructure.</td>
</tr>
<tr>
<td><pre><code>context_monitor.py</code></pre></td>
<td>Non-blocking</td>
<td>Monitors context usage. Warns at ~80% (informational) and ~90%+ (caution). Prompts <pre><code>/learn</code></pre> at key thresholds.</td>
</tr>
<tr>
<td>Memory observer</td>
<td>Async</td>
<td>Captures development observations to persistent memory.</td>
</tr>
</tbody>
</table>
<div><h4>PreCompact (before auto-compaction)</h4><a href="#precompact-before-auto-compaction"></a></div>
<table>
<thead>
<tr>
<th>Hook</th>
<th>Type</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>pre_compact.py</code></pre></td>
<td>Blocking</td>
<td>Captures Pilot state (active plan, task list, key context) to persistent memory before compaction fires.</td>
</tr>
</tbody>
</table>
<div><h4>Stop (when Claude tries to finish)</h4><a href="#stop-when-claude-tries-to-finish"></a></div>
<table>
<thead>
<tr>
<th>Hook</th>
<th>Type</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>spec_stop_guard.py</code></pre></td>
<td>Blocking</td>
<td>If an active spec exists with PENDING or COMPLETE status, <strong>blocks stopping</strong>. Forces verification to complete before the session can end.</td>
</tr>
<tr>
<td>Session summarizer</td>
<td>Async</td>
<td>Saves session observations to persistent memory for future sessions.</td>
</tr>
</tbody>
</table>
<div><h4>SessionEnd (when the session closes)</h4><a href="#sessionend-when-the-session-closes"></a></div>
<table>
<thead>
<tr>
<th>Hook</th>
<th>Type</th>
<th>What it does</th>
</tr>
</thead>
<tbody>
<tr>
<td><pre><code>session_end.py</code></pre></td>
<td>Blocking</td>
<td>Stops the worker daemon when no other Pilot sessions are active. Sends OS notification on completion.</td>
</tr>
</tbody>
</table>
<div><h3>Context Preservation</h3><a href="#context-preservation"></a></div>
<p>Pilot preserves context automatically across compaction boundaries:</p>
<ul>
<li><pre><code>pre_compact.py</code></pre> captures Pilot state (active plan, tasks, key context) to persistent memory</li>
<li><pre><code>post_compact_restore.py</code></pre> re-injects Pilot context after compaction — agent continues seamlessly</li>
<li>Multiple Pilot sessions can run in parallel on the same project without interference</li>
<li>Status line shows live context usage, memory status, active plan, and license info</li>
</ul>
<p><strong>Effective context display:</strong> Claude Code reserves ~16.5% of the context window as a compaction buffer, triggering auto-compaction at ~83.5% raw usage. Pilot rescales this to an <strong>effective 0–100% range</strong> so the status bar fills naturally to 100% right before compaction fires. A </p><pre><code>▓</code></pre> buffer indicator at the end of the bar shows the reserved zone. The context monitor warns at ~80% effective (informational) and ~90%+ effective (caution) — no confusing raw percentages.<p></p>
<div><h3>Built-in Rules &amp; Standards</h3><a href="#built-in-rules--standards"></a></div>
<p>Production-tested best practices loaded into <strong>every session</strong>. These aren't suggestions — they're enforced standards. Coding standards activate conditionally by file type.</p> <b>Core Workflow (3 rules)</b>
<ul>
<li><pre><code>task-and-workflow.md</code></pre> — Task management, /spec orchestration, deviation handling</li>
<li><pre><code>testing.md</code></pre> — TDD workflow, test strategy, coverage requirements</li>
<li><pre><code>verification.md</code></pre> — Execution verification, completion requirements</li>
</ul> <b>Development Practices (3 rules)</b>
<ul>
<li><pre><code>development-practices.md</code></pre> — Project policies, debugging methodology, git rules</li>
<li><pre><code>context-continuation.md</code></pre> — Auto-compaction and context management protocol</li>
<li><pre><code>pilot-memory.md</code></pre> — Persistent memory workflow, online learning triggers</li>
</ul> <b>Tools (3 rules)</b>
<ul>
<li><pre><code>research-tools.md</code></pre> — Context7, grep-mcp, web search, GitHub CLI</li>
<li><pre><code>cli-tools.md</code></pre> — Pilot CLI, MCP-CLI, Vexor semantic search</li>
<li><pre><code>playwright-cli.md</code></pre> — Browser automation for E2E UI testing</li>
</ul> <b>Collaboration (1 rule)</b>
<ul>
<li><pre><code>team-vault.md</code></pre> — Team Vault asset sharing via sx</li>
</ul> <b>Coding Standards (5 standards, activated by file type)</b>
<table>
<thead>
<tr>
<th>Standard</th>
<th>Activates On</th>
<th>Coverage</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python</td>
<td><pre><code>*.py</code></pre></td>
<td>uv, pytest, ruff, basedpyright, type hints</td>
</tr>
<tr>
<td>TypeScript</td>
<td><pre><code>*.ts</code></pre>, <pre><code>*.tsx</code></pre>, <pre><code>*.js</code></pre>, <pre><code>*.jsx</code></pre></td>
<td>npm/pnpm, Jest, ESLint, Prettier, React patterns</td>
</tr>
<tr>
<td>Go</td>
<td><pre><code>*.go</code></pre></td>
<td>Modules, testing, formatting, error handling</td>
</tr>
<tr>
<td>Frontend</td>
<td><pre><code>*.tsx</code></pre>, <pre><code>*.jsx</code></pre>, <pre><code>*.html</code></pre>, <pre><code>*.vue</code></pre>, <pre><code>*.css</code></pre></td>
<td>Components, CSS, accessibility, responsive design</td>
</tr>
<tr>
<td>Backend</td>
<td><pre><code>**/models/**</code></pre>, <pre><code>**/routes/**</code></pre>, <pre><code>**/api/**</code></pre>, etc.</td>
<td>API design, data models, query optimization, migrations</td>
</tr>
</tbody>
</table> <div><h3>MCP Servers</h3><a href="#mcp-servers"></a></div>
<p>External context always available to every session:</p>
<table>
<thead>
<tr>
<th>Server</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>lib-docs</strong></td>
<td>Library documentation lookup — get API docs for any dependency</td>
</tr>
<tr>
<td><strong>mem-search</strong></td>
<td>Persistent memory search — recall context from past sessions</td>
</tr>
<tr>
<td><strong>web-search</strong></td>
<td>Web search via DuckDuckGo, Bing, and Exa</td>
</tr>
<tr>
<td><strong>grep-mcp</strong></td>
<td>GitHub code search — find real-world usage patterns across repos</td>
</tr>
<tr>
<td><strong>web-fetch</strong></td>
<td>Web page fetching — read documentation, APIs, references</td>
</tr>
</tbody>
</table>
<div><h3>Language Servers (LSP)</h3><a href="#language-servers-lsp"></a></div>
<p>Real-time diagnostics and go-to-definition, auto-installed and configured:</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Server</th>
<th>Capabilities</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Python</strong></td>
<td>basedpyright</td>
<td>Strict type checking, diagnostics, go-to-definition. Auto-restarts on crash (max 3).</td>
</tr>
<tr>
<td><strong>TypeScript</strong></td>
<td>vtsls</td>
<td>Full TypeScript support with Vue compatibility. Auto-restarts on crash (max 3).</td>
</tr>
<tr>
<td><strong>Go</strong></td>
<td>gopls</td>
<td>Official Go language server. Auto-restarts on crash (max 3).</td>
</tr>
</tbody>
</table>
<p>All configured via </p><pre><code>.lsp.json</code></pre> with stdio transport.<p></p>
<hr>
<div><h2>Claude Pilot Console</h2><a href="#claude-pilot-console"></a></div>
<p>Access the web-based Claude Pilot Console to visualize your development workflow:</p>
<p><a target="_blank" href="/maxritter/claude-pilot/blob/main/docs/img/console.png"><img src="/maxritter/claude-pilot/raw/main/docs/img/console.png" alt="Claude Pilot Console"></a></p>
<hr>
<div><h2>What Users Say</h2><a href="#what-users-say"></a></div> <blockquote> </blockquote>
<blockquote>
<p>"Other frameworks I tried added so much overhead that half my tokens went to the system itself. Pilot is lean — quick mode has zero scaffolding, and even /spec only adds structure where it matters. More of my context goes to actual work."</p>
</blockquote>
<blockquote>
<p>"The persistent memory changed everything. I can pick up a project after a week and Claude already knows my architecture decisions, the bugs we fixed, and why we chose certain patterns. No more re-explaining the same context every session."</p>
</blockquote>
<hr>
<div><h2>License</h2><a href="#license"></a></div>
<p>Claude Pilot is source-available under a commercial license. See the <a href="/maxritter/claude-pilot/blob/main/LICENSE">LICENSE</a> file for full terms.</p>
<table>
<thead>
<tr>
<th>Tier</th>
<th>Seats</th>
<th>Includes</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Solo</strong></td>
<td>1</td>
<td>All features, continuous updates, bug reports via <a href="https://github.com/maxritter/claude-pilot/issues">GitHub Issues</a></td>
</tr>
<tr>
<td><strong>Team</strong></td>
<td>Multi</td>
<td>Solo + multiple seats, priority email support, feature requests</td>
</tr>
</tbody>
</table>
<p>Details and licensing at <a href="https://claude-pilot.com">claude-pilot.com</a>.</p>
<hr>
<div><h2>FAQ</h2><a href="#faq"></a></div> <b>Does Pilot send my code or data to external services?</b>
<p><strong>No code, files, prompts, project data, or personal information ever leaves your machine through Pilot.</strong> All development tools — vector search (Vexor), persistent memory (Pilot Console), session state, and quality hooks — run entirely locally.</p>
<p>Pilot makes external calls <strong>only for licensing</strong>. Here is the complete list:</p>
<table>
<thead>
<tr>
<th>When</th>
<th>Where</th>
<th>What is sent</th>
</tr>
</thead>
<tbody>
<tr>
<td>License validation (once per 24h)</td>
<td><pre><code>api.polar.sh</code></pre></td>
<td>License key, organization ID</td>
</tr>
<tr>
<td>License activation (once)</td>
<td><pre><code>api.polar.sh</code></pre></td>
<td>License key, machine fingerprint, OS, architecture, Python version</td>
</tr>
<tr>
<td>Activation analytics (once)</td>
<td><pre><code>claude-pilot.com</code></pre></td>
<td>Tier, Pilot version, OS, architecture, Python version, machine fingerprint</td>
</tr>
<tr>
<td>Trial start (once)</td>
<td><pre><code>claude-pilot.com</code></pre></td>
<td>Hashed hardware fingerprint, OS, Pilot version, locale</td>
</tr>
<tr>
<td>Trial heartbeat (each session during trial)</td>
<td><pre><code>claude-pilot.com</code></pre></td>
<td>Hashed hardware fingerprint, OS, Pilot version</td>
</tr>
</tbody>
</table>
<p>That's it. No code, no filenames, no prompts, no project content, no personal data. The validation result is cached locally, and Pilot works fully offline for up to 7 days between checks. Beyond these licensing calls, the only external communication is between Claude Code and Anthropic's API — using your own subscription or API key.</p> <b>Is Pilot enterprise-compliant for data privacy?</b>
<p>Yes. Your source code, project files, and development context never leave your machine through Pilot. The only external calls Pilot makes are for license management — validation (daily to </p><pre><code>api.polar.sh</code></pre>), activation and analytics (one-time), and trial heartbeats. None of these transmit any code, project data, or personal information. Enterprises using Claude Code with their own API key or Anthropic Enterprise subscription can add Pilot without changing their data compliance posture.<p></p> <b>What are the licenses of Pilot's dependencies?</b>
<p>All external tools and dependencies that Pilot installs and uses are open source with permissive licenses (MIT, Apache 2.0, BSD). This includes ruff, basedpyright, Prettier, ESLint, gofmt, uv, Vexor, playwright-cli, and all MCP servers. No copyleft or restrictive-licensed dependencies are introduced into your environment.</p> <b>Do I need a separate Anthropic subscription?</b>
<p>Yes. Pilot enhances Claude Code — it doesn't replace it. You need an active Claude subscription — <a href="https://claude.com/pricing">Max 5x or 20x</a> for solo developers, or <a href="https://claude.com/pricing">Team Premium</a> for teams and companies. Using the Anthropic API directly is also possible but may lead to much higher costs. Pilot adds quality automation on top of whatever Claude Code access you already have.</p> <b>Does Pilot work with existing projects?</b>
<p>Yes — that's the primary use case. Pilot doesn't scaffold or restructure your code. You install it, run </p><pre><code>/sync</code></pre>, and it explores your codebase to discover your tech stack, conventions, and patterns. From there, every session has full context about your project. The more complex and established your codebase, the more value Pilot adds — quality hooks catch regressions, persistent memory preserves decisions across sessions, and <pre><code>/spec</code></pre> plans features against your real architecture.<p></p> <b>Does Pilot work with any programming language?</b>
<p>Pilot's quality hooks (auto-formatting, linting, type checking) currently support Python, TypeScript/JavaScript, and Go out of the box. TDD enforcement, spec-driven development, persistent memory, context preservation hooks, and all rules and standards work with any language that Claude Code supports. You can add custom hooks for additional languages.</p> <b>Can I use Pilot on multiple projects?</b>
<p>Yes. Pilot installs once and works across all your projects. Each project can have its own </p><pre><code>.claude/</code></pre> rules, custom skills, and MCP servers. Run <pre><code>/sync</code></pre> in each project to generate project-specific documentation and standards.<p></p> <b>Can I add my own rules, commands, and skills?</b>
<p>Yes. Create your own in your project's </p><pre><code>.claude/</code></pre> folder — rules, commands, and skills are all plain markdown files. Your project-level assets are loaded alongside Pilot's built-in defaults and take precedence when they overlap. <pre><code>/sync</code></pre> auto-discovers your codebase patterns and generates project-specific rules for you. <pre><code>/learn</code></pre> extracts reusable knowledge from sessions into custom skills. Hooks can be extended for additional languages. Use <pre><code>/vault</code></pre> to share your custom assets across your team.<p></p> <hr>
<div><h2>Changelog</h2><a href="#changelog"></a></div>
<p>See the full changelog at <a href="https://pilot.openchangelog.com/">pilot.openchangelog.com</a>.</p>
<hr>
<div><h2>Contributing</h2><a href="#contributing"></a></div>
<p><strong>Pull Requests</strong> — New features, improvements, and bug fixes are welcome. You can improve Pilot with Pilot — a self-improving loop where your contributions make the tool that makes contributions better.</p>
<p><strong>Bug Reports</strong> — Found a bug? <a href="https://github.com/maxritter/claude-pilot/issues">Open an issue</a> on GitHub.</p>
<hr>
<div>
<p><strong>Claude Code is powerful. Pilot makes it reliable.</strong></p>
</div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>