<!DOCTYPE html>
<html lang="nl">
<head>
<meta charset="UTF-8">
<title>Get your VLM running in 3 simple steps on Intel CPUs</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Get your VLM running in 3 simple steps on Intel CPUs</h1>
  <div class="metadata">
    Source: Hugging Face Blog | Date: 10/15/2025 2:00:00 AM | Lang: NL |
    <a href="https://huggingface.co/blog/openvino-vlm" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div> <p><a href="https://huggingface.co/blog"> Back to Articles</a></p> <div><div> <p><span><span><a href="https://huggingface.co/ezelanza"><img alt="Ezequiel Lanza's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/62ebdafd6b6738393a3aaae6/bb72Ujw3EjY2oIPQjhaHo.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/helenai"><img alt="Helena's avatar" src="https://huggingface.co/avatars/95042e9b280103dd5dbe35e7b1e17542.svg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/nikita-savelyev-intel"><img alt="Nikita's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/6527c22a69cdd3a867d9afb7/Zv71yepDrtBT031TTClJh.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/echarlaix"><img alt="Ella Charlaix's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1615915889033-6050eb5aeb94f56898c08e57.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/IlyasMoutawwakil"><img alt="Ilyas Moutawwakil's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1642598610696-noauth.jpeg"></a> </span> </span></p> </div></div> <p>With the growing capability of large language models (LLMs), a new class of models has emerged: <a href="https://huggingface.co/blog/vlms-2025">Vision Language Models (VLMs)</a>. These models can analyze images and videos to describe scenes, create captions, and answer questions about visual content.</p>
<p>While running AI models on your own device can be difficult as these models are often computationally demanding, it also offers significant benefits: including improved privacy since your data stays on your machine, and enhanced speed and reliability because you're not dependent on an internet connection or external servers. This is where tools like <a href="https://huggingface.co/docs/optimum-intel/en/index">Optimum Intel</a> and <a href="https://docs.openvino.ai/2025/index.html">OpenVINO</a> come in, along with a small, efficient model like <a href="https://huggingface.co/blog/smolvlm">SmolVLM</a>. In this blog post, we'll walk you through three easy steps to get a VLM running locally, with no expensive hardware or GPUs required (though you can run all the code samples from this blog post on Intel GPUs).</p>
<h2> <a href="#deploy-your-model-with-optimum"> </a> <span> Deploy your model with Optimum </span>
</h2>
<p>Small models like SmolVLM are built for low-resource consumption, but they can be further optimized. In this blog post we will see how to optimize your model, to lower memory usage and speedup inference, making it more efficient for deployment on devices with limited resources.</p>
<p>To follow this tutorial, you need to install <code>optimum</code> and <code>openvino</code>, which you can do with:</p>
<pre><code>pip install optimum-intel[openvino] transformers==4.52.*
</code></pre>
<h2> <a href="#step-1-convert-your-model"> </a> <span> Step 1: Convert your model </span>
</h2>
<p>First, you will need to convert your model to the <a href="https://docs.openvino.ai/2025/documentation/openvino-ir-format.html">OpenVINO IR</a>. There are multiple options to do it:</p>
<ol>
<li>You can use the <a href="https://huggingface.co/docs/optimum-intel/en/openvino/export#using-the-cli">Optimum CLI</a></li>
</ol>
<pre><code>optimum-cli <span>export</span> openvino -m HuggingFaceTB/SmolVLM2-256M-Video-Instruct smolvlm_ov/
</code></pre>
<ol>
<li>Or you can convert it <a href="https://huggingface.co/docs/optimum-intel/en/openvino/export#when-loading-your-model">on the fly</a> when loading your model:</li>
</ol>
<pre><code><span>from</span> optimum.intel <span>import</span> OVModelForVisualCausalLM model_id = <span>"HuggingFaceTB/SmolVLM2-256M-Video-Instruct"</span>
model = OVModelForVisualCausalLM.from_pretrained(model_id)
model.save_pretrained(<span>"smolvlm_ov"</span>)
</code></pre>
<h2> <a href="#step-2-quantization"> </a> <span> Step 2: Quantization </span>
</h2>
<p>Now it’s time to optimize your model. Quantization reduces the precision of the model weights and/or activations, leading to smaller, faster models. Essentially, it's a way to map values from a high-precision data type, such as 32-bit floating-point numbers (FP32), to a lower-precision format, typically 8-bit integers (INT8). While this process offers several key benefits, it can also impact in a potential loss of accuracy.</p>
<p> <img alt="Quantization" src="https://huggingface.co/datasets/OpenVINO/documentation/resolve/main/blog/openvino_vlm/quantization.png">
</p> <p>Optimum supports two main post-training quantization methods:</p>
<ul>
<li><a href="https://huggingface.co/docs/optimum-intel/en/openvino/optimization#weight-only-quantization">Weight Only Quantization (WOQ)</a></li>
<li><a href="https://huggingface.co/docs/optimum-intel/en/openvino/optimization#full-quantization">Static Quantization</a></li>
</ul>
<p>Let’s explore each of them.</p>
<h3> <a href="#option-1-weight-only-quantization"> </a> <span> Option 1: Weight Only Quantization </span>
</h3>
<p>Weight-only quantization means that only the weights are quantized but activations remain in their original precisions. As a result, the model becomes smaller and more memory-efficient, improving loading times. But since activations are not quantized, inference speed gains are limited. Weight-only quantization is a simple first step since it usually doesn’t result in significant accuracy degradation.</p>
<blockquote>
<p>Since OpenVINO 2024.3, if the model's weight have been quantized, the corresponding activations will also be quantized at runtime, leading to additional speedup depending on the device.</p>
</blockquote>
<p>In order to run it, you will need to create a quantization configuration <code>OVWeightQuantizationConfig</code> as follows:</p>
<pre><code><span>from</span> optimum.intel <span>import</span> OVModelForVisualCausalLM, OVWeightQuantizationConfig q_config = OVWeightQuantizationConfig(bits=<span>8</span>)
q_model = OVModelForVisualCausalLM.from_pretrained(model_id, quantization_config=q_config)
q_model.save_pretrained(<span>"smolvlm_int8"</span>)
</code></pre>
<p>or equivalently using the CLI:</p>
<pre><code>optimum-cli <span>export</span> openvino -m HuggingFaceTB/SmolVLM2-256M-Video-Instruct --weight-format int8 smolvlm_int8/
</code></pre>
<h2> <a href="#option-2-static-quantization"> </a> <span> Option 2: Static Quantization </span>
</h2>
<p>With Static Quantization, both weights and activations are quantized before inference. To achieve the best estimate for the activation quantization parameters, we perform a calibration step. During this step, a small representative dataset is fed through the model. In our case, we will use 50 samples of the <a href="https://huggingface.co/datasets/ucla-contextual/contextual_test">contextual dataset</a> and will apply static quantization on the vision encoder while weight-only quantization will be applied on the rest of the model. Experiments show that applying static quantization on the vision encoder provides a noticeable performance improvement without significant accuracy degradation. Since the vision encoder is called only once per generation, the overall performance gain from applying static quantization on this component is lower than the gain achieved by optimizing more frequently used components like the language model. Nevertheless, this approach can be beneficial in certain scenarios. For example, when short answers are needed, especially with multiple images as input.</p>
<pre><code><span>from</span> optimum.intel <span>import</span> OVModelForVisualCausalLM, OVPipelineQuantizationConfig, OVQuantizationConfig, OVWeightQuantizationConfig q_config = OVPipelineQuantizationConfig( quantization_configs={ <span>"lm_model"</span>: OVWeightQuantizationConfig(bits=<span>8</span>), <span>"text_embeddings_model"</span>: OVWeightQuantizationConfig(bits=<span>8</span>), <span>"vision_embeddings_model"</span>: OVQuantizationConfig(bits=<span>8</span>), }, dataset=dataset, num_samples=num_samples,
)
q_model = OVModelForVisualCausalLM.from_pretrained(model_id, quantization_config=q_config)
q_model.save_pretrained(<span>"smolvlm_static_int8"</span>)
</code></pre>
<p>Quantizing activations adds small errors that can build up and affect accuracy, so careful testing afterward is important. More information and examples can be found in <a href="https://huggingface.co/docs/optimum-intel/en/openvino/optimization#pipeline-quantization">our documentation</a>.</p>
<h3> <a href="#step-3-run-inference"> </a> <span> Step 3: Run inference </span>
</h3>
<p>You can now run inference with your quantized model:</p>
<pre><code>generated_ids = q_model.generate(**inputs, max_new_tokens=<span>100</span>)
generated_texts = processor.batch_decode(generated_ids, skip_special_tokens=<span>True</span>)
<span>print</span>(generated_texts[<span>0</span>])
</code></pre>
<p>If you have a recent Intel laptop, Intel AI PC, or Intel discrete GPU, you can load the model on GPU by adding <code>device="gpu"</code> when loading your model:</p>
<pre><code>model = OVModelForVisualCausalLM.from_pretrained(model_id, device=<span>"gpu"</span>)
</code></pre>
<p>We also <a href="https://huggingface.co/spaces/echarlaix/vision-langage-openvino">created a space</a> so you can play with the <a href="https://huggingface.co/echarlaix/SmolVLM2-256M-Video-Instruct-openvino">original model</a> and its quantized variants obtained by respectively applying <a href="https://huggingface.co/echarlaix/SmolVLM2-256M-Video-Instruct-openvino-8bit-woq-data-free">weight-only quantization</a> and <a href="https://huggingface.co/echarlaix/SmolVLM2-256M-Video-Instruct-openvino-8bit-mixed">mixed quantization</a>. This demo runs on 4th Generation Intel Xeon (Sapphire Rapids) processors.</p>
<p> <img alt="HF Space" src="https://huggingface.co/datasets/OpenVINO/documentation/resolve/main/blog/openvino_vlm/chat1.png">
</p> <p>To reproduce our results, check out our <a href="https://github.com/huggingface/optimum-intel/blob/main/notebooks/openvino/vision_language_quantization.ipynb">notebook</a>.</p>
<h2> <a href="#evaluation-and-conclusion"> </a> <span> Evaluation and Conclusion </span>
</h2>
<p>We ran a benchmark to compare the performance of the <a href="https://huggingface.co/HuggingFaceTB/SmolVLM2-256M-Video-Instruct">PyTorch</a>, <a href="https://huggingface.co/echarlaix/SmolVLM2-256M-Video-Instruct-openvino">OpenVINO</a>, and <a href="https://huggingface.co/echarlaix/SmolVLM2-256M-Video-Instruct-openvino-8bit-woq-data-free">OpenVINO 8-bit WOQ</a> versions of the original model. The goal was to evaluate the impact of weight-only quantization on latency and throughput on Intel CPU hardware. For this test, we used <a href="https://huggingface.co/datasets/OpenVINO/documentation/resolve/main/blog/openvino_vlm/flower.png">a single image</a> as input.</p>
<p>We measured the following metrics to evaluate the model's performance:</p>
<ul>
<li>Time To First Token (TTFT) : Time it takes to generate the first output token.</li>
<li>Time Per Output Token (TPOT): Time it takes to generate each subsequent output tokens.</li>
<li>End-to-End Latency : Total time it takes to generate the output all output tokens.</li>
<li>Decoding Throughput: Number of tokens per second the model generates during the decoding phase.</li>
</ul>
<p>Here are the results on Intel CPU:</p>
<div> <table> <thead><tr>
<th>Configuration</th>
<th>Time To First Token (TTFT)</th>
<th>Time Per Output Token (TPOT)</th>
<th>End-to-End Latency</th>
<th>Decoding Throughput</th>
</tr> </thead><tbody><tr>
<td>pytorch</td>
<td>5.150</td>
<td>1.385</td>
<td>25.927</td>
<td>0.722</td>
</tr>
<tr>
<td>openvino</td>
<td>0.420</td>
<td>0.021</td>
<td>0.738</td>
<td>47.237</td>
</tr>
<tr>
<td>openvino-8bit-woq</td>
<td>0.247</td>
<td>0.016</td>
<td>0.482</td>
<td>63.928</td>
</tr>
</tbody> </table>
</div>
<p>This benchmark demonstrates how small, optimized multimodal models, like <a href="https://huggingface.co/HuggingFaceTB/SmolVLM2-256M-Video-Instruct">SmolVLM2-256M</a>, perform on Intel CPUs across different configurations. According to the tests, the PyTorch version shows high latency, with a time to first token (TTFT) of over 5s with a decoding throughput of 0.7 tokens/s. Simply converting the model with Optimum and running it on OpenVINO drastically reduces the time to first token (TTFT) to 0.42s (<strong>x12</strong> speedup) and raises throughput to 47 tokens/s (<strong>x65</strong>). Applying 8-bit weight-only quantization further reduces TTFT (<strong>x1.7</strong>) and increases throughput (<strong>x1.4</strong>), while also reducing model size and improving efficiency.</p>
<blockquote>
<p><strong>Platform configuration</strong>
Platform Configuration for performance claims above:</p>
<p><strong>System Board:</strong> MSI B860M GAMING PLUS WIFI (MS-7E42)<br><strong>CPU:</strong> Intel Core Ultra 7 265K<br><strong>Sockets/Physical Cores:</strong> 1/20 (20 threads)<br><strong>HyperThreading/Turbo Settings:</strong> Disabled<br><strong>Memory:</strong> 64 GB DDR5 @ 6400 MHz<br><strong>TDP:</strong> 665W<br><strong>BIOS:</strong> American Megatrends International, LLC. 2.A10<br><strong>BIOS Release Date:</strong> 28.11.2024<br><strong>OS:</strong> Ubuntu 24.10<br><strong>Kernel:</strong> 6.11.0–25-generic<br><strong>OpenVINO Version:</strong> 2025.2.0<br><strong>torch:</strong> 2.8.0<br><strong>torchvision:</strong> 0.23.0+cpu<br><strong>optimum-intel:</strong> 1.25.2<br><strong>transformers:</strong> 4.53.3<br><strong>Benchmark Date:</strong> 15.05.2025<br><strong>Benchmarked by:</strong> Intel Corporation
Performance may vary by use, configuration, and other factors. See the platform configuration below.</p>
</blockquote>
<h2> <a href="#useful-links--resources"> </a> <span> Useful Links &amp; Resources </span>
</h2>
<ul>
<li><a href="https://github.com/huggingface/optimum-intel/blob/main/notebooks/openvino/vision_language_quantization.ipynb">Notebook</a></li>
<li><a href="https://huggingface.co/spaces/echarlaix/vision-langage-openvino">Try our Space</a></li>
<li><a href="https://web.cvent.com/event/d550a2a7-04f2-4a28-b641-3af228e318ca/regProcessStep1?utm_campaign=speakers4&amp;utm_medium=organic&amp;utm_source=Community">Watch the webinar recording</a></li>
<li><a href="https://huggingface.co/docs/optimum-intel/en/openvino/inference">Optimum Intel Documentation</a></li>
</ul>
<blockquote> <h2> <a href="#notices--disclaimers"> </a> <span> Notices &amp; Disclaimers </span>
</h2>
<p>Performance varies by use, configuration, and other factors. Learn more on the Performance Index site.
Performance results are based on testing as of dates shown in configurations and may not reflect all publicly available updates. See backup for configuration details. No product or component can be absolutely secure. Your costs and results may vary. Intel technologies may require enabled hardware, software or service activation. Intel Corporation. Intel, the Intel logo, and other Intel marks are trademarks of Intel Corporation or its subsidiaries.</p>
</blockquote>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'smooth' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'smooth' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'top') scrollToTop();
      if (data.direction === 'bottom') scrollToBottom();
    });
  </script>
</body>
</html>