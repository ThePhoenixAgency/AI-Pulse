<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Continuous batching from first principles</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Continuous batching from first principles</h1>
  <div class="metadata">
    Source: Hugging Face Blog | Date: 11/25/2025 1:00:00 AM | Lang: FR |
    <a href="https://huggingface.co/blog/continuous_batching" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div> <p><a href="https://huggingface.co/blog"> Back to Articles</a></p> <div><div> <p><span><span><a href="https://huggingface.co/ror"><img alt="Rémi Ouazan Reboul's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/6123945a0ed258ebc83f3d56/8wMHFQHEV24G_ljl4kPxQ.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/ArthurZ"><img alt="Arthur Zucker's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1674683851722-62441cb7456803e95009a08f.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/mcpotato"><img alt="Luc Georges's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1666977434736-617bc8d1000dbbbf7c225eed.png"></a> </span> </span></p> </div></div> <div><nav><ul><li><a href="#attention">Attention</a> <ul></ul> </li><li><a href="#kv-cache">KV-cache</a> <ul></ul> </li><li><a href="#chunked-prefill">Chunked prefill</a> <ul></ul> </li><li><a href="#continuous-batching-1">Continuous batching</a> <ul></ul> </li><li><a href="#conclusion">Conclusion</a> <ul></ul> </li></ul></nav></div><p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/banner.png"><img alt="Title card" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/banner.png"></a></p>
<p><em>TL;DR: in this blog post, starting from attention mechanisms and KV caching, we derive continuous batching by optimizing for throughput.</em></p>
<p>If you've ever used Qwen, Claude, or any other AI chatbot, you've probably noticed something: it takes a while for the first word of the response to appear, and then words appear one-by-one on your screen with (hopefully) a regular and fast-paced frequency. That's because at the heart of it, all LLMs are just fancy next token predictors. An LLM first processes your entire prompt to produce one new token. Then it keeps adding tokens one by one, each time reading everything that came before, until it decides generation is over.</p>
<p>This generation process is computationally expensive: it requires passing the input through billions of parameters for each token generated. To make these models practical for real-world applications, particularly when serving many users simultaneously, researchers and engineers have developed a range of efficient inference techniques.<br>One of the most impactful optimizations is <strong>continuous batching</strong>, which attempts to maximize performance by processing multiple conversations in parallel and swapping them out when they are done.</p>
<p>To understand how continuous batching works and why it's so effective in high-load serving scenarios, we'll build up from the fundamentals of how LLMs process tokens.</p>
<h2> <a href="#attention"> <span></span> </a> <span> Attention </span>
</h2>
<p>The attention mechanism is the central piece of how LLMs work. A language model processes text by breaking it down into pieces that we call tokens. We can conceptually think of "tokens" as "words", but sometimes a word might be composed of several tokens. For each token sequence, the network computes a prediction of what the next token should be.</p>
<p>Many operations in the network are <strong>token-wise</strong>: each token is processed independently, and the output for a given token depends only on that token's content, not on any other tokens in the sequence. Operations like this include layer normalization or matrix multiplication. However, to create connections between words in a sentence, we need operations where tokens can influence each other. </p>
<p>This is where attention comes in. <strong>Attention layers are the only place where different tokens interact with each other</strong>. Understanding how a network connects tokens together means understanding attention.</p>
<p>Let's see how this works in practice, in the case where there is only one input prompt.</p>
<p>Consider the initial prompt <code>I am sure this project</code>, tokenized as 7 tokens: <code>[&lt;bos&gt;, I, am, sure, this, pro, ject]</code>. The <code>&lt;bos&gt;</code>, or "Beginning of Sequence", is a special token we add at the start of the prompt to tell the language model that a new conversation starts here.</p>
<p>Each token is represented inside the network with a vector of length <code>d</code> (the <em>hidden dimension</em>). Therefore, the seven incoming tokens form a tensor <span><span>xx</span></span> with shape <span><span>[1,7,d]\left[1, 7, d \right]</span></span>. <code>1</code> is the number of sequences, or batch size, which is just one in our case. <code>7</code> is the sequence length, and <code>d</code> is the hidden dimension, or the size of each token representation. Going forward, we'll use <span><span>nn</span></span> instead of <code>7</code> as the sequence length.</p>
<p>Input tensor <span><span>x x </span></span> is then projected by three matrices: the query projection <span><span>Wq W_q </span></span>, the key projection <span><span>Wk W_k </span></span> and the value projection <span><span>Wv W_v </span></span>. This produces three tensors <span><span>Q Q </span></span>, <span><span>K K </span></span> and <span><span>V V </span></span>, all of shape <span><span>[1,n,A] \left[1, n , A \right] </span></span>, where <span><span>A A </span></span> is the dimension of the attention head. We call them the <strong>query, key and value states,</strong> respectively. This is represented on the left in the figure below.</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/proj_and_mul.png"><img alt="proj_and_mul.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/proj_and_mul.png"></a></p>
<p>Next, tensors <span><span>Q Q </span></span> and <span><span>K K </span></span> are multiplied together to measure similarity between tokens, producing a tensor of shape <span><span>[1,n,n] \left[ 1, n , n \right] </span></span>. This is why we say that attention has quadratic complexity in sequence length. Computing <span><span>QKT QK^T </span></span> requires <span><span>O(n2d) \mathcal{O} \left( n^2 d \right) </span></span> operations, so the cost is a square of <span><span>n n </span></span> the sequence length. It is represented on the right in the figure above.</p>
<p>We then apply a boolean <strong>attention mask</strong> to <span><span>QKT QK^T </span></span> to control which tokens can interact, as represented in the figure below. In this figure, the attention mask is a <strong>causal mask</strong>, meaning each token only interacts with tokens that came before it. This follows the intuition that a cause must come before its consequence, hence the name causal mask. The attention mask is crucial because it dictates all token interactions in the network. <strong>Set all attention mask values to False and no token will ever interact with another in the whole network.</strong> We'll examine attention masks more closely in a few paragraphs.</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/masking_and_softmax.png"><img alt="masking_and_softmax.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/masking_and_softmax.png"></a></p>
<p>Finally, after applying the attention mask, we take a token-wise softmax (which is the same as saying a row-wise softmax) and multiply the result by the value projection <span><span>V V </span></span> to get the output of one attention head, of shape <span><span>[1,n,A] \left[ 1, n , A \right] </span></span>. We offer a visual summary of the whole process in the following figure.</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/attention.png"><img alt="attention.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/attention.png"></a></p>
<p>We are going to use a lot of attention visualization in this post, so to simplify things, we are going to condense the figure above just a bit.</p>
<p><strong>Why this matters:</strong> In continuous batching, <span><span>Q Q </span></span>, <span><span>K K </span></span>, and <span><span>V V </span></span> can have different numbers of tokens because, as we'll see, we'll be processing different stages (prefill and decode) at the same time. To make it more general, let's say <span><span>Q Q </span></span> has shape <span><span>[1,nQ,A] \left[1, n_Q , A \right] </span></span>, <span><span>K K </span></span> has shape <span><span>[1,nK,A] \left[ 1, n_K , A \right] </span></span>, and <span><span>V V </span></span> has shape <span><span>[1,nV,A] \left[ 1, n_V , A \right] </span></span>.</p>
<p>The attention scores <span><span>QKT QK^T </span></span> then have shape <span><span>[1,nQ,nK] \left[ 1, n_Q , n_K \right] </span></span>, and the attention mask has the same shape since it's applied point-wise to the scores.</p>
<p>After applying the attention mask and row-wise softmax, we multiply by <span><span>V V </span></span>. Since we're multiplying a matrix of shape <span><span>[1,nQ,nK] \left[ 1, n_Q , n_K \right] </span></span> by one of shape <span><span>[1,nV,A] \left[ 1, n_V , A \right] </span></span>, the inner dimensions must match: <span><span>nK=nV n_K = n_V </span></span>. This means <span><span>V V </span></span> and <span><span>K K </span></span> always have the same length, so we can simplify our visualizations by only showing <span><span>K K </span></span>.<br>Don't worry if this seems abstract: the figures will make it concrete.</p>
<p>Furthermore, since we know that the attention mask is applied to <span><span>QKT QK^T </span></span>, we know they have the same shape. Instead of representing the attention scores, we will represent the attention mask in its place.
Finally, since <span><span>Q Q </span></span>, <span><span>K K </span></span> and <span><span>V V </span></span> are direct projections of <span><span>x x </span></span>, no need to represent <span><span>x x </span></span>. This gives the simplified figure where we only represent <span><span>Q Q </span></span>, <span><span>K K </span></span> and the attention mask:</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/simple_attention.png"><img alt="simple_attention.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/simple_attention.png"></a></p>
<p>This representation also underlines how we can <strong>read an attention mask.</strong> </p>
<p>We read the mask row-by-row, which is the same as reading token-by-token: each row corresponds to one token's attention computation. A <strong>green square</strong> at position (row i, column j) means <code>True</code>: token j can influence token i. A <strong>white square</strong> means <code>False</code>: no interaction allowed.</p>
<p>For example, look at the third row for token "<em>am</em>". The "<em>I</em>" column is green, so "<em>I</em>" influences the computation of "<em>am</em>". The "<em>pro</em>" column is white, so "<em>pro</em>" doesn't influence "<em>am</em>" . This is causal masking at work: future tokens can't affect past ones.</p>
<p>The last layer of the model outputs a token prediction for each input token. In our context, generating the continuation of a single prompt, we only care about the next token prediction from the last token. The last token is "<em>ject</em>" in the figure above, and the associated prediction is "<em>will</em>".</p>
<p>The process we just described, where we take an entire input sequence, pass it through multiple attention layers and compute a score for the next token, is called <strong>prefill</strong>. This is because, as we'll see in a moment, much of the computation we performed can be cached and reused – hence, we are <em>prefilling</em> the cache. Thanks to the use of this cache, sequence generation can proceed using much less compute in a phase called <strong>decoding</strong>. In the decoding phase, generating one new token will be much faster than the initial full-sequence computation. Let's see why.</p>
<p>To continue generation, we begin a new forward pass, which would naively look like this:</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/naive_generate.png"><img alt="naive_generate.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/naive_generate.png"></a></p>
<p>To compute the attention scores of the new token, we still need the key and value projections of the previous tokens. So we need to repeat the matrix multiplication of the old tokens (in grey in the figure above) with <span><span>Wk W_k </span></span> and <span><span>Wv W_v </span></span> to retrieve a result that was already computed once before. In other terms, we are wasting compute. Let's see how we can avoid that.</p>
<h2> <a href="#kv-cache"> <span></span> </a> <span> KV-cache </span>
</h2>
<p>Right off the bat, we notice that the last token does not impact the attention calculation of the other tokens:</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/cant_see_me.png"><img alt="cant_see_me.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/cant_see_me.png"></a></p>
<p>This follows the idea of the causal mask: since "<em>will</em>" comes after all previous tokens, it does not change their attention calculation.
For text generation, causal attention is by far the most common, so we will focus on that case from now on. Keep in mind that non-causal attention schemes can also be used, especially when dealing with images.
Considering we only need the next-token prediction for the "<em>will</em>" token, we can simplify the attention mechanism by only computing the output for this token.</p>
<p>Moreover, we already computed the <span><span>K K </span></span> and <span><span>V V </span></span> states for the tokens "<em>&lt;bos&gt;</em>", … , "<em>ject</em>" during the previous forward pass: if they have been stored, we do not need to recompute them again. This is the <strong>KV cache</strong>: the list of key and value states created during generation. It essentially allows one to reduce the compute cost of generating token <span><span>n+1 n+1 </span></span> from <span><span>O(n2) \mathcal{O} \left( n^2 \right) </span></span> to <span><span>O(n) \mathcal{O} \left( n \right) </span></span> by avoiding recomputation of key and value projections, while paying a memory cost of <span><span>O(n) \mathcal{O} \left( n \right) </span></span>.</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/kv_cache.png"><img alt="kv_cache.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/kv_cache.png"></a></p>
<p>In the figure above, only the tokens in white are computed: instead of computing the keys and values for 8 tokens, we compute them for 1. You can see that through KV caching, a lot of compute is saved.<br>You can check <a href="https://huggingface.co/blog/not-lain/kv-caching">this post</a> for more visualizations of KV caching, or <a href="https://huggingface.co/blog/kv-cache">this one</a> for a practical implementation example.</p>
<p>Let's be a bit more specific about the cache size, because it's a good opportunity to examine the shapes present in our model. For a model with <span><span>L \mathcal L </span></span> attention layers and <span><span>H H </span></span> attention heads with head dimension <span><span>A A </span></span>, the total cache size needed to store one token will be <span><span>2∗L∗AH 2 *\mathcal L * AH </span></span> with a factor of <span><span>2 2 </span></span> to account for both <span><span>K K </span></span> and <span><span>V V </span></span>.<br>For instance, Llama-2-7B with <span><span>L=32 \mathcal{L}=32 </span></span> layers, <span><span>H=32 H=32 </span></span> heads, and <span><span>A=128 A=128 </span></span> requires <span><span>2×32×128=8,192 2 \times 32 \times 128 = 8,192 </span></span> values per token per layer. With <code>float16</code> precision, this takes <span><span>2AH×2 2AH \times 2 </span></span> bytes <span><span>=16 = 16 </span></span> KB in memory.</p>
<p>KV caching is useful when we want to generate the next token, which is a stage we call <strong>decoding</strong>. But it can also be useful in the <strong>prefill</strong> stage, when we process the initial prompt and have many input tokens. Especially when there are large initial prompts that don't fit in GPU memory all at once.</p>
<h2> <a href="#chunked-prefill"> <span></span> </a> <span> Chunked prefill </span>
</h2>
<p>Up till now, we have looked at an example of prefill where we have <span><span>n=7 n=7 </span></span> tokens, but in practice initial prompts can be much longer. For instance, when using Cursor, you can add your repository to the prompt, where it acts as context: this significantly increases the prompt size. In such cases, the memory needed to store the activations for <span><span>n n </span></span> tokens can be larger than the available memory on the GPU. Thus we cannot perform prefill in a single forward pass: we have to split the prefill in chunks. This is called <strong>chunked prefill</strong>, and it's going to be one of the components needed to enable efficient inference.</p>
<p>Let's pretend that the available memory is very constrained, and that we can only pass <span><span>m=4 m=4 </span></span> tokens per forward pass. If we have an initial prompt with <span><span>n=7 n = 7 </span></span> tokens, we need to split it in <span><span>⌈n/m⌉=2 \lceil n /m \rceil = 2 </span></span> chunks (rounding up 7/4 = 1.75 to 2). We illustrate the example below using the same <span><span>n n </span></span> and <span><span>m m </span></span> notations:</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/chunked_prefill.png"><img alt="chunked prefill.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/chunked_prefill.png"></a></p>
<p>We can do that thanks to the KV cache. We store the KV states during the first prefill split, and during the second prefill split, we prepend the stored KV states to the new KV states. We also adapt the attention mask accordingly. Visually, it looks like we split the non-chunked prefill in the middle.</p>
<p>The key insight: cached KV states let us process the prompt incrementally without losing information.</p>
<p>Although we showed here an example where we split the prefill into 2 chunks, chunked prefill can be used to split the prefill in any way we want, adapting flexibly to memory constraints. </p>
<p>We are now finally equipped with all the tools we need to understand Continuous Batching.</p>
<h2> <a href="#continuous-batching-1"> <span></span> </a> <span> Continuous batching </span>
</h2>
<p>In our previous examples we have only considered the case of batch size one, i.e. we only generate tokens for one prompt at a time. In the context of evaluation or model serving, we want to generate tokens for a large number of prompts. To increase the <strong>throughput</strong>, which is the number of tokens generated per second, the best course of action is to generate tokens in parallel for a batch of several prompts.</p>
<p>To batch prompts together, the naive way is to add an axis to both input tensors: token sequence and attention mask. However, this comes with a constraint on the shape of the inputs: we need all prompts to have the same length, because tensors must be rectangular. To achieve this, we usually add padding on the left so the new token prediction always comes from the rightmost token. We also modify the attention mask of each prompt accordingly, as shown below:</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/padding.png"><img alt="padding.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/padding.png"></a></p>
<p>where the padding tokens <code>&lt;pad&gt;</code> are coloured in orange. Then we can perform the forward pass as we used to, with the added dimension of the batch size. This is called <strong>batched generation</strong>: efficient for same-length prompts, but wasteful when lengths vary.<br>It is illustrated below, through 4 steps of generation: one prefilling step (at the top) and 3 decoding steps (below each "Forward pass" lines).</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/batched_generation.png"><img alt="batched_generation.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/batched_generation.png"></a></p>
<p>where <code>&lt;eos&gt;</code> means "End Of Sequence", this is a special token to indicate the model has reached the end of generation for the corresponding sequence.</p>
<p>The drawback of batched generation is that if one prompt finishes generation before the other one by generating an <code>&lt;eos&gt;</code> token, all further generated tokens are useless. And this goes on until the longest request of the batch finishes. Of course, we can remove the prompts that have reached an <code>&lt;eos&gt;</code> token from the batch and save some compute and memory, but saving resources is not the goal here: throughput is. </p>
<p>Instead of just removing the finished prompt from the batch, we can replace it with a prompt that's waiting for generation. We will call this <strong>dynamic scheduling</strong>, or dynamic batching. Dynamic scheduling is great to maintain throughput while ensuring any token generated by a forward pass is relevant. But because of the way we batched prompts together, it has a major drawback: we need a lot of padding when swapping prompts. That's because the newly-inserted prompt needs to go through prefill while the other prompts are decoding one token at a time. So there is almost as much padding as there are tokens in the newly-inserted prompt.</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/dynamic_batching.png"><img alt="dynamic_batching.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/dynamic_batching.png"></a></p>
<p>The problem becomes even worse when batch size increases and initial prompts are long. The padding cost grows quadratically with both batch size and prompt length. If we have a batch of <span><span>B B </span></span> prompts that are in decoding phase and one finishes, dynamically introducing a prompt of <span><span>n n </span></span> initial tokens in the batch requires <span><span>(n−1)(B−1) (n-1)(B-1) </span></span> padding tokens. For instance, with <span><span>B=8 B=8 </span></span> and <span><span>n=100 n=100 </span></span>, we'd need <span><span>99×7=693 99 \times 7 = 693 </span></span> padding tokens!</p>
<p>Furthermore, practical optimizations like CUDA graphs or <code>torch.compile</code> require static tensor shapes. This forces us to pad all prompts to a fixed maximum length, dramatically increasing the padding waste. </p>
<p>At this point, our main problem is padding, which is a consequence of the axis we added to batch sentences together. Thus, the ideal would be to get rid of this axis entirely, a radical rethinking of batching. If we do so, the only way to batch prompts together is to concatenate them:</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/concatenate.png"><img alt="concatenate.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/concatenate.png"></a></p>
<p>But we don't want tokens from prompt 0 to interact with the tokens of prompt 1! Luckily for us, we have a way to control how tokens interact with one another: the attention mask. How we do this is displayed below:</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/ragged_batching.png"><img alt="ragged_batching.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/ragged_batching.png"></a></p>
<p>Although we use different tints of green to illustrate the different parts of the attention mask, this is still a boolean mask with only greens for <code>True</code> and white for <code>False</code>. This way of batching prompts together is called <strong>ragged batching</strong> (because sequence lengths are 'ragged' or uneven), and it offers the benefit of added throughput without introducing the need for padding tokens.</p>
<p>In the figure above, we use ragged batching to combine two full prompts together, but we can batch as many as memory allows. The only limit is <span><span>m m </span></span>, the number of tokens we can fit in a batch, with <span><span>m m </span></span> depending on the available memory on the GPU. </p>
<p>Ragged batching is one of the key components of continuous batching. To maximize throughput, we can combine prefill and decoding sequences following an algorithm like this:</p>
<ul>
<li>We try to always reach our memory budget of <span><span>m m </span></span> tokens per batch</li>
<li>We first add all the prompts in decoding phase to the batch, each accounting for 1 token</li>
<li>We fill the remaining space with prefill phase prompts, relying on the flexibility of chunked prefill to split inputs as needed</li>
</ul>
<p>Dynamic scheduling is the final piece that contributes to the <em>continuous batching</em> technique: we remove finished prompts from the batch as soon as they are done, and replace them with new chunked prompts that correspond to incoming requests.</p>
<p>This combination of ragged batching and dynamic scheduling is called <strong>continuous batching</strong>, and it's the technique that powers modern LLM serving systems.</p>
<p><a href="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/continuous_batching.png"><img alt="continuous_batching.png" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/blog/continuous_batching/continuous_batching.png"></a></p>
<h2> <a href="#conclusion"> <span></span> </a> <span> Conclusion </span>
</h2>
<p>Continuous batching combines three key techniques to maximize throughput in LLM serving:</p>
<ol>
<li><strong>KV caching</strong> to avoid recomputing past token representations</li>
<li><strong>Chunked prefill</strong> to handle variable-length prompts within memory constraints </li>
<li><strong>Ragged batching with dynamic scheduling</strong> to eliminate padding waste and keep the GPU fully utilized</li>
</ol>
<p>By removing the batch dimension and using attention masks to control token interactions, continuous batching allows mixing prefill and decode phases in the same batch, dramatically improving efficiency for serving multiple requests. This is why services like ChatGPT can handle thousands of concurrent users efficiently. </p>
<p>In the next article in this series, we'll explore efficient KV cache management through <strong>paged attention</strong>. If you'd like to see a deep dive on other continuous batching topics, please let us know in the comments!</p>
<p><em>Acknowledgement: thanks to Arthur Zucker for producing the initial concept for the figures used in this article. And thanks to Arthur Zucker, Luc Georges, Lysandre Debut, Merve Noyan and Pedro Cuenca for all providing helpful reviews.</em></p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
  </script>
</body>
</html>