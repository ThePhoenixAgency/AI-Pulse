<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Bypassing Windows Administrator Protection - Project Zero</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.8; color: #e2e8f0; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.5em; }
  .metadata { color: #94a3b8; font-size: 0.9em; margin-bottom: 2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 1em; }
  img { max-width: 100%; height: auto; border-radius: 8px; }
  a { color: #00d9ff; }
  p { margin-bottom: 1em; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 15px; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 15px; border-radius: 6px; overflow-x: auto; }

  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }

</style>
</head>
<body>
  <h1>Bypassing Windows Administrator Protection - Project Zero</h1>
  <div class="metadata">
    Source: Google Project Zero | Date: 1/26/2026 | Lang: EN |
    <a href="https://projectzero.google/2026/26/windows-administrator-protection.html" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div>
      <article>
        
        <section>
          <p>A headline feature introduced in the latest release of Windows 11, 25H2 is <a href="https://blogs.windows.com/windowsdeveloper/2025/05/19/enhance-your-application-security-with-administrator-protection/">Administrator Protection</a>. The goal of this feature is to replace User Account Control (UAC) with a more robust and importantly, securable system to allow a local user to access administrator privileges only when necessary.</p>

<p>This blog post will give a brief overview of the new feature, how it works and how it’s different from UAC. I’ll then describe some of the security research I undertook while it was in the insider preview builds on Windows 11. Finally I’ll detail one of the nine separate vulnerabilities that I found to bypass the feature to silently gain full administrator privileges. All the issues that I reported to Microsoft have been fixed, either prior to the feature being officially released (in optional update <a href="https://support.microsoft.com/en-gb/topic/october-28-2025-kb5067036-os-builds-26200-7019-and-26100-7019-preview-ec3da7dc-63ba-4b1d-ac41-cf2494d2123a">KB5067036</a>) or as subsequent security bulletins.</p>

<p><em>Note: As of 1st December 2025 the Administrator Protection feature has been disabled by Microsoft while an application compatibility issue is dealt with. The issue is unlikely to be related to anything described in this blog post so the analysis doesn’t change.</em></p>



<h2>The Problem Administration Protection is Trying to Solve</h2>

<p>UAC was introduced in Windows Vista to facilitate granting a user administrator privileges temporarily, while the majority of the user’s processes run with limited privileges. Unfortunately, due to the way it was designed, it was quickly apparent it didn’t represent a hard security boundary, and Microsoft downgraded it to a security feature. This was an important change as it made it no longer a priority to fix bypasses of the UAC which allowed a limited process to silently gain administrator privileges.</p>

<p>The main issue with the design of UAC was that both the limited user and the administrator user were the same account just with different sets of groups and privileges. This meant they shared profile resources such as the user directory and <a href="https://www.tiraniddo.dev/2017/05/exploiting-environment-variables-in.html">registry hive</a>. It was also possible to open an administrators process’ access token and <a href="https://www.tiraniddo.dev/2017/05/reading-your-way-around-uac-part-1.html">impersonate it</a> to grant administrator privileges as the impersonation permission checks didn’t originally consider if an access token was “elevated” or not, it just considered the user and the integrity level.</p>

<p>Even so, on Vista it wasn’t that easy to silently acquire administrator privileges as most routes still showed a prompt to the user. Unfortunately, Microsoft decided to reduce the number of elevation prompts a user would see when modifying system configuration and introduced an “auto-elevation” feature in Windows 7. Select Microsoft binaries could be opted in to be automatically elevated. However, it also meant that in some cases it was possible to repurpose the binaries to silently gain administrator privileges. It was possible to configure UAC to always show a prompt, but the default, which few people change, would allow the auto-elevation.</p>

<p>A good repository of known bypasses is the <a href="https://github.com/hfiref0x/UACME">UACMe</a> tool which currently lists 81 separate techniques for gaining administrator privileges. A proportion of those have been fixed through major updates to the OS, even though Microsoft never officially acknowledges when a UAC bypass is fixed. However, there still exist silent bypasses that impact the latest version of Windows 11 that remain unfixed.</p>

<p>The fact that malware is regularly using known bypasses to gain administrator privileges is what Administrator Protection aims to solve. If the weaknesses in UAC can be mitigated then it can be made a secure boundary which not only requires more work to bypass but also any vulnerabilities in the implementation could be fixed as security issues.</p>

<p>In fact there is already a more secure mechanism that UAC can use that doesn’t suffer from many of the problems of the so-called “admin approval” elevation. This mechanism is used when the user is not a member of the administrators group, it’s referred to as “over-the-shoulder” elevation. This mechanism requires a user to know the credentials of a local administrator user which must be input into the UAC elevation prompt. It’s more secure than admin approval elevation for the following reasons:</p>

<ul>
  <li>The profile data is no longer shared, which prevents the limited user from modifying files or registry keys which might be used by an elevated administrator process.</li>
  <li>It’s no longer possible to get an access token for the administrator user and impersonate it as limited users cannot impersonate other user accounts.</li>
  <li>Auto-elevation of Microsoft binaries is not supported, all elevation requests require confirmation through a prompt.</li>
</ul>

<p>Unfortunately, the mechanism is difficult to use securely in practice as sharing the credentials to another local administrator account would be a big risk. Thus it’s primarily useful as a means for technical support where a sysadmin types in the credentials over the user’s shoulder.</p>

<p>Administrator Protection improves on over-the-shoulder elevation by using a separate shadow administrator account that is automatically configured by the UAC service. This has all the benefits of over-the-shoulder elevation plus the following:</p>

<ul>
  <li>The user does not need to know the credentials for the shadow administrator as there aren’t any. Instead UAC can be configured to prompt for the limited user’s credentials, including using biometrics if desired.</li>
  <li>A separate local administrator account isn’t required, only the user needs to be configured to be a member of the administrators group making deployment easier.</li>
</ul>

<p>While Microsoft is referring to Administrator Protection as a separate feature it can really be considered a third UAC mechanism as it uses the same infrastructure and code to perform elevation, just with some tweaks. However, the feature replaces admin-approval mode so you can’t use the “legacy” mode and Administrator Protection at the same time. If you want to enable it there’s currently no UI to do so but you can <a href="https://techcommunity.microsoft.com/blog/windows-itpro-blog/administrator-protection-on-windows-11/4303482">modify the local security policy</a> to do so.</p>

<p>The big question, will this make UAC a securable boundary so malware no longer has a free ride? I guess we better take a look and find out.</p>

<h2>Researching Administrator Protection</h2>

<p>I typically avoid researching new Windows features before they’re released. It hasn’t been a good use of time in the past where I’ve found a security issue in a new feature during the insider preview stages only for that bug to be due to temporary code that is subsequently removed. Also if security issues are fixed in the insider preview stage they do not result in a security bulletin, making it harder to track when something is fixed. Therefore, there’s little incentive to research features until they are released when I can be confident any bugs that are discovered are real security issues and they’re fixed in a timely manner.</p>

<p>This case was slightly different, Microsoft reached out to me to see if I wanted to help them find issues in the implementation during the insider preview stage. No doubt part of the reason they reached out was my history of finding complex logical UAC bypasses. Also, I’d already taken a brief look and noted that the feature was still vulnerable to a few well known public bypasses such as my abuse of <a href="https://www.tiraniddo.dev/2022/03/bypassing-uac-in-most-complex-way.html">loopback Kerberos</a>.</p>

<p>I agreed to look at a design document and provide feedback without doing a full “pentest”. However, if I did find issues, considering the goal was for Administration Protection to be a securable boundary I was assured that they would be fixed through a bulletin, or at least would be remediated before the final release of the feature.</p>

<p>The Microsoft document provided an overview, but not all design details. For example, I did have a question around what the developers considered the security boundary. In keeping with the removal of auto-elevation I made the assumption that bypassing the boundary would require one or more of the following:</p>

<ul>
  <li>Compromising the shadow administrators profile, such as writing arbitrary files or registry keys.</li>
  <li>Hijacking an existing process running as the shadow administrator.</li>
  <li>Get a process executing as an administrator without showing a prompt.</li>
</ul>

<p>The prompt being a boundary is important, there’s a number of UAC bypasses, such as those which rely on elevated COM objects that would still work in Administrator Protection. However as auto-elevation is no longer permitted they will always show a prompt, therefore these are not considered bypasses. Of course, what is shown in the prompt, such as the executable being elevated, doesn’t necessarily correlate with the operation that is about to be performed with administrator rights.</p>

<p>In the document there was some lack of consideration of some associated UAC features such as UI Access processes (this will be discussed in part 2 of this series) but even so some descriptions stuck out to me. Therefore, I couldn’t help myself and decided to at least take a look at the current implementation in the canary build of insider preview. This research was a mix of reverse engineering of the UAC service code in <code>appinfo.dll</code> as well as behavioral analysis.</p>

<p>At the end of the research I found <a href="https://project-zero.issues.chromium.org/issues?q=reporter:forshaw@google.com%20title:%22administrator%20protection%22">9 separate</a> means to bypass the feature and silently gain administrator privileges. Some of the bypasses were long standing UAC issues with publicly available test cases. Others were due to implementation flaws in the feature itself. But the most interesting bug class was where there wasn’t a bug at all, until the rest of the OS got involved.</p>

<p>Let’s dive into this most interesting bypass I identified during the research. If you want to skip ahead you can read the full details on the <a href="https://project-zero.issues.chromium.org/issues/432313668">issue tracker</a>. This issue is interesting, not just because it allowed me to bypass the protection but also because it was a potential UAC bypass that I had known about for many years, but only became practically exploitable because of the introduction of this feature.</p>

<h2>Logon Sessions</h2>

<p>First a little bit of background knowledge to understand the vulnerability. When a user authenticates to a Windows system successfully they’re assigned a unique <a href="https://learn.microsoft.com/en-us/windows/win32/secauthn/lsa-logon-sessions">logon session</a>. This session is used to control the information about the user, for example it keeps a copy of the user’s credentials so that they can be used for network authentication.</p>

<p>The logon session is added as a reference in the access token created during the logon process, so that it can be easily referred to during any kernel operations using the token. You can find the unique 64-bit authentication ID for the session by querying the token using the <code>NtQueryInformationToken</code> system call. In UAC, separate logon sessions are assigned to the limited and the linked administrator access tokens as shown in the following script where you can observe that the limited token and linked token have distinct authentication ID LUID values:</p>

<div><pre><code><span># Get authentication ID of current token</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>Get-NtTokenId</span><span> </span><span>-Authentication</span><span>
</span><span>LUID</span><span>
</span><span>----</span><span>
</span><span>00000000</span><span>-11457F17</span><span>

</span><span># Query linked administrator token and get its authentication ID.</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$t</span><span> </span><span>=</span><span> </span><span>Get-NtToken</span><span> </span><span>-Linked</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>Get-NtTokenId</span><span> </span><span>-Authentication</span><span> </span><span>-Token</span><span> </span><span>$t</span><span>
</span><span>LUID</span><span>
</span><span>----</span><span>
</span><span>00000000</span><span>-11457E9E</span><span>
</span></code></pre></div>

<p>One important place the logon session is referenced by the kernel is when looking up DOS drive letters. From the kernels perspective drive letters are stored in a special object directory <code>\??</code>. When this path is looked up by the kernel it’ll first see if there’s a logon session specific directory to check, this is stored under the path <code>\Sessions\0\DosDevices\X-Y</code>, where X-Y is the hexadecimal representation of the authentication ID for the logon session. If the drive letter symbolic link isn’t found in that directory the kernel falls back to checking the <code>\GLOBAL??</code> directory. You can observe this behavior by opening the <code>\??</code> object directory using the <code>NtOpenDirectoryObject</code> system call as shown:</p>

<div><pre><code><span>PS</span><span>&gt;</span><span> </span><span>$d</span><span> </span><span>=</span><span> </span><span>Get-NtDirectory</span><span> </span><span>"\??"</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$d</span><span>.</span><span>FullPath</span><span>
</span><span>\Sessions\0\DosDevices\00000000-11457f17</span><span>
</span></code></pre></div>

<p>It’s <a href="https://project-zero.issues.chromium.org/issues/42451540">well known</a> that if you can write a symbolic link to a DOS device object directory you can hijack the <code>C:</code> drive of any process running with that access token in that logon session. Even though the <code>C:</code> drive is defined in the global object directory, the logon session specific directory is checked first and so it can be overridden.</p>

<p>If a user can write into another logon session’s DOS device object directory they can redirect any file access to the system drive. For example you could redirect system DLL loading to force arbitrary code to run in the context of a process running in that logon session. In the case of UAC this isn’t an issue as the separate DOS device object directories have different access control and therefore the limited user can’t hijack the <code>C:</code> drive of an administrator process. The access control for the administrator’s DOS device object directory is shown below:</p>

<div><pre><code><span>PS</span><span>&gt;</span><span> </span><span>Get-NtTokenSid</span><span>
</span><span>Name</span><span>           </span><span>Sid</span><span>
</span><span>----</span><span>           </span><span>---</span><span>
</span><span>DOMAIN\user</span><span>    </span><span>S-1-5-21-5242245-89012345-3239842-1001</span><span>

</span><span>PS</span><span>&gt;</span><span> </span><span>$d</span><span> </span><span>=</span><span> </span><span>Get-NtDirectory</span><span> </span><span>"\??"</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>Format-NtSecurityDescriptor</span><span> </span><span>$d</span><span> </span><span>-Summary</span><span>
</span><span>&lt;</span><span>Owner</span><span>&gt;</span><span> </span><span>:</span><span> </span><span>BUILTIN\Administrators</span><span>
</span><span>&lt;</span><span>Group</span><span>&gt;</span><span> </span><span>:</span><span> </span><span>DOMAIN\Domain</span><span> </span><span>Users</span><span>
</span><span>&lt;</span><span>DACL</span><span>&gt;</span><span>
</span><span>NT</span><span> </span><span>AUTHORITY\SYSTEM:</span><span> </span><span>(</span><span>Allowed</span><span>)(</span><span>ObjectInherit</span><span>,</span><span> </span><span>ContainerInherit</span><span>)(</span><span>Full</span><span> </span><span>Access</span><span>)</span><span>
</span><span>BUILTIN\Administrators:</span><span> </span><span>(</span><span>Allowed</span><span>)(</span><span>ObjectInherit</span><span>,</span><span> </span><span>ContainerInherit</span><span>)(</span><span>Full</span><span> </span><span>Access</span><span>)</span><span>
</span><span>BUILTIN\Administrators:</span><span> </span><span>(</span><span>Allowed</span><span>)(</span><span>None</span><span>)(</span><span>Full</span><span> </span><span>Access</span><span>)</span><span>
</span><span>CREATOR</span><span> </span><span>OWNER:</span><span> </span><span>(</span><span>Allowed</span><span>)(</span><span>ObjectInherit</span><span>,</span><span> </span><span>ContainerInherit</span><span>,</span><span> </span><span>InheritOnly</span><span>)(</span><span>GenericAll</span><span>)</span><span>
</span></code></pre></div>

<h2>Creating a DOS Device Object Directory</h2>

<p>A question you might have is who creates this DOS device object directory? It turns out the kernel creates it on demand when the directory is first accessed. The code to do the creation is in <code>SeGetTokenDeviceMap</code>, which looks roughly like the following:</p>

<div><pre><code><span>NTSTATUS</span> <span>SeGetTokenDeviceMap</span><span>(</span><span>PTOKEN</span> <span>Token</span><span>,</span> <span>PDEVICE_MAP</span> <span>*</span><span>ppDeviceMap</span><span>)</span> <span>{</span>
  <span>*</span><span>ppDeviceMap</span> <span>=</span> <span>Token</span><span>-&gt;</span><span>LogonSession</span><span>-&gt;</span><span>pDeviceMap</span><span>;</span>
  <span>if</span> <span>(</span><span>*</span><span>ppDeviceMap</span><span>)</span> <span>{</span>
    <span>return</span> <span>STATUS_SUCCESS</span><span>;</span>
  <span>}</span>
  <span>WCHAR</span> <span>path</span><span>[</span><span>64</span><span>];</span>
    <span>swprintf_s</span><span>(</span>
      <span>path</span><span>,</span>
      <span>64</span><span>,</span>
      <span>L"</span><span>\\</span><span>Sessions</span><span>\\</span><span>0</span><span>\\</span><span>DosDevices</span><span>\\</span><span>%08x-%08x"</span><span>,</span>
      <span>Token</span><span>-&gt;</span><span>AuthenticationId</span><span>.</span><span>HighPart</span><span>,</span>
      <span>Token</span><span>-&gt;</span><span>AuthenticationId</span><span>.</span><span>LowPart</span><span>);</span>
  <span>PUNICODE_STRING</span> <span>PathString</span><span>;</span>
  <span>RtlInitUnicodeString</span><span>(</span><span>&amp;</span><span>PathString</span><span>,</span> <span>path</span><span>);</span>
  <span>OBJECT_ATTRIBUTES</span> <span>ObjectAttributes</span><span>;</span>
  <span>InitializeObjectAttributes</span><span>(</span><span>&amp;</span><span>ObjectAttributes</span><span>,</span> 
                             <span>&amp;</span><span>PathString</span><span>,</span> 
                             <span>OBJ_CASE_INSENSITIVE</span> <span>|</span>
                             <span>OBJ_OPENIF</span> <span>|</span>
                             <span>OBJ_KERNEL_HANDLE</span> <span>|</span>
                             <span>OBJ_PERMANENT</span><span>,</span> <span>0</span><span>,</span> <span>NULL</span><span>);</span>
  <span>HANDLE</span> <span>Handle</span><span>;</span>
  <span>NTSTATUS</span> <span>status</span> <span>=</span> <span>ZwCreateDirectoryObject</span><span>(</span><span>&amp;</span><span>Handle</span><span>,</span> 
                                            <span>0xF000F</span><span>,</span> 
                                            <span>&amp;</span><span>ObjectAttributes</span><span>);</span>
  <span>if</span> <span>(</span><span>NT_ERROR</span><span>(</span><span>status</span><span>))</span> <span>{</span>
    <span>return</span> <span>status</span><span>;</span>
  <span>}</span>
  <span>status</span> <span>=</span> <span>ObpSetDeviceMap</span><span>(</span><span>Token</span><span>-&gt;</span><span>LogonSession</span><span>,</span> <span>Handle</span><span>);</span>
  <span>if</span> <span>(</span><span>NT_ERROR</span><span>(</span><span>status</span><span>))</span> <span>{</span>
    <span>return</span> <span>status</span><span>;</span>
  <span>}</span>
  <span>*</span><span>ppDeviceMap</span> <span>=</span> <span>Token</span><span>-&gt;</span><span>LogonSession</span><span>-&gt;</span><span>pDeviceMap</span><span>;</span>
  <span>return</span> <span>STATUS_SUCCESS</span><span>;</span>
<span>}</span>
</code></pre></div>

<p>One thing you might notice is that the object directory is created using the <code>ZwCreateDirectoryObject</code> system call. One important security detail of using a <code>Zw</code> system call in the kernel is it disables security access checking unless the optional <code>OBJ_FORCE_ACCESS_CHECK</code> flag is set in the <code>OBJECT_ATTRIBUTES</code>, which isn’t the case here.</p>

<p>Bypassing access checking is necessary for this code to function correctly; let’s look at the access control of the <code>\Sessions\0\DosDevices</code> directory.</p>

<div><pre><code><span>PS</span><span>&gt;</span><span> </span><span>Format-NtSecurityDescriptor</span><span> </span><span>-Path</span><span> </span><span>\Sessions\0\DosDevices</span><span> </span><span>-Summary</span><span>
</span><span>&lt;</span><span>Owner</span><span>&gt;</span><span> </span><span>:</span><span> </span><span>BUILTIN\Administrators</span><span>
</span><span>&lt;</span><span>Group</span><span>&gt;</span><span> </span><span>:</span><span> </span><span>NT</span><span> </span><span>AUTHORITY\SYSTEM</span><span>
</span><span>&lt;</span><span>DACL</span><span>&gt;</span><span>
</span><span>NT</span><span> </span><span>AUTHORITY\SYSTEM:</span><span> </span><span>(</span><span>Allowed</span><span>)(</span><span>ObjectInherit</span><span>,</span><span> </span><span>ContainerInherit</span><span>)(</span><span>Full</span><span> </span><span>Access</span><span>)</span><span>
</span><span>BUILTIN\Administrators:</span><span> </span><span>(</span><span>Allowed</span><span>)(</span><span>ObjectInherit</span><span>,</span><span> </span><span>ContainerInherit</span><span>)(</span><span>Full</span><span> </span><span>Access</span><span>)</span><span>
</span><span>CREATOR</span><span> </span><span>OWNER:</span><span> </span><span>(</span><span>Allowed</span><span>)(</span><span>ObjectInherit</span><span>,</span><span> </span><span>ContainerInherit</span><span>,</span><span> </span><span>InheritOnly</span><span>)(</span><span>GenericAll</span><span>)</span><span>
</span></code></pre></div>

<p>The directory cannot be written to by a non-administrator user, but as this code is called in the security context of the user it needs to disable access checking to create the directory as it can’t be sure the user is an administrator. Importantly the access control of the directory has an inheritable rule for the special <code>CREATOR OWNER</code> group granting full access. This is automatically replaced by the assigned owner of the access token used during object creation.</p>

<p>Therefore even though the access checking has been disabled the final directory that’s created can be accessed by the caller. This explains how the UAC administrator DOS device object directory blocks access to the limited user. The administrator token is created with the local administrators group set as its owner and so that’s what <code>CREATOR OWNER</code> is replaced with. However, the limited user can only set their own SID as the owner and so it just grants access to the user.</p>

<p>How is this useful? I noticed a long time ago that this behavior is a potential UAC bypass, in fact it’s a potential EoP, but UAC bypass was the most likely outcome. Specifically it’s possible to get a handle to the access token for the administrator user by calling <code>NtQueryInformationToken</code> with the <code>TokenLinkedToken</code> information class. For security reasons this token is limited to <code>SecurityIdentification</code> impersonation level so it can’t be used to grant access to any resources.</p>

<p>However if you impersonate the token and open the <code>\??</code> directory then the kernel will call <code>SeGetTokenDeviceMap</code> using the identification token and if it’s not currently created it’ll use <code>ZwCreateDirectoryObject</code> to create the DOS device object directory. As access checking is disabled the creation will still succeed, however once it’s created the kernel will do an access check for the directory itself and will fail due to the identification token being impersonated.</p>

<p>This might not seem to get us very much, while the directory is created it’ll use the owner from the identification token which would be the local administrator’s group. But we can change the token’s owner SID to the user’s SID before impersonation, as that’s a permitted operation. Now the final DOS device object directory will be owned by the user and can be written to. As there’s only a single logon session used for the administrator side of UAC then any elevated process can now have its <code>C:</code> directory hijacked.</p>

<p>There’s just one problem with this as a UAC bypass, I could never find a scenario where the limited user got code running before any administrator process was created. Once the process was created and running there’s almost a certainty that some code would open a file and therefore access the <code>\??</code> directory. By the time the limited user has control the DOS device object directory has already been created and assigned the expected access control. Still as UAC is not a security boundary there was no point reporting it, so I filed this behavior away for another day in case it ever became relevant.</p>



<p>Fast forward to today, and along comes Administrator Protection. For reasons of compatibility Microsoft made calling <code>NtQueryInformationToken</code> with the <code>TokenLinkedToken</code> information class still returns an identification handle to the administrator token. But in this case it’s the shadow administrator’s token instead of the administrator version of the user’s token. But a crucial difference is while for UAC this token is the same every time, in Administrator Protection the kernel calls into the LSA and authenticates a new instance of the shadow administrator. This results in every token returned from <code>TokenLinkedToken</code> having a unique logon session, and thus does not currently have the DOS device object directory created as can be seen below:</p>

<div><pre><code><span>PS</span><span>&gt;</span><span> </span><span>$t</span><span> </span><span>=</span><span> </span><span>Get-NtToken</span><span> </span><span>-Linked</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$auth_id</span><span> </span><span>=</span><span> </span><span>Get-NtTokenId</span><span> </span><span>-Authentication</span><span> </span><span>-Token</span><span> </span><span>$t</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$auth_id</span><span>
</span><span>LUID</span><span>
</span><span>----</span><span>
</span><span>00000000</span><span>-01C23BB3</span><span>

</span><span>PS</span><span>&gt;</span><span> </span><span>Get-NtDirectory</span><span> </span><span>"\Sessions\0\DosDevices\</span><span>$auth_id</span><span>"</span><span>
</span><span>Get-NtDirectory</span><span> </span><span>:</span><span> </span><span>(</span><span>0</span><span>xC0000034</span><span>)</span><span> </span><span>-</span><span> </span><span>Object</span><span> </span><span>Name</span><span> </span><span>not</span><span> </span><span>found.</span><span>
</span></code></pre></div>

<p>While in theory we can now force the creation of the DOS device object directory, unfortunately this doesn’t help us much. As the UAC service also uses <code>TokenLinkedToken</code> to get the token to create the new process with it means every administrator process currently running or will run in the future doesn’t share logon sessions, thus doesn’t share the same DOS device object directories and we can’t hijack their <code>C:</code> drives using the token we queried in our own process.</p>

<p>To exploit this we’d need to use the token for an actual running process. This is possible, because when creating an elevated process it can be started suspended. With this suspended process we can open the process token for reading, duplicate it as an identification token then create the DOS device object directory while impersonating it. The process can then be resumed with its hijacked <code>C:</code> drive.</p>

<p>There’s only two problems with this as a bypass, first creating an elevated process suspended will require clicking through an elevation prompt. For UAC with auto-elevation this wasn’t a problem, but for Administrator Protection it will always prompt, and showing a prompt isn’t considered to be crossing the security boundary. There are ways around this, for example the UAC service exposes the <code>RAiProcessRunOnce</code> API which will run an elevated binary silently. The only problem is the process isn’t suspended and so you’d have to win a race condition to open the process and perform the bypass before any code runs in that process. This is something which should be doable, say by playing with thread priorities to prevent the new process’ main thread from being scheduled.</p>

<p>The second issue seems more of a deal breaker. When setting the owner for an access token it will only allow you to set a SID that’s either the user SID for the token, or a member group that has the <code>SE_GROUP_OWNER</code> flag set. The only group with the owner flag is the local administrators group, and of course the shadow administrator’s SID differs from the limited user’s. Therefore setting either of these SIDs as the owner doesn’t help us when it comes to accessing the directory after creation.</p>

<p>Turns out this isn’t a problem as I was not telling the whole truth about the owner assignment process. When building the access control for a new object the kernel doesn’t trust the impersonation token if it’s at identification level. This is for a good security reason, an identification token is not supposed to be usable to make access control decisions, therefore it makes no sense to assign its owner when creating the object. Instead the kernel uses the primary token of the process to make that decision, and so the assigned owner is the limited user’s SID. In fact setting the owner SID for the UAC bypass was never necessary, it was never used. You can verify this behavior by creating an object without a name so that it can be created while impersonating an identification token and checking the assigned owner SID:</p>

<div><pre><code><span>PS</span><span>&gt;</span><span> </span><span>$t</span><span> </span><span>=</span><span> </span><span>Get-NtToken</span><span> </span><span>-Anonymous</span><span>
</span><span># Impersonate anonymous token and create directory</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$d</span><span> </span><span>=</span><span> </span><span>Invoke-NtToken</span><span> </span><span>$t</span><span> </span><span>{</span><span> </span><span>New-NtDirectory</span><span> </span><span>}</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$d</span><span>.</span><span>SecurityDescriptor</span><span>.</span><span>Owner</span><span>.</span><span>Sid</span><span>.</span><span>Name</span><span>
</span><span>NT</span><span> </span><span>AUTHORITY\ANONYMOUS</span><span> </span><span>LOGON</span><span>
</span><span># Impersonate at identification level</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$d</span><span> </span><span>=</span><span> </span><span>Invoke-NtToken</span><span> </span><span>$t</span><span> </span><span>-ImpersonationLevel</span><span> </span><span>Identification</span><span> </span><span>{</span><span>
      </span><span>New-NtDirectory</span><span>
</span><span>}</span><span>
</span><span>PS</span><span>&gt;</span><span> </span><span>$d</span><span>.</span><span>SecurityDescriptor</span><span>.</span><span>Owner</span><span>.</span><span>Sid</span><span>.</span><span>Name</span><span>
</span><span>DOMAIN\user</span><span>
</span></code></pre></div>

<p>One final question you might have is how come creating a process with the shadow admin’s token doesn’t end up accessing some DOS drive’s file resource as that user thus causing the DOS device object directory to be created? The implementation of the <code>CreateProcessAsUser</code> API runs all its code in the security context of the caller, regardless of what access token is being assigned so by default it wouldn’t ever open a file under the new logon session.</p>

<p>However, if you know about how to securely create a process in a system service you might expect that you’re supposed to impersonate the new token over the call to <code>CreateProcessAsUser</code> to ensure you don’t allow a user to create a process for an executable file they can’t access. The UAC service is doing this correctly, so surely it must have accessed a drive to create the process and the DOS device object directory should have been created, why isn’t it?</p>

<p>In a small irony what’s happening is the UAC service is tripping over a recently introduced security mitigation to prevent the hijack of the <code>C:</code> drive when impersonating a low privileged user in a system service. This mitigation kicks in if the caller of a system call is the <code>SYSTEM</code> user and it’s trying to access the <code>C:</code> drive. This was added by Microsoft in response to multiple vulnerabilities in manifest file parsing, if you want an overview <a href="https://www.youtube.com/watch?v=H03b0UaogVs">here’s a video</a> of the talk me and Maddie Stone did at OffensiveCon 23 describing some of the attack surface.</p>

<p>It just so happens that the UAC service is running as <code>SYSTEM</code> and as long as the elevated executable is on the <code>C:</code> drive, which is very likely, the mitigation ignores the impersonated token’s DOS device object directory entirely. Thus <code>SeGetTokenDeviceMap</code> never gets calls and so the first time a file is accessed under the logon session is once the process is up and running. As long as we can perform the exploit before the new process touches a file we can create the DOS device object directory and redirect the process’ <code>C:</code> drive.</p>

<p>To conclude, the steps to exploit this bypass is as follows:</p>

<ol>
  <li>Spawn a shadow admin process through <code>RAiProcessRunOnce</code>, which will run the <code>runonce.exe</code> from the <code>C:</code> drive.</li>
  <li>Open the new process before it has accessed a file resource, and query the primary token.</li>
  <li>Duplicate the token to an identification token.</li>
  <li>Force the DOS device object directory to be created while impersonating the shadow admin token. This can be done by opening <code>\??</code> through a call to <code>NtOpenDirectoryObject</code>.</li>
  <li>Create a C: drive symlink in the new DOS device directory to hijack the system drive.</li>
  <li>Let the process resume and wait for a redirected DLL to be loaded.</li>
</ol>

<h2>Final Thoughts</h2>

<p>The bypass was interesting because it’s hard to point to the specific bug that causes it. The vulnerability is a result of 5 separate OS behaviors:</p>

<ul>
  <li>The Administrator Protection feature changes to the <code>TokenLinkedToken</code> query generates a new logon session for every shadow admin token.</li>
  <li>The per-token DOS device directory is lazily initialized for each new logon session meaning when the linked token is first created the directory does not currently exist.</li>
  <li>The kernel creates the DOS device directory when it’s accessed by using <code>Zw</code> functions, which disables access checking. This allows a limited user to impersonate the shadow admin token at identification level and create the directory by opening <code>\??</code>.</li>
  <li>If a thread impersonates a token at identification level any security descriptor assignment takes the owner SID from the primary token, not the impersonation token. This results in the limited user being granted full access to the shadow admin token’s DOS device object directory.</li>
  <li>The DOS device object directory isn’t already created once the low-privileged user gets access to the process token because of the security mitigation which disables the impersonated DOS device object directory when opening files from the <code>C:</code> drive in a <code>SYSTEM</code> process.</li>
</ul>

<p>I don’t necessarily blame Microsoft for not finding this issue during testing. It’s a complex vulnerability with many moving pieces. It’s likely I only found it because I knew about the weird behavior when creating the DOS device object directory.</p>

<p>The fix Microsoft implemented was to prevent creating the DOS device object directory when impersonating a shadow administrator token at identification level. As this fix was added into the final released build as part of the optional update KB5067036 it doesn’t have a security bulletin associated with it. I would like to thank the Administrator Protection team and MSRC for the quick response in fixing all the issues and demonstrating that this feature will be taken seriously as a security boundary. I’d also like to thank them for providing additional information such as the design document which aided in the research.</p>

<p>As for my views on Administrator Protection as a feature, I feel that Microsoft have not been as bold as they could have been. Making small tweaks to UAC resulted in carrying along the almost 20 years of unfixed bypasses which manifest as security vulnerabilities in the feature. What I would have liked to have seen was something more configurable and controllable, perhaps a proper version of <a href="https://www.tiraniddo.dev/2024/02/sudo-on-windows-quick-rundown.html">sudo</a> or Linux capabilities where a user can be granted specific additional access for certain tasks.</p>

<p>I guess app compatibility is ultimately the problem here, Windows isn’t designed for such a radical change. I’d have also liked to have seen this as a separate configurable mode rather than replacing admin-approval completely. That way a sysadmin could choose when people are opted in to the new model rather than requiring everyone to use it.</p>

<p>I do think it improves security over admin-approval UAC assuming it becomes enabled by default. It presents a more significant security boundary that should be defendable unless more serious design issues are discovered. I expect that malware will still be able to get administrator privileges even if that’s just by forcing a user to accept the elevation prompt, but any silent bypasses they might use should get fixed which would be a significant improvement on the current situation. Regardless of all that, the safest way to use Windows is to never run as an administrator, with any version of UAC. And ideally avoid getting malware on your machine in the first place.</p>


        </section>
      </article>
      
      
    </div></div>
  </div>
</body>
</html>