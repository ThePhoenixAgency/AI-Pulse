<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>npm’s Update to Harden Their Supply Chain, and Points to Consider</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.8; color: #e2e8f0; max-width: 800px; margin: 40px auto; padding: 0 20px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.5em; }
  .metadata { color: #94a3b8; font-size: 0.9em; margin-bottom: 2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 1em; }
  img { max-width: 100%; height: auto; border-radius: 8px; }
  a { color: #00d9ff; }
  p { margin-bottom: 1em; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 15px; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 15px; border-radius: 6px; overflow-x: auto; }

  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }

</style>
</head>
<body>
  <h1>npm’s Update to Harden Their Supply Chain, and Points to Consider</h1>
  <div class="metadata">
    Source: The Hacker News | Date: 2/13/2026 | Lang: EN |
    <a href="https://thehackernews.com/2026/02/npms-update-to-harden-their-supply.html" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div>
<p><span><i></i><span>The Hacker News</span><i></i><span>Feb 13, 2026</span></span><span>Supply Chain Security / DevSecOps</span></p></div><div><p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg2f7TicFSKUe4LQJy82mhhepyMplbLHU-VNYpY_gxLvTILbFCviVqGKP4thBHnPvHWaw1EdFBuqDcDePYX1Z76KaB2j0pC8rWGM4eyu8tNLDcy0HChASJSx2zZufWVktAvzIR2yAJGDC0eIpVPV5u5OaAJsYohGS77dRTUcm_q3kl3D-N5hhCJ6XWxz-w/s1600/npm-security.jpg"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEg2f7TicFSKUe4LQJy82mhhepyMplbLHU-VNYpY_gxLvTILbFCviVqGKP4thBHnPvHWaw1EdFBuqDcDePYX1Z76KaB2j0pC8rWGM4eyu8tNLDcy0HChASJSx2zZufWVktAvzIR2yAJGDC0eIpVPV5u5OaAJsYohGS77dRTUcm_q3kl3D-N5hhCJ6XWxz-w/s1600/npm-security.jpg" /></a></p>
<p>In December 2025, in response to the Sha1-Hulud incident, npm completed a <a href="https://github.blog/changelog/2025-12-09-npm-classic-tokens-revoked-session-based-auth-and-cli-token-management-now-available/#if-you-were-still-using-npm-classic-tokens" target="_blank">major authentication overhaul</a> intended to reduce supply-chain attacks. While the overhaul is a solid step forward, the changes don’t make npm projects immune from supply-chain attacks. npm is still susceptible to malware attacks – here’s what you need to know for a safer Node community.</p>
<h2><strong>Let’s start with the original problem</strong></h2>
<p>Historically, npm relied on classic tokens: long-lived, broadly scoped credentials that could persist indefinitely. If stolen, attackers could directly publish malicious versions to the author’s packages (no publicly verifiable source code needed). This made npm a prime vector for supply-chain attacks. Over time, numerous real-world incidents demonstrated this point. Shai-Hulud, Sha1-Hulud, and chalk/debug are examples of recent, notable attacks.</p>

<h2><strong>npm’s solution</strong></h2>
<p>To address this, npm made the following changes:</p>
<ol>
<li>npm revoked all classic tokens and defaulted to session-based tokens instead. The npm team also improved token management. Interactive workflows now use short-lived session tokens (typically two hours) obtained via npm login, which <em>defaults</em> to MFA for publishing. </li>
<li>The npm team also encourages OIDC Trusted Publishing, in which CI systems obtain short-lived, per-run credentials rather than storing secrets at rest.</li>
</ol>
<p>In combination, these practices improve security. They ensure credentials expire quickly and require a second factor during sensitive operations.</p>
<h2><strong>Two important issues remain</strong></h2>
<p>First, people need to remember that the original attack on tools like ChalkJS was a successful MFA phishing attempt on npm’s console. If you look at the original email attached below, you can see it was an MFA-focused phishing email (nothing like trying to do the right thing and still getting burned). The campaign tricked the maintainer into sharing both the user login and one-time password. This means in the future, similar emails could get short-lived tokens, which still give attackers enough time to upload malware (since that would only take minutes).</p>
<p><a href="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjXFQSKG-LeBnnzMYojU9iWdG9dZ0E8eMhNOsR_lxwGOtJmUjU3dirzJq18nER5-x3lXbz38lSKks6VnmauJvvJuDCC4MP6wxWtmVaN5nh2iIei-gqAt8R8BgDUv-oMneR-oRw1r47iH8fdzNi_V7V8lKjg941WGR_XqXlKuQPkuplFLmTTMDGOQshN7XA/s1600/npm.png"><img alt="" src="https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjXFQSKG-LeBnnzMYojU9iWdG9dZ0E8eMhNOsR_lxwGOtJmUjU3dirzJq18nER5-x3lXbz38lSKks6VnmauJvvJuDCC4MP6wxWtmVaN5nh2iIei-gqAt8R8BgDUv-oMneR-oRw1r47iH8fdzNi_V7V8lKjg941WGR_XqXlKuQPkuplFLmTTMDGOQshN7XA/s1600/npm.png" /></a></p>
<p>Second, MFA on publish is optional. Developers can still create 90-day tokens with MFA bypass enabled in the console, which are extremely similar to the classic tokens from before.</p>
<p>These tokens allow you to read and write to a token author’s maintained packages. This means that if bad actors gain access to a maintainer’s console with these token settings, they can publish new, malicious packages (and versions) on that author’s behalf. This circles us back to the original issue with npm before they adjusted their credential policies.</p>
<p>To be clear, more developers using MFA on publish is good news, and future attacks should be fewer and smaller. However, making OIDC and MFA on-publish <em>optional</em> still leaves the core issue unresolved.</p>
<p>In conclusion, if (1) MFA phishing attempts to npm’s console still work and (2) access to the console equals access to publish new packages/versions, then developers need to be aware of the supply-chain risks that still exist.</p>
<h2><strong>Recommendations</strong></h2>
<p>In the spirit of open source security, here are three recommendations that we hope GitHub and npm will consider in the future.</p>
<ol>
<li>Ideally, they continue to push for the ubiquity of OIDC in the long term. OIDC is very hard to compromise and would almost completely erase the issues surrounding supply-chain attacks.</li>
<li>More realistically, enforcing MFA for local package uploads (either via an email code or a one-time password) would further reduce the blast radius of worms like Shai-Hulud. In other words, it would be an improvement to <em>not allow</em> custom tokens that bypass MFA.</li>
<li>At a minimum, it would be nice to add metadata to package releases, so developers can take precautions and avoid packages (or maintainers) who do not take supply chain security measures.</li>
</ol>
<p>In short, npm has taken an important step forward by eliminating permanent tokens and improving defaults. Until short-lived, identity-bound credentials become the norm — and MFA bypass is no longer required for automation — supply-chain risk from compromised build systems remains materially present.</p>
<h2><strong>A new way to do it</strong></h2>
<p>This entire time, we’ve been talking about supply-chain attacks by uploading packages to npm on a maintainer’s behalf. If we could build every npm package from verifiable upstream source code rather than downloading the artifact from npm, we’d be better off. That’s exactly what Chainguard does for its customers with Chainguard Libraries for JavaScript.</p>
<p><a href="https://www.chainguard.dev/unchained/mitigating-malware-in-the-npm-ecosystem-with-chainguard-libraries" target="_blank">We’ve looked at the public database for compromised packages across npm</a> and discovered that for 98.5% of malicious packages, the malware was not present in the upstream source code (just the published artifact). This means an approach of building from source would reduce your attack surface by some 98.5%, based on past data, because Chainguard’s JavaScript repository would never publish the malicious versions available on npm.</p>
<p>In an ideal world, customers are most secure when they use Chainguard Libraries and apply the recommendations above. Per the “Swiss cheese model of security,” all of these features are layers of additive security measures, and companies would be best off using a combination of them.</p>
<p>If you’d like to learn more about Chainguard Libraries for JavaScript, <a href="https://www.chainguard.dev/contact" target="_blank">reach out to our team</a>.</p>
<p><strong>Note:</strong> <em>This article was thoughtfully written and contributed for our audience by Adam La Morre, Senior Solutions Engineer at Chainguard.</em></p>

<p>Found this article interesting? <span>This article is a contributed piece from one of our valued partners.</span> Follow us on <a href="https://news.google.com/publications/CAAqLQgKIidDQklTRndnTWFoTUtFWFJvWldoaFkydGxjbTVsZDNNdVkyOXRLQUFQAQ" target="_blank">Google News</a>, <a href="https://twitter.com/thehackersnews" target="_blank">Twitter</a> and <a href="https://www.linkedin.com/company/thehackernews/" target="_blank">LinkedIn</a> to read more exclusive content we post.</p>
</div></div>
  </div>
</body>
</html>