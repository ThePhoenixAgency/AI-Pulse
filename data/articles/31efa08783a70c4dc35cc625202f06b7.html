<!DOCTYPE html>
<html lang="pt">
<head>
<meta charset="UTF-8">
<title>How LDAP works</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>How LDAP works</h1>
  <div class="metadata">
    Source: Hacker News (nouveautés) | Date: 2/28/2026 10:02:01 AM | <a href="https://growingswe.com/blog/ldap" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: PT
  </div>
  <div class="content">
    <div><div><article><div>
<p>Suppose you're building a company directory. Every employee has a name, an email address, a phone number, a department, a job title. You add people when they join and remove them when they leave. Everyone needs to look each other up constantly: find Alice's email, list everyone in Engineering, check who has VPN access.</p>
<p>You could store all of this in a database, but look at the access pattern. You're doing far more reads than writes. People rarely change departments, but they look each other up hundreds of times a day. You want something optimized for fast lookups, not complex transactions. You want a directory.</p>
<p>A directory is a specialized data store designed for exactly this: storing information about people and things in an organization, and looking it up quickly. LDAP (Lightweight Directory Access Protocol) is the standard protocol for talking to these directories. It was designed in the early 1990s as a simpler alternative to the X.500 Directory Access Protocol, which required the full <span><span>OSI</span></span> networking stack. LDAP runs over <span><span>TCP</span></span> and strips the protocol down to the essentials, which is where "Lightweight" comes from. Almost every large organization uses it, usually without anyone noticing.</p>
<h2><span>A list of people</span><span></span></h2>
<p>The simplest directory is a flat list, where each entry has a name and some associated data. When someone asks "where's Diana?", you start at the top and scan down until you find her.</p>
<p>Try searching the list below, then try adding a duplicate name:</p> <p>You run into two problems right away. Searching is slow: you scan every entry until you find a match, which is fine for six people but painful for sixty thousand. Uniqueness also breaks: add a second Bob Smith (different department, different email) and you can't tell them apart by name alone.</p>
<p>A flat list has no concept of structure. Departments, teams, and locations exist only as text fields on each person, not as organizational containers. You can't ask "show me everyone in Engineering" without scanning every single entry.</p>
<p>So you need structure, a way to organize entries into groups, with groups inside groups.</p>
<p>Toggle between the flat list and a tree view of the same data to see the difference:</p> <p>In the tree view, the structure is explicit. People live under People and groups live under Groups, so if you want everyone in Engineering, you walk directly to the Engineering branch instead of scanning the whole list. The tree also solves the duplicate name problem, because two people named Bob Smith can exist in different branches and their positions in the tree make them unambiguous.</p>
<h2><span>Organizing into a tree</span><span></span></h2>
<p>LDAP directories store data in a tree called the Directory Information Tree, or DIT. The root of the tree represents the organization. Below it, organizational units (OUs) act as containers, and below those, individual entries represent people, groups, services, or anything else the organization needs to track.</p>
<p>Step through the construction of a directory tree below:</p> <p>The root entry uses domain components (<code>dc</code>), so <code>dc=example,dc=com</code> mirrors the organization's <span><span>DNS domain name</span></span> split into parts. Below that, organizational units (<code>ou</code>) group entries by purpose: <code>ou=People</code> for employees, <code>ou=Groups</code> for teams, <code>ou=Services</code> for infrastructure. Individual entries then use common names (<code>cn</code>) like <code>cn=Alice Johnson</code> or <code>cn=Engineering</code>.</p>
<p>These prefixes (<code>dc</code>, <code>ou</code>, <code>cn</code>) are called attribute types. Each node in the tree has a Relative Distinguished Name (RDN), one or more <code>type=value</code> pairs that identify it among its siblings. Most RDNs are single-valued in practice, but multi-valued RDNs are allowed (e.g., <code>cn=Kurt+l=Redwood Shores</code>). <code>cn=Alice Johnson</code> is Alice's RDN within the <code>ou=People</code> container.</p>
<p>But an RDN only identifies a node relative to its parent. If there's a <code>cn=Alice Johnson</code> under <code>ou=People</code> and another under <code>ou=Contractors</code>, the RDN alone isn't enough.</p>
<p>Try finding Alice by her RDN alone:</p> <p>To resolve this, we need a full address.</p>
<h2><span>Naming things in trees</span><span></span></h2>
<p>Click any node in the tree below to see the full path from that node back to the root:</p> <p>The full path from a node to the root, written as a comma-separated list of RDNs, is called the Distinguished Name (DN). Alice's DN is <code>cn=Alice Johnson,ou=People,dc=example,dc=com</code>, which reads left to right from the specific entry (the leaf) to the general (the root), like a file path written backwards.</p>
<p>Every entry in the directory has a unique DN, because no two siblings can share the same RDN. This gives you a global addressing scheme: given a DN, you can navigate from the root, following each component, straight to the entry.</p>
<p>You use the DN to refer to entries in LDAP operations. When you want to read Alice's record, you ask for <code>cn=Alice Johnson,ou=People,dc=example,dc=com</code>. When you want to authenticate as Alice, you bind with her DN.</p>
<h2><span>What's inside an entry</span><span></span></h2>
<p>A DN tells you where an entry lives in the tree. But what does the entry actually contain?</p>
<p>Click different nodes below to explore their attributes:</p> <p>Every entry is a collection of attributes, which are named values. An attribute has a type (like <code>mail</code> or <code>telephoneNumber</code>) and one or more values. Alice has one email address, but a group entry has multiple <code>member</code> values, one per member.</p>
<p>Notice how different types of entries have different attributes. A person entry has <code>mail</code>, <code>telephoneNumber</code>, and <code>title</code>, while an organizational unit entry has just <code>ou</code> and <code>description</code>, and a group entry has <code>member</code> with multiple DNs. What determines which attributes an entry is allowed to have is its object class.</p>
<h2><span>What an entry is allowed to hold</span><span></span></h2>
<p>An object class defines what attributes an entry can (or must) have. Object classes form an inheritance chain, where each class extends the one above it and adds more attributes.</p>
<p>Step through the object class chain below:</p> <p>The base class <code>top</code> requires only <code>objectClass</code> itself. The <code>person</code> class adds <code>cn</code> (common name) and <code>sn</code> (surname) as required attributes, plus optional ones like <code>telephoneNumber</code>. The <code>organizationalPerson</code> class extends that with <code>title</code> and <code>ou</code>, and finally <code>inetOrgPerson</code> (the most commonly used class for people) permits internet-era attributes like <code>mail</code> and <code>uid</code>. These attribute types are defined in other schema RFCs; <code>inetOrgPerson</code> doesn't invent them, it just says that entries of this class are allowed to use them.</p>
<p>An entry can have multiple object classes. A typical person entry lists <code>objectClass: top, person, organizationalPerson, inetOrgPerson</code> and inherits all attributes from the entire chain. The schema is enforced by the server, so if you try to add a <code>mail</code> attribute to an entry that only has the <code>person</code> object class (without <code>inetOrgPerson</code>), the server rejects the operation.</p>
<p>Because of this schema system, the directory is self-describing. A client can query the schema to discover what attributes exist, what object classes are available, and what the rules are.</p>
<h2><span>Finding things</span><span></span></h2>
<p>Looking up entries by DN requires knowing the exact address. In practice, the most common operation is search: "find all engineers," "find everyone whose email contains @example.com," or "find the group called Engineering."</p>
<p>Every LDAP search has three parameters: where to start (the base DN), how far to look (the scope), and what to match (the filter).</p>
<p>Click a node to set the base, then toggle between scopes to see how each one works:</p> <p>Base scope returns only the entry at the base DN itself. One level returns only the direct children of the base entry, without including the base entry itself. Subtree returns the base entry and all of its descendants recursively, which is the scope most real searches use, typically with the root as the base to search the entire directory.</p>
<p>The scope determines which entries are candidates, and the filter narrows them down. Try the preset filters below:</p> <p>Filters use a prefix notation with parentheses. The simplest filter is an equality check: <code>(cn=Alice Johnson)</code> matches entries where the <code>cn</code> attribute equals "Alice Johnson." The presence filter <code>(mail=*)</code> matches any entry that has a <code>mail</code> attribute at all, and substring filters like <code>(title=*Engineer*)</code> match any entry whose title contains "Engineer." You can also combine filters with <code>&amp;</code> (AND) and <code>|</code> (OR), so <code>(&amp;(objectClass=inetOrgPerson)(title=*Engineer*))</code> finds all people whose title contains "Engineer."</p>
<p>Here's a complete search operation. It uses subtree scope from the root with the filter <code>(objectClass=inetOrgPerson)</code>, which matches all person entries:</p> <p>The server walks the tree in order, checking each entry against the filter. Entries that match get added to the result set and entries that don't are skipped, so the final result is the set of all entries in scope that satisfy the filter.</p>
<h2><span>Who gets to see what</span><span></span></h2>
<p>An open directory where anyone can read everything isn't practical. Salary data, private phone numbers, and group memberships all might need to be restricted. LDAP controls access through binding, which is the process of authenticating to the server.</p>
<p>Step through a bind operation below:</p> <p>Before binding, a connection is anonymous. The client sees only what the server's access control rules allow for anonymous users, which is often limited to basic attributes like names and email addresses. To see more, the client sends a bind request containing a DN (identifying who they claim to be) and a password.</p>
<p>The server looks up the entry at that DN, checks the password against the stored <span><span>hash</span></span>, and responds with success or failure. After a successful bind, the connection carries that identity, and what you can read, modify, or delete from that point on depends on the server's access control rules. These rules are vendor-specific; LDAP itself doesn't standardize an <span><span>ACL</span></span> mechanism.</p>
<p>A simple bind sends the password in the clear, so in production you always wrap the connection in <span><span>TLS</span></span>. You can do this with <span><span>LDAPS</span></span> (on port 636) or the <span><span>StartTLS</span></span> extended operation, which upgrades a plain connection to TLS in-place on the standard port 389.</p>
<p>Try toggling between a correct and incorrect password in the demo above and notice how a failed bind leaves the connection anonymous.</p>
<h2><span>Where LDAP lives today</span><span></span></h2>
<p>LDAP is invisible infrastructure. It underpins directory lookups and authentication flows across corporate networks, often without anyone realizing it's there.</p>
<p>When you type your username and password at a company login screen, the application often searches the LDAP directory for your username, gets back your DN, then attempts a bind with your DN and password. If the bind succeeds, you're in. OS-level domain logon usually uses <span><span>Kerberos</span></span> or <span><span>NTLM</span></span> instead of a simple LDAP bind, but the directory behind those protocols is the same. That's why changing your password in one place (the directory) changes it everywhere: every application authenticates against the same directory.</p>
<p>Active Directory, Microsoft's directory service, is the most widely deployed LDAP server. It powers authentication and authorization for most corporate Windows environments. OpenLDAP is the most common open-source implementation, used in Linux environments and cloud infrastructure. Cloud providers offer managed LDAP services: AWS Managed Microsoft AD, Microsoft Entra Domain Services, and Google's Cloud Identity Secure LDAP (for connecting apps) or Managed Service for Microsoft Active Directory (for managed AD with LDAP/LDAPS).</p>
<p>Beyond authentication, directories are the source of truth for organizational data. Email clients query LDAP for address books, VPN servers check group membership to decide who gets access, and HR systems sync employee records to the directory. <span><span>Single sign-on</span></span> systems use it as the identity backend.</p>
<p>The protocol itself is simple: connect, bind, search, compare, add, modify, delete, unbind. What makes it useful is the data model, with its tree structure, schema enforcement, and DN addressing, combined with the fact that everyone agrees to use the same one.</p></div></article></div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>