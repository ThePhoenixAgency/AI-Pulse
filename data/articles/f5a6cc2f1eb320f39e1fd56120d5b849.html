<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Microsoft annonce la version Beta de TypeScript 6.0 apportant des am�liorations aux fonctions sensibles au contexte ainsi que la prise en charge des importations de sous-chemins</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Microsoft annonce la version Beta de TypeScript 6.0 apportant des am�liorations aux fonctions sensibles au contexte ainsi que la prise en charge des importations de sous-chemins</h1>
  <div class="metadata">
    Source: Developpez.com | Date: 2/13/2026 1:46:00 PM | <a href="https://typescript.developpez.com/actu/380244/Microsoft-annonce-la-version-Beta-de-TypeScript-6-0-apportant-des-ameliorations-aux-fonctions-sensibles-au-contexte-ainsi-que-la-prise-en-charge-des-importations-de-sous-chemins/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: FR
  </div>
  <div class="content">
    <div><div> <p><img src="https://www.developpez.com/images/logos/typescript.png"> <b>Microsoft annonce la version Beta de TypeScript 6.0. Voici quelques-uns des points forts de cette version : moins de sensibilit� au contexte pour les fonctions sans this, importations de sous-chemins commen�ant par #/, combinaison de --moduleResolution bundler avec --module commonjs, le drapeau --stableTypeOrdering, l'option es2025 pour target et lib, entre autres. TypeScript 6.0 est une version unique en son genre, car son �quipe a l'intention d'en faire la derni�re version bas�e sur le code source JavaScript actuel. Comme annonc� en 2025, ils travaillent sur un nouveau code source pour le compilateur TypeScript et le service linguistique �crit en Go qui tire parti de la vitesse du code natif et du multithreading � m�moire partag�e.</b></p><p>TypeScript est un langage qui s'appuie sur JavaScript en ajoutant une syntaxe pour les types. L'�criture de types dans le code permet d'expliquer l'intention et de faire v�rifier le code par d'autres outils pour d�tecter les erreurs comme les fautes de frappe, les probl�mes avec <span>null</span> et <span>undefined</span>, et plus encore. Les types alimentent �galement les outils d'�dition de TypeScript, comme l'auto-compl�tion, la navigation dans le code et les refactorisations que vous pouvez voir dans des �diteurs tels que Visual Studio et VS Code. En fait, TypeScript et son �cosyst�me alimentent l'exp�rience JavaScript dans ces deux �diteurs �galement.</p><p>TypeScript 6.0 est une version unique en son genre, car son �quipe a l'intention d'en faire la derni�re version bas�e sur le code source JavaScript actuel. Comme annonc� en 2025, ils travaillent sur un nouveau code source pour le compilateur TypeScript et le service linguistique �crit en Go qui tire parti de la vitesse du code natif et du multithreading � m�moire partag�e. Cette nouvelle base de code constituera le fondement de TypeScript 7.0 et des versions ult�rieures. TypeScript 6.0 sera le pr�curseur imm�diat de cette version et, � bien des �gards, il servira de pont entre TypeScript 5.9 et 7.0. � ce titre, la plupart des changements apport�s � TypeScript 6.0 visent � faciliter l'alignement et la pr�paration � l'adoption de TypeScript 7.0.</p><p><img src="https://www.developpez.net/forums/attachments/p674204d1/a/a/a"></p><p>
Voici quelques-uns des points forts de cette version, avec des d�tails sur ce qui va changer dans la version 7.0 :</p><p><b><span>Moins de sensibilit� au contexte pour les fonctions sans this</span></b></p><p>Lorsque les param�tres n'ont pas de types explicites, TypeScript peut g�n�ralement les d�duire en fonction d'un type attendu, ou m�me � partir d'autres arguments dans le m�me appel de fonction.</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br></p></td><td><pre><span>declare</span> <span>function</span> callIt<span>&lt;</span>T<span>&gt;</span><span>(</span>obj<span>:</span> <span>{</span> produce<span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>=&gt;</span> T<span>,</span> consume<span>:</span> <span>(</span>y<span>:</span> T<span>)</span> <span>=&gt;</span> <span>void</span><span>,</span> <span>}</span><span>)</span><span>:</span> <span>void</span><span>;</span> &nbsp; <span>// Works, no issues.</span> callIt<span>(</span><span>{</span> produce<span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>=&gt;</span> x <span>*</span> <span>2</span><span>,</span> consume<span>:</span> y <span>=&gt;</span> y.<span>toFixed</span><span>(</span><span>)</span><span>,</span> <span>}</span><span>)</span><span>;</span> &nbsp; <span>// Works, no issues even though the order of the properties is flipped.</span> callIt<span>(</span><span>{</span> consume<span>:</span> y <span>=&gt;</span> y.<span>toFixed</span><span>(</span><span>)</span><span>,</span> produce<span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>=&gt;</span> x <span>*</span> <span>2</span><span>,</span> <span>}</span><span>)</span><span>;</span></pre></td></tr></tbody></table></pre></div><p>Ici, TypeScript peut d�duire le type de <span>y</span> dans la fonction <span>consume</span> en se basant sur le type <span>T</span> d�duit de la fonction <span>produce</span>, quel que soit l'ordre des propri�t�s. Mais qu'en est-il si ces fonctions ont �t� �crites en utilisant la syntaxe de m�thode plut�t que la syntaxe de fonction fl�ch�e ?</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br></p></td><td><pre><span>declare</span> <span>function</span> callIt<span>&lt;</span>T<span>&gt;</span><span>(</span>obj<span>:</span> <span>{</span> produce<span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>=&gt;</span> T<span>,</span> consume<span>:</span> <span>(</span>y<span>:</span> T<span>)</span> <span>=&gt;</span> <span>void</span><span>,</span> <span>}</span><span>)</span><span>:</span> <span>void</span><span>;</span> &nbsp; <span>// Works fine, `x` is inferred to be a number.</span> callIt<span>(</span><span>{</span> produce<span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>{</span> <span>return</span> x <span>*</span> <span>2</span><span>;</span> <span>}</span><span>,</span> consume<span>(</span>y<span>)</span> <span>{</span> <span>return</span> y.<span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>,</span> <span>}</span><span>)</span><span>;</span> &nbsp; callIt<span>(</span><span>{</span> consume<span>(</span>y<span>)</span> <span>{</span> <span>return</span> y.<span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>,</span> <span>// ~</span> <span>// error: 'y' is of type 'unknown'.</span> &nbsp; produce<span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>{</span> <span>return</span> x <span>*</span> <span>2</span><span>;</span> <span>}</span><span>,</span> <span>}</span><span>)</span><span>;</span></pre></td></tr></tbody></table></pre></div><p>Curieusement, le deuxi�me appel � <span>callIt</span> g�n�re une erreur, car TypeScript n'est pas en mesure de d�duire le type de y dans la m�thode <span>consume</span>. Ce qui se passe ici, c'est que lorsque TypeScript essaie de trouver des candidats pour <span>T</span>, il ignore d'abord les fonctions dont les param�tres n'ont pas de types explicites. Il proc�de ainsi parce que certaines fonctions peuvent avoir besoin que le type d�duit de <span>T</span> soit correctement v�rifi�. Dans ce cas, on a besoin de conna�tre le type de <span>T</span> pour analyser la fonction <span>consume</span>.</p><p>Ces fonctions sont appel�es fonctions sensibles au contexte, c'est-�-dire des fonctions dont les param�tres n'ont pas de types explicites. Au final, le syst�me de types devra d�terminer les types de ces param�tres, mais cela va � l'encontre du fonctionnement de l'inf�rence dans les fonctions g�n�riques, car les deux � tirent � les types dans des directions diff�rentes.</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></p></td><td><pre><span>function</span> callFunc<span>&lt;</span>T<span>&gt;</span><span>(</span>callback<span>:</span> <span>(</span>x<span>:</span> T<span>)</span> <span>=&gt;</span> <span>void</span><span>,</span> value<span>:</span> T<span>)</span> <span>{</span> <span>return</span> callback<span>(</span>value<span>)</span><span>;</span> <span>}</span> &nbsp; callFunc<span>(</span>x <span>=&gt;</span> x.<span>toFixed</span><span>(</span><span>)</span><span>,</span> <span>42</span><span>)</span><span>;</span> <span>// ^</span> <span>// We need to figure out the type of `x` here,</span> <span>// but we also need to figure out the type of `T` to check the callback.</span></pre></td></tr></tbody></table></pre></div><p>Pour r�soudre ce probl�me, TypeScript ignore les fonctions sensibles au contexte lors de l'inf�rence des arguments de type et v�rifie et inf�re d'abord � partir d'autres arguments. Si le fait d'ignorer les fonctions sensibles au contexte ne fonctionne pas, l'inf�rence se poursuit simplement sur tous les arguments non v�rifi�s, en allant de gauche � droite dans la liste des arguments. Dans l'exemple ci-dessus, TypeScript ignorera le rappel lors de l'inf�rence pour <span>T</span>, mais examinera ensuite le deuxi�me argument, <span>42</span>, et en d�duira que <span>T</span> est un nombre. Ensuite, lorsqu'il reviendra v�rifier le rappel, il aura un type contextuel de <span>(x: nombre) =&gt; void</span>, ce qui lui permettra de d�duire que x est �galement un nombre.</p><p>Que se passe-t-il donc dans nos exemples pr�c�dents ?</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br></p></td><td><pre><span>// Arrow syntax - no errors.</span> callIt<span>(</span><span>{</span> consume<span>:</span> y <span>=&gt;</span> y.<span>toFixed</span><span>(</span><span>)</span><span>,</span> produce<span>:</span> <span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>=&gt;</span> x <span>*</span> <span>2</span><span>,</span> <span>}</span><span>)</span><span>;</span> &nbsp; <span>// Method syntax - errors!</span> callIt<span>(</span><span>{</span> consume<span>(</span>y<span>)</span> <span>{</span> <span>return</span> y.<span>toFixed</span><span>(</span><span>)</span><span>;</span> <span>}</span><span>,</span> <span>// ~</span> <span>// error: 'y' is of type 'unknown'.</span> &nbsp; produce<span>(</span>x<span>:</span> <span>number</span><span>)</span> <span>{</span> <span>return</span> x <span>*</span> <span>2</span><span>;</span> <span>}</span><span>,</span> <span>}</span><span>)</span><span>;</span></pre></td></tr></tbody></table></pre></div><p>Dans les deux exemples, une fonction avec un param�tre x explicitement typ� est attribu�e � <span>produce</span>. Ne devraient-ils pas �tre v�rifi�s de mani�re identique ?</p><p>La question est subtile : la plupart des fonctions (comme celles qui utilisent la syntaxe de m�thode) ont un param�tre <span>this</span> implicite, mais ce n'est pas le cas des fonctions fl�ch�es. Toute utilisation de <span>this</span> pourrait n�cessiter de � tirer � sur le type de <span>T</span>. Par exemple, conna�tre le type de l'objet litt�ral contenant pourrait � son tour n�cessiter le type de <span>consume</span>, qui utilise <span>T</span>.</p><p>Mais nous n'utilisons pas <span>this</span> ! Bien s�r, la fonction peut avoir une valeur <span>this</span> lors de l'ex�cution, mais elle n'est jamais utilis�e !</p><p>TypeScript 6.0 en tient compte lorsqu'il d�cide si une fonction est sensible au contexte ou non. Si this n'est jamais r�ellement utilis� dans une fonction, alors il n'est pas consid�r� comme sensible au contexte. Cela signifie que ces fonctions seront consid�r�es comme ayant une priorit� plus �lev�e en mati�re d'inf�rence de type, et tous nos exemples ci-dessus fonctionnent d�sormais !</p><p><b><span>Importations de sous-chemins commen�ant par #/</span></b></p><p>Lorsque Node.js a ajout� la prise en charge des modules, il a ajout� une fonctionnalit� appel�e � importations de sous-chemins �. Il s'agit essentiellement d'un champ appel� imports qui permet aux paquets de cr�er des alias internes pour les modules au sein de leur paquet.</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></p></td><td><pre><span>{</span> <span>"name"</span><span>:</span> <span>"my-package"</span><span>,</span> <span>"type"</span><span>:</span> <span>"module"</span><span>,</span> <span>"imports"</span><span>:</span> <span>{</span> <span>"#root"</span><span>:</span> <span>"./dist/index.js"</span><span>,</span> <span>"#root/*"</span><span>:</span> <span>"./dist/*"</span> <span>}</span> <span>}</span></pre></td></tr></tbody></table></pre></div><p>Cela permet aux modules de <span>my-package</span> d'importer � partir de <span>#root</span> au lieu d'avoir � utiliser un chemin relatif comme <span>../../index.js</span>, et permet essentiellement � tout autre module d'�crire quelque chose comme</p><div> <pre><span>import</span> <span>*</span> <span>as</span> utils <span>from</span> <span>"#root/utils.js"</span><span>;</span></pre></div><p>au lieu d'utiliser un chemin relatif comme celui-ci.</p><div> <pre><span>import</span> <span>*</span> <span>as</span> utils <span>from</span> <span>"../../utils.js"</span><span>;</span></pre></div><p>Un inconv�nient mineur de cette fonctionnalit� est que les d�veloppeurs devaient toujours �crire quelque chose apr�s le <span>#</span> lorsqu'ils sp�cifiaient une importation de sous-chemin. Ici, on utilise <span>root</span>, mais cela est un peu inutile puisqu'il n'y a pas d'autre r�pertoire que <span>./dist/</span> sur lequel nous effectuons le mappage.</p><p>Les d�veloppeurs qui ont utilis� des bundlers sont �galement habitu�s � utiliser le mappage de chemins pour �viter les longs chemins relatifs. Une convention courante avec les bundlers consiste � utiliser un simple <span>@/</span> comme pr�fixe. Malheureusement, les importations de sous-chemins ne pouvaient pas commencer par <span>#/</span>, ce qui causait beaucoup de confusion pour les d�veloppeurs qui essayaient de les adopter dans leurs projets.</p><p>Mais plus r�cemment, Node.js a ajout� la prise en charge des importations de sous-chemins commen�ant par <span>#/</span>. Cela permet aux paquets d'utiliser un simple pr�fixe <span>#/</span> pour leurs importations de sous-chemins sans avoir � ajouter de segment suppl�mentaire.</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br></p></td><td><pre><span>{</span> <span>"name"</span><span>:</span> <span>"my-package"</span><span>,</span> <span>"type"</span><span>:</span> <span>"module"</span><span>,</span> <span>"imports"</span><span>:</span> <span>{</span> <span>"#"</span><span>:</span> <span>"./dist/index.js"</span><span>,</span> <span>"#/*"</span><span>:</span> <span>"./dist/*"</span> <span>}</span> <span>}</span></pre></td></tr></tbody></table></pre></div><p>Cette fonctionnalit� est prise en charge dans les nouvelles versions de Node.js 20. TypeScript la prend donc d�sormais en charge dans les options <span>node20</span>, <span>nodenext</span> et <span>bundler</span> pour le param�tre <span>--moduleResolution</span>.</p><p><b><span>Combinaison de --moduleResolution bundler avec --module commonjs</span></b></p><p>Le param�tre <span>--moduleResolution bundler</span> de TypeScript ne pouvait auparavant �tre utilis� qu'avec <span>--module esnext</span> ou <span>--module preserve</span> ; cependant, avec la d�pr�ciation du n�ud <span>--moduleResolution</span> (alias <span>--moduleResolution node10</span>), cette nouvelle combinaison est souvent la voie de mise � niveau la plus appropri�e pour de nombreux projets.</p><p>Les projets voudront souvent planifier une migration vers l'un des deux �l�ments suivants</p><p>- <span>--module preserve</span> et <span>--moduleResolution bundler</span>.<br>
- <span>--module nodenext</span>.</p><p>en fonction du type de projet (par exemple, application web group�e, application Bun ou application Node.js).</p><p><b><span>Le drapeau --stableTypeOrdering</span></b></p><p>Dans le cadre du travail continu sur le portage natif de TypeScript, l'�quipe de typeScprit a introduit un nouveau drapeau appel� <span>--stableTypeOrdering</span> destin� � faciliter les migrations de la version 6.0 � la version 7.0.</p><p>Aujourd'hui, TypeScript attribue des identifiants de type (num�ros de suivi internes) aux types dans l'ordre o� ils apparaissent, et utilise ces identifiants pour trier les types d'union de mani�re coh�rente. Un processus similaire s'applique aux propri�t�s. Par cons�quent, l'ordre dans lequel les �l�ments sont d�clar�s dans un programme peut avoir des effets surprenants sur des �l�ments tels que l'�mission de d�clarations.</p><p>Prenons par exemple l'�mission de d�clarations � partir de ce fichier :</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br></p></td><td><pre><span>// Input: some-file.ts</span> <span>export</span> <span>function</span> foo<span>(</span>condition<span>:</span> <span>boolean</span><span>)</span> <span>{</span> <span>return</span> condition <span>?</span> <span>100</span> <span>:</span> <span>500</span><span>;</span> <span>}</span> &nbsp; <span>// Output: some-file.d.ts</span> <span>export</span> <span>declare</span> <span>function</span> foo<span>(</span>condition<span>:</span> <span>boolean</span><span>)</span><span>:</span> <span>100</span> <span>|</span> <span>500</span><span>;</span> <span>// ^^^^^^^^^</span> <span>// Note the order of this union: 100, then 500.</span></pre></td></tr></tbody></table></pre></div><p>Si nous ajoutons une constante non li�e au-dessus de <span>foo</span>, la d�claration �mise change :</p><div> <pre><table><tbody><tr><td><p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br></p></td><td><pre><span>// Input: some-file.ts</span> <span>const</span> x <span>=</span> <span>500</span><span>;</span> <span>export</span> <span>function</span> foo<span>(</span>condition<span>:</span> <span>boolean</span><span>)</span> <span>{</span> <span>return</span> condition <span>?</span> <span>100</span> <span>:</span> <span>500</span><span>;</span> <span>}</span> &nbsp; <span>// Output: some-file.d.ts</span> <span>export</span> <span>declare</span> <span>function</span> foo<span>(</span>condition<span>:</span> <span>boolean</span><span>)</span><span>:</span> <span>500</span> <span>|</span> <span>100</span><span>;</span> <span>// ^^^^^^^^^</span> <span>// Note the change in order here.</span></pre></td></tr></tbody></table></pre></div><p>Cela se produit parce que le type litt�ral <span>500</span> obtient un ID de type inf�rieur � <span>100</span>, car il a �t� trait� en premier lors de l'analyse de la d�claration de la <span>const x</span>. Dans de tr�s rares cas, ce changement d'ordre peut m�me entra�ner l'apparition ou la disparition d'erreurs en fonction de l'ordre de traitement du programme, mais en g�n�ral, c'est principalement dans les fichiers de d�claration �mis ou dans la fa�on dont les types sont affich�s dans votre �diteur que vous remarquerez cet ordre.</p><p>L'une des principales am�liorations architecturales de TypeScript 7 est la v�rification parall�le des types, qui r�duit consid�rablement le temps de v�rification global. Cependant, le parall�lisme pose un d�fi : lorsque diff�rents v�rificateurs de types visitent les n�uds, les types et les symboles dans des ordres diff�rents, les identifiants internes attribu�s � ces constructions deviennent non d�terministes. Cela conduit � des r�sultats non d�terministes pr�tant � confusion, o� deux fichiers au contenu identique dans le m�me programme peuvent produire des fichiers de d�claration diff�rents, voire calculer des erreurs diff�rentes lors de l'analyse du m�me fichier. Pour rem�dier � cela, TypeScript 7.0 trie ses objets internes (par exemple, les types et les symboles) selon un algorithme d�terministe bas� sur le contenu de l'objet. Cela garantit que tous les v�rificateurs rencontrent le m�me ordre d'objets, ind�pendamment de la mani�re et du moment o� ils ont �t� cr��s. En cons�quence, dans l'exemple donn�, TypeScript 7 affichera toujours <span>100 | 500</span>, supprimant ainsi compl�tement l'instabilit� de l'ordre.</p><p>Cela signifie que TypeScript 6 et 7 peuvent parfois afficher un ordre diff�rent. Bien que ces changements d'ordre soient presque toujours b�nins, si vous comparez les r�sultats du compilateur entre deux ex�cutions (par...
</p><p>La fin de cet article est r�serv�e aux abonn�s. Soutenez le Club Developpez.com en <a href="https://premium.developpez.com/abonnement">prenant un abonnement</a> pour que nous puissions continuer � vous proposer des publications.</p> </div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
  </script>
</body>
</html>