<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Gotta cache 'em all: bending the rules of web cache exploitation</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
</style>
</head>
<body>
  <h1>Gotta cache 'em all: bending the rules of web cache exploitation</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 8/9/2024 12:27:46 AM | Lang: EN |
    <a href="https://portswigger.net/research/gotta-cache-em-all" target="_blank">Original Article</a>
  </div>
  <div class="content">
    <div><div> <div> <p><img alt="Martin Doyhenard" src="https://portswigger.net/content/images/logos/portswigger-logo.jpg"></p>
</div> <ul> <li> <p><span></span><strong>Published: </strong>08 August 2024 at 22:27 UTC</p> </li> <li> <p><strong>Updated: </strong>08 January 2026 at 12:21 UTC</p> </li> <li> </li> </ul> <p><img src="https://portswigger.net/cms/images/93/82/c528-article-gotta-cache-em-all-image-article.png" alt="evil keys used to obtain secrets"><br></p><p>Through the years, we have seen many attacks exploiting web caches to hijack sensitive information or store malicious payloads.<br>However, as CDNs became more popular, new discrepancies between proprietary URL parsers prove that we have only seen the tip of the iceberg.
</p><p>In this paper will explore how different HTTP servers and proxies behave when parsing specially crafted URLs and explore ambiguities in the RFC that lead to path confusion. It will also introduce a set of novel techniques that can be used to leverage parser discrepancies and achieve arbitrary <a href="https://portswigger.net/web-security/web-cache-poisoning">web cache poisoning</a> and deception in countless websites and CDN providers.<br></p><p>This research is also available in <a href="https://portswigger.net/kb/papers/kapvrid/gotta-cache-em-all.pdf">print/download-friendly PDF</a> format
</p><p>You can also watch the recording of my DEFCON presentation here:</p><p></p><h2>Outline</h2><ul> <li><a href="#background">Background</a></li> <ul> <li><a href="#webcaches">Web caches</a></li> <li><a href="#poisondeception">Poisoning and deception</a></li> </ul> <li><a href="#urldiscrepancies">URL discrepancies</a></li> <ul> <li><a href="#delimiters">Delimiters</a></li> <li><a href="#normalization">Normalization</a></li> </ul> <li><a href="#cachedeception">Arbitrary Web Cache Deception</a></li> <ul> <li><a href="#limitations">Limitations</a></li> <li><a href="#extensions">Static extensions</a></li> <li><a href="#directories">Static directories</a></li> <li><a href="#files">Static files</a></li> </ul> <li><a href="#cachepoisoning">Arbitrary Web Cache Poisoning</a></li> <ul> <li><a href="#keynormalization">Key normalization</a></li> <li><a href="#backdelimiters">Exploiting back-end delimiters</a></li> <li><a href="#frontdelimiters">Exploiting front-end delimiters</a></li> </ul> <li><a href="#whatwhere">Cache-What-Where</a></li> <li><a href="#defence">Defence</a></li>
</ul>
<h2><a>Background</a></h2>
<h3><a>Web caches</a></h3>
<p>Web caches have been around since the beginning of the internet. This technology works by fingerprinting requests using a key, which in most cases will be built using some or all parts of the requested URL, and mapping the key with stored static responses.</p>
<p>In recent years, most productive systems incorporate caching by setting Content Delivery Networks (CDNs) with providers like CloudFlare, Akamai, or CloudFront. CDNs can be seen as a network of web cache proxies that are distributed around the globe. They serve static responses, increasing the efficiency and scalability of a system.</p>
<p>This paper focuses on URL parsing discrepancies that exist between different application servers and CDN proxies, but the same techniques can be applied to any type of web cache, including those integrated in the origin server itself.</p>
<h3><a>Poisoning and deception</a></h3>
<p>As web caches play a crucial role in modern systems, researchers have looked for ways to exploit them to store dynamic information. This information could be used to obtain sensitive data or deliver malicious payloads. These attacks typically target one of two processes: key generation or cache rule analysis.</p>
<p>Calculating the key is crucial as every request with the same fingerprint should generate the same response, regardless of when it was sent or what additional information it contains (like body or extra headers). If the response varies based on the value of a specific header, then that value should be part of the key. Storing a message with a malicious payload intended to match an incorrect key is called <a href="https://portswigger.net/web-security/web-cache-poisoning">web cache poisoning</a>.</p>
<p>Cache rules are designed to recognize if a response is static and should be stored. Failing to cache a static resource can affect performance, but storing a dynamic response with sensitive information meant for an authenticated user can be devastating for an application. If an attacker can craft a malicious request that retrieves and caches user data, they may be able to hijack tokens and API keys, potentially leading to a full account takeover. This is known as <a href="https://portswigger.net/web-security/web-cache-deception">web cache deception</a>.</p> <h2><a>URL discrepancies</a></h2>
<p>To evaluate cache rules, calculate cache keys, and map endpoint handlers, the origin server must extract the absolute path of the requested resource. This is done by parsing the URL using path delimiters and normalization.</p>
<p>If the cache and application server’s parsers are different, it may be possible to use a discrepancy to change the meaning of the URL. This may enable you to control which responses are stored and the key that is used to access them.</p>
<h3><a>Delimiters</a></h3>
<p>The URL RFC defines certain characters as delimiters, for example the semicolon or question mark. However the specification is quite permissive and allows each implementation to add custom characters to this list.</p>
<p>This research showed that many popular frameworks and HTTP servers use different characters as delimiters. This can create path confusion between the origin server and the cache parser.</p>
<h4>Origin delimiters</h4>
<p>The following custom delimiters are used in various application servers and frameworks:</p>
<ul> <li> <span>Semicolon in Spring:</span> In many Java frameworks, including Spring, the semicolon is used as a delimiter to include matrix variables. Matrix variables can be included in each path segment and aren't interpreted as part of the absolute path.<p> <strong>URL:</strong> /MyAccount;<span>var1=val</span> → <strong>Path:</strong> /MyAccount</p><p> <strong>URL:</strong> /hello;<span>var=a/world;var1=b;var2=c</span> → <strong>Path:</strong> /hello/world </p></li> <br> <li> <span>Dot in Rails:</span> Ruby on Rails allows the client to send a path with a formatter extension, which defines the view returned in the response. This is used to return different responses with different content types. If no extension is used or the extension isn't recognized by the server, the default HTML view is returned. Therefore the dot character can act as a path delimiter.<p> <strong>URL:</strong> /MyAccount<span>.html</span> → <strong>Path:</strong> /MyAccount (default HTML view)</p><p> <strong>URL:</strong> /MyAccount<span>.css</span> → <strong>Path:</strong> /MyAccount (CSS view or error if not present)</p><p> <strong>URL:</strong> /MyAccount<span>.aaaa</span> → <strong>Path:</strong> /MyAccount (default HTML view) </p></li> <br> <li> <span>Null encoded byte in OpenLiteSpeed:</span> This HTTP server uses the null encoded byte as a classic delimiter to truncate the path.<p> <strong>URL:</strong> /MyAccount<span>%00aaa</span> → <strong>Path:</strong> /MyAccount </p></li> <br> <li> <span>Newline encoded byte in Nginx:</span> When Nginx is configured to rewrite the request path, the encoded newline byte is used as a path delimiter. The rewrite rule must map the prefix or the URL and not the entire pathname (which is common in Nginx).<p> <strong>Rule:</strong> rewrite /user/(.*) /account/$1 break;</p><p> <strong>URL:</strong> /users/MyAccount<span>%0aaaa</span> → <strong>Path:</strong> /account/MyAccount </p></li> </ul><br>
<h4>Detecting origin delimiters</h4>
<p>1) Identify a non-cacheable request. Look for a request with a method that isn't idempotent, such as POST, or a response with a <span>Cache-Control: no-store</span> or <span>Cache-Control: private</span> header. The response (R0) will be used to compare the behavior of interesting characters in the URL.</p>
<p>2)Send the same request, only this time append a random suffix at the end of the path, for example, if the original path was <span>/home</span> send a request to <span>/homeabcd</span>. If the response (R1) is the same as R0, repeat step 1 and 2 with a different endpoint.</p>
<p>3)Send the same request as step 2, but include a potential delimiter before the random suffix. If the delimiter being tested is <span>$</span>, the path should look like <span>/home$abcd</span>. Compare this response (R2) with the base one (R0).<br>If the messages are identical, the character or string is used as a delimiter.
</p>
<p>To test a number of possible delimiters at once, you can use Burp Intruder with a wordlist that includes all ASCII characters. Be sure to test both unencoded and URL-encoded versions of the characters.</p> <h4>Detecting cache delimiters</h4>
<p>Cache servers often don't use delimiters aside from the question mark. It's possible to test this using a static request and response:</p>
<p>1) Identify a cacheable request by looking for evidence that the response is retrieved from the cache. For example, by response time analysis, or by looking for an <span>X-Cache</span> header with the value <span>hit</span><br>. This response (R0) will be used to compare the behavior of interesting characters in the URL.
</p>
<div><p>2) Send the same request with a URL path suffix followed by the possible delimiter and a random value.</p><p><span>GET /static-endpoint<span>&lt;DELIMITER&gt;</span><span>&lt;Random&gt;</span></span></p></div><p>3) Compare the response with R0. If the messages are identical, the character or string is used as a delimiter.
</p> <h3><a>Normalization</a></h3>
<p>URL parsers are used by both the cache and origin server to extract paths for endpoint mapping, cache keys, and rules. First, path delimiters are identified to locate the start and end of the pathname. Once the path is extracted, it's normalized to its absolute form by decoding characters and removing dot-segments.</p>
<h4>Encodings</h4>
<p>Sometimes, a delimiter character needs to be sent for interpretation by the application rather than the HTTP parser. For such cases, the URI RFC defines URL encoding, which allows characters to be encoded to avoid modifying the meaning of the pathname.</p>
<p>Many HTTP servers and proxies including Nginx, Node, CloudFlare, CloudFront and Google Cloud decode certain delimiter characters before interpreting the pathname. To make things worse, this process is inconsistent. This means that the same URL will have a different meaning in the most popular CDNs and origin servers even without any custom configuration.</p>
<p>In addition, the RFC doesn't specify how a request should be forwarded or rewritten. Many proxies decode the URL and forward the message with the decoded values. If this occurs, the next parser may use the decoded characters as delimiters. Therefore, if the following request is received by a proxy, the %3F character will be converted to a question mark symbol</p> <p><span>"/myAccount%3Fparam" → "/myAccount?param"</span></p><p>There are also many other encodings supported by different cache proxies. Even though most of them are not used by default, it is possible to configure CDNs like CloudFlare or CloudFront to apply custom transformations and decode the path for caching or <a href="https://portswigger.net/web-security/access-control">access control</a> purposes.</p>
<h4>Detecting decoding behaviors</h4>
<p>To test if a character is being decoded, compare a base request with its encoded version. For example:</p>
<p>/home/index → /%68%6f%6d%65%2f%69%6e%64%65%78</p>
<p>Note: It might be useful to encode each character individually, as sometimes specific characters are not decoded (like the slash or other reserved characters).</p>
<p>If the response is the same as the base response and wasn't obtained from the cache (no cache hit header), the origin server decodes the path before using it. If the response is cacheable, it's possible to detect the cache parser's decoding behavior. Send the original request followed by the encoded version. If both responses contain the same cache headers, it means that the second one was obtained from the proxy, and the key was decoded before being compared.
</p>
<h4>Dot-segment normalization</h4>
<p>The URI RFC also defines how to handle dot-segments in a URL and provides a simple algorithm to normalize the path. While this feature is crucial for referencing any resource from a relative path, it's also the source of many vulnerabilities.</p>
<p>It's possible to exploit dot-segment normalization by leveraging the discrepancies between parsers to modify the behavior of the cache rules and obtain crafted keys. Even popular HTTP servers like Apache and Nginx resolve URLs completely differently, meaning it is impossible to use the same cache proxy without having a path confusion vulnerability.</p>
<h4>Detecting dot-segment normalization</h4>
<p>The following techniques can be used to detect dot-segment normalization at both the cache and the origin server. These tests can be extended using encoded <a href="https://portswigger.net/web-security/file-path-traversal">path traversal</a> payloads to know if a special decoding is applied. For this, use the same request / responses and replace the dot-segments with the encoded version.</p>
<p>To detect normalization in the origin server, issue a non-cacheable request (or a request with a cache buster) to a known path, then send the same message with a path traversal sequence:</p>
<p>GET /home/index?cacheBuster</p>
<p>GET <b>/aaa/</b>../home/index?cacheBuster or GET <b>/aaa\..\</b>home/index?cacheBuster</p>
<p>If the responses are identical, this means that the path is normalized before it's mapped with a resource. This can either happen at the origin server or before being forwarded by a proxy. Either way, the dot-segment is resolved and can be used to reference an existing resource.</p>
<p>To detect normalization at the web cache, repeat the same process but with a cacheable response and compare the <span>X-Cache</span> and <span>Cache-Control</span> headers to verify if the resource was obtained from the cache memory.</p>
<h4>Normalization discrepancies</h4>
<p>The following tables illustrate how different HTTP servers and web cache proxies normalize the path <span>/hello/..%2fworld.</span> Some resolve the path to <span>/world</span>, while others don't normalize it at all.</p>
<p><img src="https://portswigger.net/cms/images/aa/91/4d39-article-noramlization_table.png"></p><h2><a>Arbitrary Web Cache Deception</a></h2>
<p>When the web cache receives a response from the origin server, it must decide if the resource is static and should therefore be stored. This involves applying predefined, customizable rules to the request and response.</p>
<p>This section focuses on rules that use the URL to determine if a response should be cached. These are popular in production environments and most CDNs include some of these rules by default.</p>
<p>It's possible to use parsing discrepancies to exploit cache rules, to store dynamic responses and hijack sensitive information that was generated for a victim. <br>A detailed explanation of how to use discrepancies in URL mapping to create path confusion can be found in Omer Gil’s white paper <a href="https://www.blackhat.com/docs/us-17/wednesday/us-17-Gil-Web-Cache-Deception-Attack-wp.pdf">Web cache deception attack</a>.
</p>
<p>This white paper focuses on other types of discrepancies, which can be exploited to hijack any arbitrary response, not only those with special endpoint mapping at the origin server.</p>
<h3><a>Limitations</a></h3>
<p>Since the attacker needs to generate a link that's used by a victim's browser, the payload must contain safe URL characters only - those the browser won't encode before sending.</p>
<p>To visualize this scenario, consider the browser as a proxy that rewrites the request URL by encoding certain characters and removing segments.</p>
<h3><a>Static extensions</a></h3>
<p>Most CDN providers, such as CloudFlare and Akamai, store responses for resources with static extensions. This means that if the requested path ends with a string like .js or .css the cache proxy treats the response as static. It stores the response and uses it to serve other clients that request the same path.</p>
<p>Each CDN or cache proxy defines its own list of recognized static extensions. The image below shows those listed by CloudFlare:</p>
<p><img src="https://portswigger.net/cms/images/18/8a/d91c-article-cloudflare_extensions.png"></p><h4>Exploiting static extensions</h4>
<p>When a character is used as a delimiter by the origin server but not the cache, it's possible to include an arbitrary suffix to trigger a cache rule and store any sensitive response.</p>
<p>For example, if the dollar sign character is a delimiter in the origin server but not the proxy, the following link stores the response to <span>/myAccount</span>, allowing an attacker to hijack sensitive information:</p><p><img src="https://portswigger.net/cms/images/bd/df/4f4a-article-table1.png"></p><p>You can also use the same technique with an encoded character or string. This is useful when the origin server decodes a delimiter before parsing the URL, or if the path is rewritten by the cache before forwarding the request. For example, the unencoded hashtag symbol wouldn't work for cache deception as its not sent by the browser, but if it's encoded it can be used for an exploit:</p><p><img src="https://portswigger.net/cms/images/99/4f/d7c9-article-table2.png"><br></p><p>You can use a variation of this attack to exploit a discrepancy from a forwarding transformation. If multiple parsers rewrite the request, we can attack a specific cache proxy of the chain by applying multiple encodings and/or delimiters:</p>
<p><img src="https://portswigger.net/cms/images/df/db/b465-article-table3.png"></p> <h3><a>Static directories</a></h3>
<p>A popular rule implemented in all CDNs allows the user to create rules that match a custom URL path prefix. This can be used to let the web cache know that every resource in a specific directory is immutable and should be stored, no matter the resource name or extension.<br>Some common examples of static directories are: </p>
<ul> <li><span>/static</span></li> <li><span>/assets</span></li> <li><span>/wp-content</span></li> <li><span>/media</span></li> <li><span>/templates</span></li> <li><span>/public</span></li> <li><span>/shared</span></li></ul>
<h4>Exploiting static directories with delimiters</h4>
<p>If a character is used as a delimiter by the origin server but not by the cache and the cache normalizes the path before applying a static directory rule, you can hide a path traversal segment after the delimiter, which the cache will resolve:</p>
<p><span>GET /<span>&lt;Dynamic_Resource&gt;</span><span>&lt;Delimiter&gt;</span><span>&lt;Encoded_Dot_Segment&gt;</span><span>&lt;Static_Directory&gt;</span></span></p>
<p>It's important to encode the dot-segment. Otherwise the victim’s browser will resolve it and won't forward the original malicious path.</p><p><img src="https://portswigger.net/cms/images/40/6b/2a8b-article-table4.png"></p><p>Amazon CloudFront, Microsoft Azure, and Imperva normalize the path before evaluating the cache rules by default.</p>
<h4>Exploiting static directories with normalization</h4>
<p>When the origin server normalizes the path before mapping the endpoint and the cache doesn't normalize the path before evaluating the cache rules, you can add a path traversal segment that will only be processed by the origin server:</p>
<p><span>GET /<span>&lt;Static_Directory&gt;</span><span>&lt;Encoded_Dot_Segment&gt;</span><span>&lt;Dynamic_Resource&gt;</span></span></p><p><img src="https://portswigger.net/cms/images/5b/a8/7b46-article-table5.png"></p><p>Cloudflare, Google Cloud, and Fastly don't normalize the path before evaluating the cache rules. If the origin server normalizes the path before mapping the request with an endpoint handler, such as Nginx, Microsoft IIS and OpenLiteSpeed, it is possible to exploit any static directory rule.</p>
<p>Another normalization discrepancy arises when combining Microsoft IIS with any web cache that doesn't convert backlashes. These caches interpret encoded backslashes as regular slashes. Since no tested CDN recognizes this transformation, IIS is vulnerable when used with such products.</p><p><img src="https://portswigger.net/cms/images/f2/24/b888-article-table6.png"><br></p><h3><a>Static files</a></h3> <p>Some files, like <span>/robots.txt</span>, <span>/favicon.ico</span>, and <span>/index.html</span>, might not be in a static directory or have a static extension but are expected to be immutable in every website. To store these files it is possible to create a cache rule that looks for an exact match of the filename in the path. CDNs like CloudFlare have this rule by default and always store responses for <span>robots.txt</span> or <span>favicon.ico</span>.</p>
<h4>Exploiting static files</h4>
<p>To exploit static file rules it is possible to use the same technique as for static directories when there is normalization at the frontend and a delimiter at backend. In this case, the static directory is replaced by the filename and a cache buster to avoid hitting a cached resource:</p>
<p><span>GET /<span>&lt;Dynamic_Resource&gt;</span><span>&lt;Delimiter&gt;</span><span>&lt;Encoded_Dot_Segment&gt;</span><span>&lt;Static_File&gt;</span></span></p>
<p><img src="https://portswigger.net/cms/images/33/27/0564-article-table7.png"><br></p><h2><a>Arbitrary Web Cache Poisoning</a></h2> <p>When a response is considered static, it's stored in the cache using a key that is derived from the original request. Any future request with the same key will be served with the stored resource.</p>
<p>Keys are usually generated using the URL and host header. They can be customized to use other headers or request elements.</p>
<p>In classic web cache poisoning, the attacker attempts to store a malicious response using a URL key that is requested by users while they navigate the vulnerable website. The more frequently the path is visited, the more victims will be affected by the malicious payload. You can read more about finding web cache poisoning vulnerabilities in James Kettle's research <a href="https://portswigger.net/kb/papers/7q1e9u9a/web-cache-poisoning.pdf">Practical Web Cache Poisoning</a> and <a href="https://portswigger.net/kb/papers/c3wwniai/web-cache-entanglement.pdf">Web Cache Entanglements: Novel pathways to poisoning</a>.</p>
<p>The attack is limited, as in many cases the poisoned path is not controlled by the attacker and user interaction is required. For example, consider a URL that is never visited, either because it requires a specific parameter such as <span>/home?param=XSS</span>, or because the path itself contains the payload <span>/&lt;script&gt;alert()&lt;/script&gt;</span></p>
<p>However, combining path confusion with a web cache poisoning vulnerability could allow you to modify the cache key and poison a highly requested resource, like the website's homepage. In this case, there's no limitation on the characters that can be used, as the attacks don't require user interaction, which means that the payload can be sent through an HTTP editor/repeater like Burp Suite.</p>
<h3><a>Key normalization</a></h3>
<p>Normalizing a URL is usually considered a safe action that helps to obtain the absolute path of a requested resource. However, resolving dot-segments and encodings in a cache key could allow an attacker to poison arbitrary resources if the origin server is not interpreting the path in the same way.</p>
<p>All the following attacks assume that the URL is normalized before generating the cache key. This can be configured in most CDNs and is a default behavior in Microsoft Azure and Imperva.</p>
<h4>Exploiting mapping discrepancies</h4>
<p>When the origin server uses a special mapping or doesn't normalize the path before generating the response, it's possible to control the key used for stored resources.
An classic example of this are applications that have a self-reflected XSS when an non-existing endpoint is visited.</p>
<p>Consider the following request/response:</p>
<p><code>GET /<span>&lt;script&gt;X&lt;/script&gt;</span> HTTP/1.1
Host: server.com </code>
<code>HTTP/1.1 404 Not Found
Content-Type: text/html
Cache-Control: public Not Found /<span>&lt;script&gt;X&lt;/script&gt;</span></code></p><p>The malicious payload is part of the URL and is reflected in a cacheable response. However, a valid user would never issue a request to <span>/&lt;script&gt;X&lt;/script&gt;</span> if there is no interaction with the attacker. Therefore, even if the response is also accessible through the encoded version <span>/%3Cscript%3EX%3C/script%3E</span> (the key is decoded), the attacker will need to send a link to the victim, just as in a <a href="https://portswigger.net/web-security/cross-site-scripting/reflected">reflected XSS</a> scenario.</p>
<p>However, if the key is normalized, the following payload would poison a highly visited endpoint like <span>/home</span> with the malicious response:</p>
<p><span>GET /<span>&lt;Backend_Path&gt;</span><span>&lt;Path_Traversal&gt;</span><span>&lt;Poisoned_Path&gt;</span></span></p><p><img src="https://portswigger.net/cms/images/38/e2/6160-article-table8.png"><br></p><p>The double dot-segment is used in this example as the payload already contains a slash. Adjust the path traversal to resolve to the desired poisoned endpoint. The same technique can be applied if a special mapping is used for the <span>backend_path<span> placeholder.</span></span></p> <h3><a>Exploiting back-end delimiters</a></h3>
<p>When a character is used as a delimiter by the origin server but not by the cache, it's possible to generate an arbitrary key for the cacheable resource. The delimiter will stop the backend from resolving the dot-segment.</p>
<p><span>GET /<span>&lt;Backend_Path&gt;</span><span>&lt;Delimiter&gt;</span><span>&lt;Path_Traversal&gt;</span><span>&lt;Poisoned_Path&gt;</span></span></p>
<p><img src="https://portswigger.net/cms/images/7c/82/e482-article-table9.png"></p> <h3><a>Exploiting front-end delimiters</a></h3>
<p>In <a href="https://portswigger.net/web-security/web-cache-deception">web cache deception</a> attacks, the parsing discrepancy was caused by a delimiter being used only in the origin server but not in the cache. Finding a character with special meaning for the cache server that can be sent through a browser is rare. However, as web cache poisoning doesn't require user interaction, delimiters like the hash can create path confusion. This is useful because fragments are interpreted differently by many HTTP servers, CDNs, and backend frameworks, as shown in the tables below:</p><p><img src="https://portswigger.net/cms/images/d3/d9/9cf7-article-hash_delimiter.png"></p><p>Therefore, in cases like Microsoft Azure, which normalizes the path and treats the hash as a delimiter, it's possible to use this to modify the cache key of the stored resource:</p>
<p><span>GET /<span>&lt;Poisoned_Path&gt;</span><span>&lt;Front-End_Delimiter&gt;</span><span>&lt;Path_Traversal&gt;</span><span>&lt;Backend_Path&gt;</span></span></p><p>This technique could be applied to any delimiter used by the cache. The only requirement is that the key is normalized and the path is forwarded with the suffix after the delimiter.</p> <h2><a>Cache-What-Where</a></h2>
<p>When auditing a website for a pentest or bug bounty program, it's common to find vulnerabilities that aren't exploitable due to browser constraints and limitations. These issues require user interaction and can't be sent through the browser because the request needs specific crafted headers or characters in the URL that get encoded.</p>
<p>By combining these vulnerabilities with the previously described cache poisoning and deception techniques, an attacker could exploit them and store a malicious payload in the cache.</p>
<p>For example, consider a website with an open redirect where the location is generated with an <span>X-Forwarded-Host</span> header:</p>
<p><code>GET /home HTTP/1.1
Host: server.com
X-Forwarded-Host: evil.com </code>
<code>HTTP/1.1 302 Found
Location: http://evil.com/index.html </code></p><p>By itself, this redirect isn't stored in the cache, so it shouldn't be possible to poison the cache with it. However, if there's a discrepancy between the cache key and backend parser, this 'unexploitable' vulnerability could be escalated to a full domain takeover. For example, if the web application loads the <span>/main.js</span> script on the homepage, we can poison the path in the cache and redirect the browser to load a malicious script:</p><p><img src="https://portswigger.net/cms/images/8d/e8/23e7-article-table12.png"><br></p><p>This forces the cache proxy into storing the redirect response to evil.com under the /main.js key. When a victim loads the homepage and tries to access the /main.js resource, a malicious redirect will obtain a JavaScript controlled by the attacker which will infect every user browser.<br></p>
<p>In an even worse scenario, the open redirect is stored due to a cache header:</p>
<p><code>GET /redirect?somePage HTTP/1.1
Host: vulnerable.com
X-Forwarded-Host: evil.com </code>
<code>HTTP/1.1 302 Found
Location: http://evil.com/somePage
Cache-Control: public, max-age=3600 </code></p><p>In this case, the poisoned path wouldn’t need a static extension and the vulnerability could be leveraged to complete arbitrary cache poisoning and full website defacement.</p><p><img src="https://portswigger.net/cms/images/7b/60/6180-article-table14.png"></p><p>The same technique can be used with any other user interaction required or self reflected issue, like a self-reflected and not-exploitable XSS.</p> <h2><a>Defence</a></h2>
<p>The easiest way to protect against web cache deception is to mark all dynamically generated responses with a <span>Cache-Control</span> header, set with the <span>no-store</span> and <span>private</span> directives. This tells the web cache that the resource should never be stored.</p>
<p>It is also important to verify that the cache rules don't have priority over the <span>Cache-Control</span> header. This can be configured in most CDNs. If it can't be configured, consider disabling the caching rules or avoid using an origin server or framework that parses the URL differently to the CDN.</p>
<p>To protect against cache key confusion make sure that the cache key isn't normalized and that the suffix after a cache delimiter isn't forwarded to the application server. If this isn't possible, consider switching to a different CDN or HTTP server that parses the URL in as similar a way as possible.</p>
<br><h2><a>Takeaways</a></h2>
<p>URL parsing discrepancies can be easily exploited using web cache poisoning and deception</p>
<p>Exploitation techniques that can be applied in countless systems and bug bounty programs</p>
<p>Chain web cache poisoning and deception to increase severity and obtain full site take over!</p> <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
  </script>
</body>
</html>