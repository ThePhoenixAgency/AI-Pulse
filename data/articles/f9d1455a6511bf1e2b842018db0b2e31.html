<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Optimisation webperf : AVIF et pré-compression pour le blog</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Optimisation webperf : AVIF et pré-compression pour le blog</h1>
  <div class="metadata">
    Source: Journal du Hacker | Date: 2/21/2026 3:35:46 PM | <a href="https://blog.zwindler.fr/2026/02/19/optimisation-webperf-avif-precompression/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: FR
  </div>
  <div class="content">
    <div><section><p>Ce blog a presque 16 ans d’existence. Sur cette période, j’ai accumulé plus de 530 articles avec plus de 2700 images. Il y a quelques années, j’avais commencé à taper des limites (notamment quand j’ai essayer Gitlab pages chez Froggit) en atteignant les 500 Mo de medias.</p><p>J’avais fait une première passe d’optimisation, à grand coup de resize, <code>jpegoptim</code> et <code>optipng</code> et j’étais redescendu sous les 300 Mo. C’était pas mal, mais pas satisfaisant.</p><p>Puis j’ai vu <a href="https://blog.zwindler.fr/2026/02/13/recap-touraine-tech-2026-jour2/#au-secours--mes-images-pourrissent-mes-perfs">le talk d’Antoine Caron (slashgear) et Mathieu Mure à Touraine Tech 2026</a> et j’ai enfin pris le temps de lâcher les “formats morts”.</p><h2>Un peu de contexte</h2><p>Ça fait un moment que je bricole l’infra et les perfs de ce blog. Si ça vous intéresse, les épisodes précédents sont ici :</p><ul><li><a href="https://blog.zwindler.fr/2019/12/24/ca-bouge-pas-mal-sur-le-blog/">Ça bouge pas mal sur le blog !</a> (2019) - De 5s à 1s en virant Wordpress pour Hugo</li><li><a href="https://blog.zwindler.fr/2025/01/15/ca-bouge-encore-sur-le-blog/">Ça bouge encore sur le blog</a> (2025) - Nettoyage massif, retour auto-hébergé</li><li><a href="https://blog.zwindler.fr/2023/08/01/automatiser-hugo-sans-github-action/">Automatiser son site Hugo sans Github Action ou Vercel</a> - Le setup nginx + webhook actuel</li></ul><p>Quand j’ai commencé ce round d’optimisation, la note PageSpeed de la page d’accueil tournait autour de 70-85 en mobile selon les articles. Pas dramatique, mais on peut faire mieux !</p><h2>Le talk qui a tout déclenché</h2><p>À <a href="https://blog.zwindler.fr/2026/02/13/recap-touraine-tech-2026-jour2/">Touraine Tech 2026</a>, Antoine Caron et Mathieu Mure ont fait un talk très clair sur l’optimisation des images web, qui pourrissent les perfs des sites web aujourd’hui.</p><p>Le message principal : les formats comme JPEG et PNG sont des “formats morts” (ou en tout cas vieillissants). À compression équivalente, les formats modernes comme AVIF prennent beaucoup moins de place, mais surtout, ils affichent des artefacts visuels bien moindres dans les hauts niveaux de compression.</p><p>J’avais failli faire une migration vers le WebP il y a quelques années, puis j’avais laissé tomber, par flemme et après quelques soucis techniques dont je ne me souviens plus trop.</p><p>Et finalement, c’est presque tant mieux, parce qu’avec AVIF, on peut compresser <strong>encore plus fort</strong>, sans que ça se voit. C’est exactement ce qu’il me fallait.</p><p>Side note : on m’a demandé une comparaison WebP vs AVIF, et Joseph a trouvé ça. C’est plutôt intéressant :</p><ul><li><a href="https://elementor.com/blog/fr/avif-vs-webp-quel-format-dimage-regne-en-maitre-en-2024/" target="_blank">elementor blog - AVIF vs WebP : Quel format d’image règne en maître en 2024 ?</a></li></ul><h2>Conversion massive en AVIF</h2><p>J’ai donc écrit un script qui :</p><ol><li><strong>Redimensionne</strong> les images trop grandes (&gt; 1500px) pour les ramener à ~1 mégapixel</li><li><strong>Convertit en AVIF</strong> avec <code>avifenc</code> (qualité 50, speed 6)</li><li><strong>Met à jour les références</strong> dans tous les articles markdown</li></ol><p>Et je l’ai lancé année par année, de 2026 jusqu’à 2010.</p><h3>Les résultats</h3><div><table><thead><tr><th>Année</th><th>Fichiers</th><th>Originaux</th><th>AVIF</th><th>Réduction</th></tr></thead><tbody><tr><td>2010</td><td>12</td><td>0.4 MiB</td><td>0.1 MiB</td><td>74%</td></tr><tr><td>2011</td><td>27</td><td>1.8 MiB</td><td>0.7 MiB</td><td>63%</td></tr><tr><td>2012</td><td>6</td><td>0.4 MiB</td><td>0.1 MiB</td><td>78%</td></tr><tr><td>2013</td><td>2</td><td>0.1 MiB</td><td>0.1 MiB</td><td>56%</td></tr><tr><td>2014</td><td>43</td><td>5.3 MiB</td><td>1.0 MiB</td><td>81%</td></tr><tr><td>2015</td><td>214</td><td>10.7 MiB</td><td>3.7 MiB</td><td>65%</td></tr><tr><td>2016</td><td>231</td><td>12.1 MiB</td><td>4.1 MiB</td><td>66%</td></tr><tr><td>2017</td><td>428</td><td>23.7 MiB</td><td>9.1 MiB</td><td>62%</td></tr><tr><td>2018</td><td>142</td><td>7.5 MiB</td><td>2.4 MiB</td><td>68%</td></tr><tr><td>2019</td><td>136</td><td>12.1 MiB</td><td>2.9 MiB</td><td>76%</td></tr><tr><td>2020</td><td>228</td><td>23.6 MiB</td><td>5.6 MiB</td><td>77%</td></tr><tr><td>2021</td><td>187</td><td>31.6 MiB</td><td>4.8 MiB</td><td>85%</td></tr><tr><td>2022</td><td>237</td><td>29.2 MiB</td><td>7.5 MiB</td><td>74%</td></tr><tr><td>2023</td><td>253</td><td>43.2 MiB</td><td>7.8 MiB</td><td>82%</td></tr><tr><td>2024</td><td>259</td><td>34.2 MiB</td><td>8.0 MiB</td><td>77%</td></tr><tr><td>2025</td><td>255</td><td>31.2 MiB</td><td>6.8 MiB</td><td>78%</td></tr><tr><td>2026</td><td>44</td><td>6.8 MiB</td><td>1.8 MiB</td><td>74%</td></tr><tr><td><strong>Total</strong></td><td><strong>2704</strong></td><td><strong>~274 MiB</strong></td><td><strong>~66 MiB</strong></td><td><strong>~76%</strong></td></tr></tbody></table></div><p>De PNG/JPEG qualité 90 à AVIF qualité 50 : entre 4 et 5 fois moins lourd.</p><p>Le plus satisfaisant, c’est que je ne suis pas capable de détecter visuellement de perte de qualité. Les screenshots de terminal et mes photos passent très bien en AVIF 50.</p><h2>Pré-compression des documents HTML</h2><p>Après la conversion AVIF, <a href="https://bsky.app/profile/slashgear.dev/post/3metqwv5aas2t" target="_blank">Antoine Caron (@slashgear.dev)</a> m’a fait remarquer un truc :</p><blockquote><p>Alors c’est pas mal déjà ! Je vois aussi que tes documents HTML ne sont pas compressés. Si ton blog est purement static, hésite pas à précompresser à balle et dire à ton server de servir les versions précompressées.</p></blockquote><p>Effectivement, j’avais déjà <code>gzip on;</code> dans ma config nginx, mais c’est de la compression <strong>à la volée</strong>. Nginx utilise par défaut un niveau de compression modéré (niveau 6 sur 9) pour ne pas consommer trop de CPU.</p><div><pre><code><span><span><span>server</span> <span>{</span>
</span></span><span><span> <span>server_name</span> <span>blog.zwindler.fr</span><span>;</span>
</span></span><span><span> <span>root</span> <span>/usr/share/nginx/html/blog.zwindler.fr/public</span><span>;</span>
</span></span><span><span> <span>gzip</span> <span>on</span><span>;</span>
</span></span><span><span> <span>...</span>
</span></span><span><span><span>}</span>
</span></span></code></pre></div><p>Or, mon blog est <strong>100% statique</strong>. Les fichiers ne changent qu’au rebuild. Ça veut dire qu’on peut les compresser une seule fois, avec le niveau maximum, et demander à nginx de servir directement les fichiers pré-compressés. Zéro CPU à chaque requête, mais surtout un meilleur ratio au final, car on peut compresser plus fort.</p><h3>Côté build : <code>blog_refresh.sh</code></h3><p>J’ai ajouté les commandes de pré-compression après le <code>hugo --minify</code> :</p><div><pre><code><span><span><span># Pre-compress static files (gzip + brotli) for nginx gzip_static/brotli_static</span>
</span></span><span><span><span># Zopfli: compatible gzip mais ~3-8% plus petit que gzip -9</span>
</span></span><span><span><span>if</span> <span>command</span> -v zopfli <span>&amp;</span>&gt; /dev/null<span>;</span> <span>then</span>
</span></span><span><span> find public -type f <span>\(</span> -name <span>"*.html"</span> -o -name <span>"*.css"</span> -o -name <span>"*.js"</span> <span>\
</span></span></span><span><span> -o -name <span>"*.xml"</span> -o -name <span>"*.json"</span> -o -name <span>"*.svg"</span> -o -name <span>"*.txt"</span> <span>\)</span> <span>\
</span></span></span><span><span> -exec zopfli --i1023 <span>{}</span> +
</span></span><span><span><span>else</span>
</span></span><span><span> find public -type f <span>\(</span> -name <span>"*.html"</span> -o -name <span>"*.css"</span> -o -name <span>"*.js"</span> <span>\
</span></span></span><span><span> -o -name <span>"*.xml"</span> -o -name <span>"*.json"</span> -o -name <span>"*.svg"</span> -o -name <span>"*.txt"</span> <span>\)</span> <span>\
</span></span></span><span><span> -exec gzip -k -f -9 <span>{}</span> +
</span></span><span><span><span>fi</span>
</span></span><span><span>
</span></span><span><span><span># Brotli pre-compression (better ratio than gzip, ~15-25% smaller)</span>
</span></span><span><span><span>if</span> <span>command</span> -v brotli <span>&amp;</span>&gt; /dev/null<span>;</span> <span>then</span>
</span></span><span><span> find public -type f <span>\(</span> -name <span>"*.html"</span> -o -name <span>"*.css"</span> -o -name <span>"*.js"</span> <span>\
</span></span></span><span><span> -o -name <span>"*.xml"</span> -o -name <span>"*.json"</span> -o -name <span>"*.svg"</span> -o -name <span>"*.txt"</span> <span>\)</span> <span>\
</span></span></span><span><span> -exec brotli -k -f -q <span>11</span> <span>{}</span> +
</span></span><span><span><span>fi</span>
</span></span></code></pre></div><p>Pour la compression gzip, Zigazou m’a conseillé d’utiliser <a href="https://github.com/google/zopfli" target="_blank">Zopfli</a> (<code>apt install zopfli</code>) plutôt que <code>gzip -9</code>. Zopfli produit des fichiers 100% compatibles gzip mais avec un meilleur ratio (~3-8% en moins). C’est plus lent, mais sur un blog statique où on compresse une seule fois au build, on s’en fiche.</p><p>En pratique, le gain de Zopfli est surtout un bonus : la majorité des navigateurs modernes supportent Brotli et recevront les <code>.br</code>, qui sont de toute façon plus petits. Le <code>.gz</code> ne sert que de fallback.</p><p>Chaque fichier <code>index.html</code> se retrouve ainsi avec un <code>index.html.gz</code> et un <code>index.html.br</code> à côté de lui.</p><h3>Côté nginx</h3><div><pre><code><span><span><span># Serve pre-compressed files generated at build time
</span></span></span><span><span><span>gzip_static</span> <span>on</span><span>;</span>
</span></span><span><span><span>brotli_static</span> <span>on</span><span>;</span> <span># nécessite libnginx-mod-http-brotli-static
</span></span></span><span><span>
</span></span><span><span><span># Fallback pour les contenus non pré-compressés
</span></span></span><span><span><span>gzip</span> <span>on</span><span>;</span>
</span></span><span><span><span>gzip_vary</span> <span>on</span><span>;</span>
</span></span><span><span><span>gzip_min_length</span> <span>1024</span><span>;</span>
</span></span><span><span><span>gzip_types</span> <span>text/plain</span> <span>text/css</span> <span>text/xml</span> <span>text/javascript</span>
</span></span><span><span> <span>application/javascript</span> <span>application/json</span>
</span></span><span><span> <span>application/xml</span> <span>image/svg+xml</span><span>;</span>
</span></span></code></pre></div><p>Pour Brotli, sur <strong>Ubuntu 24.04+</strong>, les paquets sont dans les dépôts officiels :</p><div><pre><code><span><span>sudo apt install libnginx-mod-http-brotli-filter libnginx-mod-http-brotli-static
</span></span></code></pre></div><h3>Le gain mesuré</h3><p>Un petit <code>curl</code> pour comparer la page d’accueil :</p><div><pre><code><span><span><span># Avec Brotli (ce que reçoivent les navigateurs)</span>
</span></span><span><span>curl -so /dev/null -w <span>"%{size_download}"</span> -H <span>"Accept-Encoding: br, gzip"</span> https://blog.zwindler.fr/
</span></span><span><span><span># =&gt; 6 206 bytes</span>
</span></span><span><span>
</span></span><span><span><span># Sans compression</span>
</span></span><span><span>curl -so /dev/null -w <span>"%{size_download}"</span> -H <span>"Accept-Encoding: identity"</span> https://blog.zwindler.fr/
</span></span><span><span><span># =&gt; 32 886 bytes</span>
</span></span></code></pre></div><p><strong>-81% sur le HTML</strong>, de 33 Ko à 6 Ko transférés. Et on le vérifie dans Chrome DevTools : le header <code>Content-Encoding: br</code> confirme que Brotli est bien servi.</p><p>Et c’est pareil pour les autres fichiers textes statiques (CSS, JS).</p><h2>Bilan</h2><div><table><thead><tr><th>Optimisation</th><th>Avant</th><th>Après</th><th>Gain</th></tr></thead><tbody><tr><td>Images (AVIF)</td><td>274 MiB</td><td>66 MiB</td><td><strong>-76%</strong></td></tr><tr><td>HTML page d’accueil (Brotli)</td><td>33 Ko transférés</td><td>6 Ko transférés</td><td><strong>-81%</strong></td></tr></tbody></table></div><p>Le tout sans aucune dégradation visible de la qualité des images, et zéro impact CPU côté serveur pour la compression (puisqu’elle est faite au build).</p><p>Et des webperfs qui ont bien progressé, même en mobile :</p><p><img src="https://blog.zwindler.fr/2026/02/webperf.avif"></p></section></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>