<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Agents IA : passer du prototype à un système en production</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Agents IA : passer du prototype à un système en production</h1>
  <div class="metadata">
    Source: Journal du Net | Date: 2/23/2026 2:23:19 PM | <a href="https://www.journaldunet.com/intelligence-artificielle/1548129-agents-ia-passer-du-prototype-a-un-systeme-en-production/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: FR
  </div>
  <div class="content">
    <div><div> <p> Les agents IA ne sont plus des démos qui répondent à des questions. Ce sont des systèmes qui agissent&nbsp;: ils déclenchent des workflows, interrogent des données, ...</p> <p>Les agents IA ne sont plus des démos qui répondent à des questions. Ce sont des systèmes qui agissent : ils déclenchent des workflows, interrogent des données, ouvrent des tickets, proposent des décisions — et parfois les exécutent. Cette capacité à opérer de manière autonome et contextuelle marque une évolution majeure par rapport aux modèles génératifs passifs. Cependant, ce qui impressionne en preuve de concept (POC) s’effondre souvent en production. Non pas parce que le modèle "n’est pas assez bon", mais parce qu’un agent est un assemblage complexe de composants hétérogènes, et que l’ensemble doit être gouverné avec la même rigueur qu'un produit logiciel critique.</p> <p>La transition d'une idée brillante à une solution fiable et performante en environnement réel exige une approche architecturale et opérationnelle structurée. Il s'agit de transformer un comportement "agentique" en une application distribuée robuste, capable de gérer les imprévus, les contraintes de coût, de latence, et les impératifs de sécurité et de conformité.</p> <h2>L'architecture d'un agent en production : bien plus qu'un simple prompt</h2> <p>Un agent "production-ready" ressemble bien plus à une application distribuée complexe qu'à un simple prompt envoyé à un LLM. Sa conception repose sur une interaction dynamique entre plusieurs briques fondamentales, chacune jouant un rôle crucial dans sa performance et sa fiabilité. Ignorer l'une de ces briques, c'est prendre le risque de construire une solution fragile.</p> <p>Le Modèle (LLM ou autre)</p> <p>Le cœur pensant de l'agent. Il arbitre en permanence entre qualité de la réponse, latence d'exécution, coût des requêtes, taille du contexte disponible et tolérance au risque. Dans un environnement multi-vendor, l'idée qu'un agent puisse choisir différents modèles selon la tâche est devenue essentielle. Un LLM puissant peut exceller pour la rédaction créative, tandis qu'un modèle plus petit et rapide sera privilégié pour des tâches de classification ou de résumé. L'architecture doit permettre cette flexibilité, par exemple en routant les requêtes vers le modèle le plus adapté (et le plus économique) pour une tâche donnée. Cela implique une fine compréhension des capacités et des limitations de chaque modèle.</p> <p>Les Outils (Tools)</p> <p>Un agent devient véritablement utile le jour où il peut interagir avec le monde extérieur. Les "tools" sont ses bras et ses jambes : appels d'APIs internes, intégrations avec des SaaS (CRM, ERP, ticketing), requêtes à des bases de données structurées ou non, moteurs de recherche internes/externes, ou même des systèmes d'automatisation d'infrastructure. Ces outils sont le vecteur de son action. Mais paradoxalement, ils sont aussi la source n°1 de fragilité : problèmes d'authentification, timeouts inattendus, changements de schémas d'API, quotas de requêtes dépassés, ou encore la gestion des erreurs et des réponses vides. La robustesse d'un agent en production dépend directement de la fiabilité et de la gestion des erreurs de ses outils.</p> <p>L'Orchestration</p> <p>Les tâches réelles ne sont jamais monolithiques. Elles demandent plusieurs étapes : comprendre la demande, planifier les actions nécessaires, exécuter les outils adéquats, vérifier les résultats, et corriger si nécessaire. L’orchestration gère cette séquence logique. Elle peut être simple (une chaîne d'actions linéaire) ou avancée (avec du parallélisme, des boucles itératives, des mécanismes de prise de décision, ou même l'interaction entre plusieurs sous-agents). Plus l'orchestration est complexe et "agentique" (capacités de raisonnement et de self-correction), plus elle doit être observée, testée rigoureusement, et bornée par des limites claires (nombre maximal de cycles, budget alloué, garde-fous de sécurité) pour éviter des comportements imprévus ou coûteux.</p> <p>Les Données et la Mémoire (Grounding)</p> <p>Sans données, l'agent "improvise" et invente. En production, il doit s'ancrer dans la réalité factuelle et opérationnelle de l'entreprise. La mémoire n'est pas un concept unique, mais une architecture à plusieurs vitesses :</p> <ul> <li>Connaissance long terme : Représentée par des bases de données vectorielles (Vector DB), des index de recherche, des graphes de connaissances (Knowledge Graphs) ou des systèmes RAG (Retrieval Augmented Generation) traditionnels. Elle fournit à l'agent un accès à des informations statiques ou semi-statiques (documentation, historiques, politiques internes).</li> <li>Mémoire de travail : Le contexte court terme de la tâche en cours, souvent géré directement par le modèle via la fenêtre de contexte. Elle permet à l'agent de suivre le fil de la conversation ou de la tâche.</li> <li>Mémoire transactionnelle : L'état courant des systèmes externes, les traces d'audit, la traçabilité des décisions et des actions exécutées. Elle est cruciale pour la fiabilité, la reprise sur erreur, et la conformité, permettant de savoir exactement ce que l'agent a fait et pourquoi.</li>
</ul> <h2>Les pièges courants : du POC au chaos</h2> <p>L'enthousiasme généré par un POC d'agent IA peut rapidement laisser place à la frustration en production. Ces échecs ne sont pas des fatalités, mais des conséquences de lacunes architecturales ou opérationnelles.</p> <ol> <li>L'agent "hallucine avec assurance" en production : Un POC fonctionne souvent sur un corpus de données propre et limité. En production, face à des données bruitées, ambiguës ou manquantes, l'agent, même bien intentionné, peut générer des informations erronées avec un ton très convaincant, entraînant des décisions incorrectes ou des actions inappropriées. La cause principale est un manque de "grounding" robuste et de mécanismes de vérification.</li> <li>Explosion des coûts opérationnels : Un agent en développement peut ne pas considérer le coût de chaque appel LLM ou outil. En production, avec des millions de requêtes, des boucles d'orchestration non maîtrisées ou des appels de modèles trop chers, la facture peut rapidement devenir insoutenable, rendant le projet non rentable.</li> <li>Intégration complexe et fragile : Les POC se connectent souvent à des APIs simplifiées ou des mocks. En production, la gestion des authentifications complexes, des schémas d'API changeants, des erreurs de réseau, des latences imprévues et des volumes de données importants peut transformer l'intégration en un cauchemar de maintenance.</li> <li>Problèmes de sécurité et de conformité : Un agent en POC n'est généralement pas soumis à des tests de sécurité rigoureux. Une fois déployé, il devient une cible potentielle pour les prompt injections, l'exfiltration de données sensibles ou l'exécution d'actions non autorisées en raison de privilèges excessifs, exposant l'entreprise à des risques légaux et de réputation.</li> <li>Difficulté de débogage et d'explicabilité : Face à un comportement inattendu ou une erreur en production, l'absence de traces détaillées du raisonnement de l'agent, des appels d'outils effectués et des décisions prises rend le débogage extrêmement difficile, voire impossible. "L'agent a fait ça... mais pourquoi ?" est une question courante et sans réponse.</li>
</ol> <h2>Évaluation et testing : au-delà du "vibe testing"</h2> <p>L'évaluation des agents ne peut se limiter à une impression subjective ("vibe testing"). Leur nature non déterministe et leur capacité à interagir avec des systèmes externes exigent une approche d'AgentOps rigoureuse, une extension des principes DevOps et MLOps.</p> <p>Tests unitaires des outils (Tool Testing)</p> <p>Chaque outil externe (API, base de données, fonction) appelé par l'agent doit être testé isolément. Cela inclut la validation des contrats d'API (schémas d'entrée/sortie), la gestion des authentifications, des timeouts, et des différents scénarios d'erreur (réponses vides, erreurs 4xx/5xx). Un outil défaillant est une défaillance potentielle de tout l'agent.</p> <p>Jeux de cas "golden" (Golden Datasets)</p> <p>Créez un ensemble de scénarios "golden" pour lesquels la réponse ou l'action attendue de l'agent est connue et validée. Ces jeux de données doivent couvrir les cas nominaux, les cas limites et les cas d'erreur. Ils permettent d'évaluer la qualité finale de l'agent de manière reproductible et automatisée, et de suivre la régression des performances au fil des versions.</p> <p>Évaluation des trajectoires (Trajectory Analysis)</p> <p>Il ne suffit pas que l'agent arrive à la bonne réponse, il faut aussi qu'il y arrive de la bonne manière. L'analyse des trajectoires évalue le cheminement de raisonnement de l'agent : le nombre d'étapes, la pertinence des appels d'outils, la présence de boucles inutiles, la cohérence logique et le respect des politiques. Des métriques comme le "tool usage efficiency" ou le "reasoning step count" deviennent essentielles.</p> <p>Scénarios adversariaux (Adversarial Testing)</p> <p>Les agents sont sensibles aux entrées inattendues. Les tests adversariaux consistent à soumettre l'agent à des scénarios conçus pour le piéger : injections de prompts malveillants, requêtes ambiguës, données manquantes ou contradictoires, conflits entre différentes sources d'information. Cela permet d'identifier les vulnérabilités de l'agent et d'améliorer sa robustesse et sa résilience.</p> <h2>Coûts et optimisation économique</h2> <p>Un agent IA peut devenir un gouffre financier si ses coûts ne sont pas maîtrisés dès la conception. La nature itérative du raisonnement agentique et la dépendance aux LLM entraînent des dépenses potentiellement élevées.</p> <p>Sources principales de coûts</p> <ul> <li>Appels LLM : Le coût par token peut sembler minime, mais multiplié par le nombre de requêtes, la taille des contextes et la profondeur des boucles de raisonnement, il devient significatif. Les modèles plus puissants sont souvent plus chers.</li> <li>Utilisation des outils : Certains appels d'API externes peuvent être facturés. Des appels excessifs ou redondants peuvent alourdir la facture.</li> <li>Infrastructure : Le runtime de l'agent (serverless, Kubernetes) a un coût, d'autant plus s'il nécessite des ressources GPU pour l'inférence locale ou des bases de données vectorielles de grande taille.</li> <li>Re-runs et erreurs : Chaque échec ou chaque "retry" dû à une erreur d'outil ou un raisonnement infructueux coûte de l'argent sans apporter de valeur.</li>
</ul> <p>Stratégies d'optimisation</p> <ul> <li>Routage intelligent des modèles : Utiliser le bon modèle pour la bonne tâche. Pour une classification simple, un modèle plus petit et moins cher peut suffire. Garder les LLM les plus puissants pour les tâches complexes de raisonnement ou de génération critique.</li> <li>Caching et mémoire efficace : Mettre en cache les résultats d'appels LLM ou d'outils fréquemment utilisés. Gérer la mémoire de l'agent pour éviter de re-transmettre des contextes inutiles et longs à chaque itération.</li> <li>Prompt engineering pour l'efficacité : Optimiser les prompts pour qu'ils soient concis mais suffisamment informatifs, réduisant ainsi le nombre de tokens traités par le LLM. Encourager le "short-circuiting" du raisonnement quand une réponse rapide est possible.</li> <li>Monitoring des coûts en temps réel : Mettre en place une observabilité fine des dépenses par agent, par tâche, par modèle et par outil. Définir des budgets et des alertes automatiques pour détecter les dérives.</li> <li>Limites d'exécution (Guardrails) : Imposer des limites sur le nombre d'appels LLM, la profondeur des boucles ou le temps d'exécution maximum pour chaque tâche afin d'éviter les consommations excessives.</li>
</ul> <h2>Interopérabilité et anti-lock-in : la flexibilité avant tout</h2> <p>Le marché des agents IA est en constante évolution, avec de nouveaux modèles, plateformes et outils qui apparaissent régulièrement. La stratégie gagnante n'est pas de "choisir le bon fournisseur" unique, mais de concevoir une architecture qui assure une flexibilité maximale et évite le lock-in technologique.</p> <p>Patterns d'architecture pour la flexibilité</p> <ul> <li>Couches d'abstraction claires : Isoler les composants clés de l'agent derrière des interfaces bien définies. Par exemple, une couche d'abstraction pour les appels LLM (permettant de switcher entre OpenAI, Anthropic, Gemini, etc.), une autre pour les bases de données vectorielles (Pinecone, Weaviate, Chroma), ou pour les systèmes RAG.</li> <li>Contrats d'outils standardisés : Définir des schémas d'entrée/sortie uniformes pour tous les outils que l'agent peut appeler. Cela garantit que l'agent peut interagir avec n'importe quel outil compatible sans avoir à adapter son raisonnement pour chaque nouvelle intégration.</li> <li>Connecteurs interchangeables : Construire des "adaptateurs" modulaires pour les services SaaS, les bases de données ou les plateformes d'observabilité. Si un fournisseur change ou si un nouveau doit être intégré, seul le connecteur est à modifier, pas la logique de l'agent.</li> <li>Mécanismes de routage dynamique des modèles : Permettre à l'agent de choisir dynamiquement le modèle le plus approprié (et le plus économique) en fonction de la complexité de la tâche, du domaine de connaissance ou des contraintes de performance.</li>
</ul> <p>L'objectif ultime est de pouvoir changer un fournisseur de modèle, un vector store, un runtime ou une plateforme d'observabilité sans avoir à réécrire une part significative de la logique de l'agent. Cette découplage est une assurance contre la dépendance et un accélérateur d'innovation.</p> <h2>Sécurité : l'agent comme nouvelle surface d'attaque</h2> <p>Un agent IA, surtout s'il est connecté à des outils et doté de capacités d'action, devient un "opérateur" avec des droits. Cette capacité d'action élargit considérablement la surface d'attaque potentielle, nécessitant une approche de sécurité proactive et multi-couches.</p> <p>Scénarios d'attaque spécifiques aux agents</p> <ul> <li>Prompt Injection / Data Poisoning : L'agent est manipulé par des instructions cachées dans des documents, des pages web consultées via RAG, ou des entrées utilisateur malveillantes, le forçant à exécuter des actions non intentionnelles ou à révéler des informations.</li> <li>Exfiltration de données : Un attaquant réussit à faire en sorte que l'agent inclue des données sensibles (numéros de carte de crédit, informations personnelles) dans une réponse, qu'elle soit destinée à l'attaquant ou à un tiers non autorisé.</li> <li>Escalade de privilèges / Actions non autorisées : L'agent est trompé pour utiliser un outil avec des permissions excessives, ou pour exécuter une action qui dépasse son mandat initial, par exemple en supprimant des données ou en modifiant des configurations critiques.</li> <li>Abus de ressources / Déni de service : L'agent est incité à déclencher un nombre excessif d'appels d'outils ou de requêtes LLM, entraînant une explosion des coûts ou une surcharge des systèmes backend.</li> <li>Vulnérabilités de la chaîne d'approvisionnement : Utilisation de connecteurs, de plugins ou de bibliothèques tierces comportant des failles de sécurité, exploitables pour compromettre l'agent.</li>
</ul> <p>Contre-mesures essentielles</p> <ul> <li>Principe du moindre privilège (Least Privilege) : Accorder à l'agent (et à ses outils) uniquement les permissions strictement nécessaires pour accomplir sa tâche. Utiliser des tokens d'accès à courte durée de vie et avec des scopes très précis.</li> <li>Validation côté serveur des actions : Ne jamais faire confiance à l'intention exprimée par l'agent. Toutes les actions critiques (modifications de données, déclenchement de workflows) doivent être validées côté serveur par des règles métier strictes et indépendantes du raisonnement de l'agent.</li> <li>Sandboxing et Allowlisting des outils : Confiner les outils dans des environnements isolés et n'autoriser l'accès qu'à une liste blanche d'outils et de paramètres vérifiés.</li> <li>Redaction systématique des données sensibles : Filtrer et masquer automatiquement les informations confidentielles dans les logs, les requêtes et les réponses de l'agent. Mettre en œuvre une séparation stricte des secrets.</li> <li>Garde-fous "par design" : Intégrer des mécanismes de confirmation humaine pour les actions à haut risque (Human-in-the-Loop), des seuils d'alerte pour les comportements anormaux, et des doubles contrôles pour les décisions critiques.</li> <li>Audit Trail complet : Enregistrer chaque étape du raisonnement de l'agent, chaque appel d'outil, chaque décision et chaque réponse pour une traçabilité forensic en cas d'incident.</li>
</ul> <h2>Gouvernance et conformité : opérer en toute légalité</h2> <p>Au-delà de la sécurité technique, le déploiement d'agents IA en production soulève des questions cruciales de gouvernance d'entreprise et de conformité réglementaire. L'autonomie relative des agents exige une structure claire pour assurer la responsabilité et la transparence.</p> <p>Responsabilité et imputabilité</p> <p>Qui est responsable en cas d'erreur ou de décision incorrecte prise par un agent ? L'entreprise doit établir des lignes claires de responsabilité, en définissant les points de contrôle humains et les mécanismes de révision. L'audit trail devient non seulement un outil de débogage, mais aussi une preuve de diligence.</p> <p>Conformité réglementaire (e.g., RGPD)</p> <p>Si l'agent traite des données personnelles, il doit respecter les principes du RGPD (ou équivalent) : minimisation des données, droit à l'oubli, consentement, sécurité. Le "grounding" sur des sources de données maîtrisées et la "redaction" des informations sensibles sont fondamentaux. Les systèmes de mémoire et de logging doivent être conçus pour supporter la gestion du cycle de vie des données personnelles.</p> <p>Auditabilité et explicabilité légale</p> <p>Dans de nombreux secteurs réglementés, la capacité à expliquer une décision est une exigence légale. Pour un agent, cela signifie pouvoir reconstituer son raisonnement, identifier les données d'entrée utilisées, les outils appelés et les règles appliquées. Les traces d'exécution doivent être exhaustives et conservées conformément aux exigences légales.</p> <p>Politiques et garde-fous organisationnels</p> <p>Mettre en place des politiques claires définissant ce que l'agent a le droit de faire, et dans quelles limites. Ces politiques doivent être codifiées et appliquées via les garde-fous techniques (budgets, limites d'action, validations humaines). Les processus de revue et de validation des "prompts" et des configurations de l'agent doivent être formalisés.</p> <h2>Roadmap de déploiement pragmatique</h2> <p>Industrialiser un agent IA est un parcours itératif. Voici une feuille de route structurée pour passer du POC à la production de manière maîtrisée.</p> <ol> <li>Définir les tâches et les niveaux de risque : Commencez par les cas d'usage où l'agent a une valeur claire et un risque mesuré (ex: lecture et synthèse vs. modification de données critiques). Comprendre le "blast radius" de chaque action.</li> <li>Outiller proprement les capacités d'action : Assurez-vous que les APIs et les fonctions que l'agent peut appeler sont robustes, documentées, avec des contrats clairs, des mécanismes de gestion des erreurs (timeouts, retries) et une sécurité renforcée.</li> <li>Grounder l'agent à la réalité : Intégrez des mécanismes RAG performants pour l'accès aux sources de vérité internes (documents, bases de données). Mettez en place des processus de vérification de l'information et de citation systématique des sources. L'agent doit savoir dire "Je ne sais pas" plutôt que d'inventer.</li> <li>Orchestrer avec des limites strictes : Développez la logique d'orchestration en intégrant des budgets (tokens, appels d'outils), des "stop conditions" (limite de temps ou d'itérations) et des politiques de sécurité qui dictent les actions autorisées.</li> <li>Évaluer systématiquement et au-delà du simple ressenti : Utilisez des jeux de cas "golden", des tests unitaires pour les outils, et des analyses de trajectoires pour mesurer la qualité des résultats et l'efficacité du raisonnement. Intégrez des scénarios adversariaux.</li> <li>Observer de bout en bout l'exécution : Mettez en place un système d'observabilité qui trace chaque étape du raisonnement (planification, appel d'outil, décision), capture les métriques clés (latence, coûts, tokens, taux d'échec) et génère des journaux exploitables, corrélés par requête et avec redaction des données sensibles.</li> <li>Sécuriser l'agent comme un système critique : Appliquez les principes du moindre privilège, des validations côté serveur, du sandboxing et de l'audit trail. Implémentez des garde-fous humains pour les actions à risque élevé.</li> <li>Industrialiser le cycle de vie : Intégrez l'agent dans un processus CI/CD/CT (Continuous Testing). Assurez un versioning complet de tous les composants (modèles, prompts, outils, schémas, index de connaissances, politiques). Mettez en place des capacités de rollback rapides en cas de dégradation.</li>
</ol> <h2>Conclusion : l'évolution des agents et les défis futurs</h2> <p>L'émergence des agents IA marque un tournant majeur, non seulement dans l'informatique, mais aussi dans la manière dont les entreprises opèrent. Ils sont appelés à devenir une couche d'exécution fondamentale, capable de transformer des données en actions autonomes et intelligentes. Cette évolution promet des gains de productivité sans précédent et une capacité d'innovation accrue.</p> <p>Cependant, les défis à venir sont tout aussi significatifs. La complexité inhérente aux architectures d'agents, la nécessité de gérer leur non-déterminisme, la protection contre les risques de sécurité amplifiés, et les impératifs de gouvernance et de conformité exigent une vigilance constante et une expertise pointue. Les agents du futur seront probablement plus modulaires, capables de coopérer (multi-agents), d'apprendre de leurs erreurs (apprentissage continu), et de s'adapter encore plus finement aux nuances du monde réel.</p> <p>Le véritable enjeu pour les entreprises n'est plus de savoir "si" elles doivent adopter les agents IA, mais "comment" elles vont les opérer de manière sûre, fiable et économiquement viable. Celles qui réussiront à maîtriser cette industrialisation transformeront leur mode de fonctionnement en profondeur. Celles qui se contenteront d'approches superficielles risquent de s'exposer à des incidents coûteux et à une perte de confiance. L'agent en production n'est pas un simple assistant ; c'est un nouveau membre à part entière de votre système d'exploitation d'entreprise, nécessitant la même rigueur, la même stratégie et le même investissement que toute autre infrastructure critique.</p> </div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>