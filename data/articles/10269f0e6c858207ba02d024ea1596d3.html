<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Building the Hugging Face MCP Server</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Building the Hugging Face MCP Server</h1>
  <div class="metadata">
    Source: Hugging Face Blog | Date: 7/10/2025 12:00:00 AM | <a href="https://huggingface.co/blog/building-hf-mcp" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div> <p><a href="https://huggingface.co/blog"> Back to Articles</a></p> <div><div> <p><span><span><a href="https://huggingface.co/evalstate"><img alt="shaun smith's avatar" src="https://huggingface.co/avatars/909635453bf62a2a7118a01dd51b811c.svg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/julien-c"><img alt="Julien Chaumond's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/5dd96eb166059660ed1ee413/NQtzmrDdbG0H8qkZvRyGk.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/coyotte508"><img alt="Eliott Coyac's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/61d2f90c3c2083e1c08af22d/jn21aKijwBnopk7aUJUkq.png"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/abidlabs"><img alt="Abubakar Abid's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1621947938344-noauth.png"></a> </span> </span></p> </div></div> <blockquote>
<strong>TL;DR:</strong> The Hugging Face Official MCP Server offers unique customization options for AI Assistants accessing the Hub, along with access to thousands of AI applications through one simple URL. We used MCPs "Streamable HTTP" transport for deployment, and examine in detail the trade-offs that Server Developers have. <p>We've learned many things about building a useful MCP server in the last month - we'll describe our journey here.</p>
</blockquote>
<h2> <a href="#introduction"> </a> <span> Introduction </span>
</h2>
<p>The Model Context Protocol (MCP) is fulfilling its promise of being the standard to connect AI Assistants to the outside world. </p>
<p>At Hugging Face, providing access to the Hub via MCP is an obvious choice, and this article shares our experience developing the <a href="https://hf.co/mcp"><code>hf.co/mcp</code></a> MCP Server.</p>
<h2> <a href="#design-choices"> </a> <span> Design Choices </span>
</h2>
<p>The community uses the Hub for research, development, content creation and more. We wanted to let people customize the server for their own needs, as well as easily access thousands of AI applications available on Spaces. This meant making the MCP Server dynamic by adjusting users' tools on the fly.</p>
<figure> <img alt="The Hugging Face MCP Settings Page" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/hf-mcp-remote/hf-mcp-settings.png"> <figcaption>The <a href="https://huggingface.co/settings/mcp">Hugging Face MCP Settings Page</a> where Users can configure their tools.</figcaption>
</figure> <p>We also wanted to make access simple by avoiding complicated downloads and configuration, so making it remotely accessible via a simple URL was a must.</p>
<h2> <a href="#remote-servers"> </a> <span> Remote Servers </span>
</h2>
<p>When building a remote MCP Server, the first decision is deciding how clients will connect to it. MCP offers several transport options, with different trade-offs. <strong>TL;DR:</strong> our open source code supports all variants, but for production we chose to go with the most modern one. This section goes through the different options in detail. </p>
<p>Since its launch in November 2024, MCP has undergone rapid evolution with 3 protocol revisions in 9 months. This has seen the replacement of the SSE Transport with Streamable HTTP, as well as the introduction and rework of authorization.</p>
<p>These rapid changes mean support for different MCP Features and revisions in Client applications varies, providing extra challenges for our design choices.</p>
<p>Here is a brief summary of the Transport Options offered by the Model Context Protocol and associated SDKs: </p>
<div> <table> <thead><tr>
<th>Transport</th>
<th>Notes</th>
</tr> </thead><tbody><tr>
<td><code>STDIO</code></td>
<td>Typically used when the MCP Server is running on the same computer as the Client. Able to access local resources such as files if needed.</td>
</tr>
<tr>
<td><code>HTTP with SSE</code></td>
<td>Used for remote connections over HTTP. Deprecated in the 2025-03-26 version of MCP but still in use.</td>
</tr>
<tr>
<td><code>Streamable HTTP</code></td>
<td>A more flexible remote HTTP transport that provides more options for deployment than the outgoing SSE version</td>
</tr>
</tbody> </table>
</div>
<p>Both <code>STDIO</code> and <code>HTTP with SSE</code> are fully bi-directional by default - meaning that Client and Server maintain an open connection and can send messages to each other at any time. </p>
<blockquote>
<p>SSE refers to "Server Sent Events" - a way for HTTP Servers to maintain an open connection and send events in response to a request.</p>
</blockquote>
<h4> <a href="#understanding-streamable-http"> </a> <span> Understanding Streamable HTTP </span>
</h4>
<p>MCP Server Developers face a lot of choices when setting up the Streamable HTTP transport.</p>
<p>There are 3 main communication patterns to choose from:</p>
<ul>
<li><strong>Direct Response</strong> - Simple Request/Response (like standard REST APIs). This is perfect for straightforward, stateless operations like simple searches.</li>
<li><strong>Request Scoped Streams</strong> - Temporary SSE Streams associated with a single Request. This is useful for sending <a href="https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress">Progress Updates</a> if the Tool Call takes a long time - such as Video Generation. Additionally the Server may need to request information from the user with an <a href="https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation">Elicitation</a>, or conduct a Sampling request.</li>
<li><strong>Server Push Streams</strong> - Long-lived SSE connection supporting server-initiated messages. This enables Resource, Tool and Prompt List change notifications or ad-hoc Sampling and Elicitations. These connections need extra management such as <a href="https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/ping">keep-alive</a> and resumption mechanics on re-connection.</li>
</ul>
<blockquote>
<p>When using Request Scoped Streams with the official SDKs, use the <code>sendNotification()</code> and <code>sendRequest()</code> methods provided in the <code>RequestHandlerExtra</code> parameter (TypeScript) or set the <code>related_request_id</code> (Python) to send messages to the correct stream.</p>
</blockquote>
<p>An additional factor to consider is whether or not the MCP Server itself needs to maintain state for each connection. This is decided by the Server when the Client sends its Initialize request:</p>
<div> <table> <thead><tr>
<th></th>
<th>Stateless</th>
<th>Stateful</th>
</tr> </thead><tbody><tr>
<td><strong>Session IDs</strong></td>
<td>Not needed</td>
<td>Server responds with an <code>mcp-session-id</code></td>
</tr>
<tr>
<td><strong>What it means</strong></td>
<td>Each request is independent</td>
<td>Server maintains client context</td>
</tr>
<tr>
<td><strong>Scaling</strong></td>
<td>Simple horizontal scaling: any instance can handle any request</td>
<td>Need session affinity or shared state mechanisms</td>
</tr>
<tr>
<td><strong>Resumption</strong></td>
<td>Not needed</td>
<td>May replay messages for broken connections</td>
</tr>
</tbody> </table>
</div>
<p>The table below summarizes the MCP Features and their supported communication pattern:</p>
<div> <table> <thead><tr>
<th>MCP Feature</th>
<th>Server Push</th>
<th>Request Scoped</th>
<th>Direct Response</th>
</tr> </thead><tbody><tr>
<td>Tools, Prompts, Resources</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Sampling/Elicitation</td>
<td>Server Initiated at any time</td>
<td>Related to a Client initiated request</td>
<td>N</td>
</tr>
<tr>
<td>Resource Subscriptions</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Tool/Prompt List Changes</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>Tool Progress Notification</td>
<td>-</td>
<td>Y</td>
<td>N</td>
</tr>
</tbody> </table>
</div>
<p>With Request Scoped streams, Sampling and Elicitation requests need a Stateful connection so that the <code>mcp-session-id</code> can be used for response association.</p>
<blockquote>
<p>The <a href="https://github.com/evalstate/hf-mcp-server">Hugging Face MCP Server</a> is Open Source - and supports STDIO, SSE and Streamable HTTP deployment in both Direct Response and Server Push mode. You can configure keep-alive and last activity timeouts when using Server Push Streams. There's also a built-in observability dashboard that you can use to understand how different Clients manage connections, and handle Tool List change notifications.</p>
</blockquote>
<p>The following picture shows our MCP Server connection dashboard running in "Server Push" Streamable HTTP mode:</p>
<figure> <img alt="The Hugging Face MCP Server Connection Dashboard" src="https://huggingface.co/datasets/huggingface/documentation-images/resolve/main/hf-mcp-remote/hf-mcp-connections.png"> <figcaption>The Hugging Face MCP Server Connection Dashboard.</figcaption>
</figure> <h3> <a href="#production-deployment"> </a> <span> Production Deployment </span>
</h3>
<p>For production, we decided to launch our MCP Server with Streamable HTTP in a Stateless, Direct Response configuration for the following reasons:</p>
<p><strong>Stateless</strong> For anonymous users we supply a standard set of Tools for using the Hub along with an Image Generator. For authenticated users our state comprises their <a href="https://huggingface.co/settings/mcp">selected tools</a> and chosen Gradio applications. We also make sure that users ZeroGPU quota is correctly applied for their account. This is managed using the supplied <code>HF_TOKEN</code> or OAuth credentials that we look up on request. None of our existing tools require us to maintain any other state between requests.</p>
<blockquote>
<p>You can use OAuth login by adding <code>?login</code> to the MCP Server url - e.g. <code>https://huggingface.co/mcp?login</code>. We may make this the default once the <code>claude.ai</code> remote integration supports the latest OAuth spec.</p>
</blockquote>
<p><strong>Direct Response</strong> provides the lowest deployment resource overhead - and we don't currently have any Tools that require Sampling or Elicitation during execution.</p>
<p><strong>Future Support</strong> At launch, the "HTTP with SSE" transport was still the remote default in a lot of MCP Clients. However, we didn't want to invest heavily in managing it due to its imminent deprecation. Fortunately, popular clients had already started making the switch (VSCode and Cursor), and within a week of launch <code>claude.ai</code> also added support. If you need to connect with SSE, feel free to deploy a copy of our Server on a <a href="https://huggingface.co/new-space">FreeCPU Hugging Face Space</a>.</p>
<h4> <a href="#tool-list-change-notifications"> </a> <span> Tool List Change Notifications </span>
</h4>
<p>In the future, we would like to support real-time Tool List Changed notifications when users update their settings on the Hub. However, this raises a couple of practical issues:</p>
<p>First, users tend to configure their favourite MCP Servers in their Client and leave them enabled. This means that the Client remains connected whilst the application is open. Sending notifications would mean maintaining as many open connections as there were currently active Clients - regardless of active usage - on the chance the user updates their tool configuration. </p>
<p>Second, most MCP Servers and Clients disconnect after a period of inactivity, resuming when necessary. This inevitably means that immediate push notifications would be missed - as the notification channel will have been closed. In practice, it is far simpler for the Client to refresh the connection and Tool List as needed.</p>
<p>Unless you have reasonable control over the Client/Server pair, using <strong>Server Push Streams</strong> adds a lot of complexity to a public deployment, when lower-resource solutions for refreshing the Tool List exist.</p>
<h4> <a href="#url-user-experience"> </a> <span> URL User Experience </span>
</h4>
<p>Just before launch, <a href="https://huggingface.co/julien-c"><code>@julien-c</code></a> submitted a PR to include friendly instructions for users visiting <code>hf.co/mcp</code>. This hugely improves the User Experience - the default response is otherwise an unfriendly bit of JSON.</p>
<p>Initially, we found this generated an enormous amount of traffic. After a bit of investigation we found that when returning a web page rather than an HTTP 405 error, VSCode would poll the endpoint multiple times per second! </p>
<p>The fix suggested by <a href="https://huggingface.co/coyotte508"><code>@coyotte508</code></a> was to properly detect browsers and only return the page in that circumstance. Thanks also to the VSCode team who rapidly <a href="https://github.com/microsoft/vscode/pull/251288/files">fixed it</a>. </p>
<p>Although not specifically stated - returning a page in this manner <em>does</em> seem acceptable within the MCP Specification. </p>
<h4> <a href="#mcp-client-behaviour"> </a> <span> MCP Client Behaviour </span>
</h4>
<p>The MCP Protocol sends several requests during initialization. A typical connection sequence is: <code>Initialize</code>, <code>Notifications/Initialize</code>, <code>tools/list</code> and then <code>prompts/list</code>. </p>
<p>Given that MCP Clients will connect and reconnect whilst open, and the fact that users make periodic calls, we find there is a ratio of around 100 MCP Control messages for each Tool Call.</p>
<p>Some clients also send requests that don't make sense for our Stateless, Direct Response configuration - for example Pings, Cancellations or attempts to list Resources (which isn't a capability we currently advertise).</p>
<p>The first week of July 2025 saw an astonishing 164 different Clients accessing our Server. Interestingly, one of the most popular tools is <a href="https://github.com/geelen/mcp-remote"><code>mcp-remote</code></a>. Approximately half of all Clients use it as a bridge to connect to our remote server. </p>
<h2> <a href="#conclusion"> </a> <span> Conclusion </span>
</h2>
<p>MCP is rapidly evolving, and we're excited about what has already been achieved across Chat Applications, IDEs, Agents and MCP Servers over the last few months.</p>
<p>We can already see how powerful integrating the Hugging Face Hub has been and support for Gradio Spaces now makes it possible for LLMs to be easily extended with the latest <a href="https://huggingface.co/blog/gradio-mcp-servers">Machine Learning applications</a>.</p>
<p>Here are some great examples of things people have been doing with our MCP Server so far:</p>
<ul>
<li><a href="https://x.com/victormustar/status/1937095435316822244">Orchestrating Video Production</a></li>
<li><a href="https://x.com/reach_vb/status/1942247029515735263">Image Editing</a></li>
<li><a href="https://x.com/NielsRogge/status/1940472422790242561">Document Searching</a></li>
<li><a href="https://x.com/llmindsetuk/status/1940358288220336514">AI Application Development</a></li>
<li><a href="https://www.linkedin.com/posts/ben-burtenshaw_im-a-big-fan-of-local-models-in-lmstudio-activity-7344001099533590528-zNyw">Adding Reasoning to existing Models</a></li>
</ul>
<p>We hope that this post has provided insights to the decisions that need to be made building Remote MCP Servers, and encourage you to try some of the examples in your favourite MCP Client.</p>
<p>Take a look at our <a href="https://github.com/evalstate/hf-mcp-server">Open Source MCP Server</a>, and try some of the different transport options with your Client, or open an Issue or Pull Request to make improvements or suggest new functionality. </p>
<p>Let us know your thoughts, feedback and questions on this <a href="https://huggingface.co/spaces/huggingface/README/discussions/26">discussion thread</a>.</p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>