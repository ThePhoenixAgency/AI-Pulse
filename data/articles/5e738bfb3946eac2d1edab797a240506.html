<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>How to build custom scanners for web security research automation</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>How to build custom scanners for web security research automation</h1>
  <div class="metadata">
    Source: PortSwigger Research | Date: 10/3/2023 1:34:47 PM | <a href="https://portswigger.net/research/how-to-build-custom-scanners-for-web-security-research-automation" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div> <div> <p><img alt="James Kettle" src="https://portswigger.net/content/images/profiles/callout_james_kettle_112px.png"></p>
</div> <ul> <li> <p><span></span><strong>Published: </strong>03 October 2023 at 13:34 UTC</p> </li> <li> <p><strong>Updated: </strong>01 August 2024 at 08:26 UTC</p> </li> <li> </li> </ul> <p><img src="https://portswigger.net/cms/images/be/7d/784e-article-black-box_automation_blog.png"><br></p><p>In this post, I'll share my approach to developing custom automation to aid research into under-appreciated attack classes and (hopefully) push the boundaries of web security. </p>
<p>As a worked example, I'll build on my research from&nbsp;<a href="https://portswigger.net/research/smashing-the-state-machine">Smashing the state machine: the true potential of web race conditions</a>. If you haven't already seen it, the <a href="https://www.youtube.com/watch?v=tKJzsaB1ZvI&amp;list=PLoX0sUafNGbEkK0ai5P_DB2HDnljRAJyZ">DEFCON recording of this presentation</a> is now available and probably worth a watch.</p>
<h4>Identify the opportunity</h4>
<p>Do you think it's possible to create a scanner that can automatically detect web <a href="https://portswigger.net/web-security/race-conditions">race conditions</a>? I initially dismissed the idea, as the race conditions I found required triggering complex, multi-step authenticated interactions with websites and spotting subtle side-effects.</p>
<p>Over the course of this research, I noticed that race conditions often occur in clusters. They bubble up from shaky libraries and frameworks, so if you spot one in a website it's likely that others lurk nearby. This meant that automated detection of race conditions might be valuable even if the detected races were themselves harmless.</p>
<p>I decided that this idea was worth exploring based on my familiarity with the topic, novel tooling in the form of the single-packet attack, and a test-bed that meant I could try out the concept in a day or two.</p>
<h4>Avoid over-committing</h4>
<p>When attempting to automate something tricky, a common pitfall is to try to automate too much and ultimately fail to achieve anything useful. To avoid this, I like to examine my manual testing methodology and identify the smallest, earliest step that I could plausibly automate. Here's the manual testing process I use for race conditions:</p><p><img src="https://portswigger.net/cms/images/c3/96/d22c-article-methodology.png"><br></p><p>Since the 'predict' phase is just about efficiency, we can skip this and simply try to automate the 'probe' phase. The goal of this phase is to use a batch of concurrent requests to trigger an 'anomaly' and prove that an endpoint might have a sub-state. </p>
<h4>Embrace the unexpected</h4>
<p>I wrote code to send a request ten times sequentially, then resend it ten times in under 1ms using the single-packet attack. I anticipated that on a race-prone website, the concurrent requests might trigger a 50X error response. </p>
<p>At this point I could have improved efficiency and reduced false positives by only targeting dynamic-looking endpoints, and only reporting responses with 50X codes. However, the best research discoveries often come from unexpected outcomes. This means that it's important to avoid writing your expectations into the code. I deliberately left room for unexpected outcomes by testing all observed requests regardless of what they were for, and reporting any difference in status-code. </p>
<p>When it comes to research I'd rather have false positives than false negatives.</p>
<h4>Make iteration easy</h4>
<p>This approach inevitably results in a flood of false positives at the start, so it's crucial that making iterative improvements is painless.</p>
<p>I implemented this in a Burp Suite extension, and as a testbed I used a project file containing the homepage and resources from around ~30,000 websites with bug bounty programs. For more details on this setup, check out <a href="https://portswigger.net/research/cracking-the-lens-targeting-https-hidden-attack-surface">Cracking the lens</a>.</p>
<p>For a full run, I just select all the requests in the proxy, right click, and launch the scan. It prioritises shorter domains so results on high-profile targets tend to turn up quickly.</p>
<h4>Automate your triage</h4>
<p>I typically manually triage a small portion of the findings, then analyse my triage process and automate it. While processing the results I found myself:</p>
<ul><li>Ignoring findings where crucial requests just timed out</li><li>Ignoring findings with 429 status codes as these are just rate-limits</li><li>Ignoring findings with 502/503 as these indicate back-end timeouts</li><li>Trying extra sequential requests after the concurrent batch</li><li>Adding cache-busters to filter out cache behaviour </li></ul>
<p>Implementing this filter process in my scan-check and re-running it left me with a number of promising findings:</p>
<ul> <li>Assorted curious 50X and 307 codes</li> <li>A webserver that issues a cryptic '501 Not Implemented' response claiming it doesn't support GET requests when you use the single-packet attack. </li> <li>A website that triggers a server-side request to a back-end system for SSO purposes. The single-packet attack overloaded the back-end and triggered an error message disclosing the full URL.</li> <li>Another server which intermittently issued a 400 Bad Request response when hit with synchronised requests. This is curious because it suggests that there may be a race condition in their request parsing, which might enable a desync attack. </li></ul>
<p>Unfortunately none of these left me with a clear route forward other than in-depth manual investigation, which I didn't have time for before the conference I was targeting (Nullcon Goa).</p>
<h4>Abuse gadgets</h4>
<p>What I needed was an approach that would detect behaviour that was obviously dangerous.
But what dangerous race-condition can you directly detect from a site's homepage? Well, now and then I've seen reports of applications and caches getting mixed up and either sending responses to the wrong people, or serving up raw memory. The most notorious example of this is, of course, <a href="https://portswigger.net/research/top-10-web-hacking-techniques-of-2017#5">Cloudbleed</a>.</p>
<p>How can we tell if we've received a response intended for someone else? As a human it's easy, and an LLM could probably tell at the price of terrible performance, but it's a tricky question for crude, regex-level automation. </p>
<p>This is where gadgets come in. Gadgets are helpful features present on some websites that make vulnerability detection easier. We can lean on gadgets to quickly and easily explore whether a concept is worth investing more time in. Relying on gadgets for vulnerability detection will cause a lot of false negatives, but during the early stages of research it's worth the trade-off for development speed.</p>
<p>Quite a few websites embed data about the user's request in order to expose it to client-side JavaScript. This typically includes the user's IP address, and request properties like the URL and User-Agent. On sites containing this type of gadget I could detect race-infoleak vulnerabilities by placing a unique 'canary' parameter in every request, then analysing each response to see if it contained a canary from a different request.</p>
<p>This approach initially flagged a lot of websites, but most of them just had cache-poisoning via an <a href="https://portswigger.net/research/web-cache-entanglement">unkeyed query string</a>. </p> <p>After filtering out the cache poisoning and other 'canary storage' behaviour via some more code tweaks, some genuine findings remained. The best example was a certain website where thanks to a race condition, you could obtain the URLs that live users were accessing simply by repeatedly fetching the homepage:</p>
<p><code>window.PAGE_STATE={…{"params":{"utm_souce":"bing",…</code></p>
<p>This was perfect for Nullcon; I knocked together a couple of slides and released the scan-checks in <a href="https://portswigger.net/research/backslash-powered-scanning-hunting-unknown-vulnerability-classes" target="_blank">Backslash Powered Scanner</a>. You can install it via the BApp store, and <a href="https://github.com/PortSwigger/backslash-powered-scanner" target="_blank">peruse the code on Github</a>.</p>
<h4>Wrapping up</h4>
<p>As we've seen, research-oriented scanning is quite different to building a normal scanner so please be careful when cross-applying this advice to other use-cases.</p>
<p>If you'd like to try your hand at custom automation, the <a href="https://portswigger.net/blog/bchecks-houston-we-have-a-solution" target="_blank">new BChecks feature</a> in Burp Suite is designed to make this extra accessible. </p>
<p>If you found this useful, you might also enjoy the presentation <a href="https://www.youtube.com/watch?v=skbKjO8ahCI">Hunting evasive vulnerabilities: finding flaws that others miss</a> where I take a look at research automation from a different angle.</p>
<p>In my next post I'll continue the race condition theme and look beyond HTTP/2 to explore which other protocols support the single-packet attack.</p> <p><a href="https://portswigger.net/research/articles">Back to all articles</a></p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>