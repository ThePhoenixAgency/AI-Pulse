<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Kimina-Prover: Applying Test-time RL Search on Large Formal Reasoning Models</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Kimina-Prover: Applying Test-time RL Search on Large Formal Reasoning Models</h1>
  <div class="metadata">
    Source: Hugging Face Blog | Date: 7/10/2025 12:54:19 PM | <a href="https://huggingface.co/blog/AI-MO/kimina-prover" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><div> <p><a href="https://huggingface.co/blog"> Back to Articles</a></p> <div><div> <p><span><span><a href="https://huggingface.co/HaimingW"><img alt="Haiming Wang's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/65f9013b25145caed6c725a4/Qf0qqqwzU3xitBWkA4ZqC.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/mertunsal"><img alt="Mert Unsal's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/66775fab8c58c5a12ae629ac/rwaS-fPTO2be-UcqSL5y0.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/XiaoHLim"><img alt="Xiaohan Lin's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/635e7a8b875f3e8c2756a4fe/CvATc3ZlDnYWyqq92ynep.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/MantasBaksys"><img alt="MantasBaksys's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/66e0354fa9f50756756f8635/9BqMWr7sB7i9r-uE-kO2h.png"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/ahhwuhu"><img alt="Junqi Liu's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/677f8f9b5b7a01fbc70c609e/bjpFv-Zq0o47mEQaXGwuI.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/dsantosmarco"><img alt="Marco Dos Santos's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/64146fc68ebec947b8c2fddc/tTTdYhcg5cp2U8LGZustC.png"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/floodsung"><img alt="Flood Sung's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/6343d01a08c017b2c042305d/cmJrYkGs9RjDAKfMYCqdW.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/zhenzhe"><img alt="Ying's avatar" src="https://huggingface.co/avatars/f395bfa8e59f2fc80ccbef882473461e.svg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/hehepig166"><img alt="Zhu Zekai's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/noauth/dWgbpoxTIpU9WUdlYiWBv.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/rookiemango"><img alt="lujianqiao's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/64d59835bcab729cb48e3258/cDTTOozta7zCkjkHmbPCQ.png"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/desaxce"><img alt="Hugues de Saxcé's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/650c5818fb7a51088736587b/u8FIlFoylRB3iSwQaBQQv.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/thibautbar"><img alt="Thibaut Barroyer's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/67c7666cd51b75fc80596316/5l5x9PRzLuPwuauN-ZXDW.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/ebony59"><img alt="Ebony Zhang's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/6437b938fac5ea753f1d0ba8/6xxQEmjKmrS1yPUZSoYQP.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/BoltonBailey"><img alt="Bolton Bailey's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/683f0dd9fde42c0912397f59/Kw0b5T64FGHMSn8YJ9RbK.webp"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/UnluckyOrangutan"><img alt="Frederick Pu's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/noauth/mnSJ7cP3UfzyA9qkqaRx-.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/TBUGTB"><img alt="Jonas Bayer's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/noauth/PdtmLEqIkalWWw0tYND6o.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/mavi88"><img alt="Marina Vinyes's avatar" src="https://huggingface.co/avatars/7bfb5978f1c05d7e0a3b9dcdda90859b.svg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/evariste-liu"><img alt="Zhengying Liu's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/6445f82f5691ca69b0df747a/lVILbKYiX6Aw9I97HlPo1.jpeg"></a> </span> </span></p> </div><div> <p><span><span><a href="https://huggingface.co/liyongsea"><img alt="LI Jia's avatar" src="https://cdn-avatars.huggingface.co/v1/production/uploads/1645633727256-621660534b06824e1e5022ed.jpeg"></a> </span> </span></p> </div></div> <p> <b> Numina &amp; Kimi Team</b>
</p> <p><a href="https://hackmd.io/_uploads/BylPdmTHge.png"><img alt="kimina_prover_main_result" src="https://hackmd.io/_uploads/BylPdmTHge.png"></a></p>
<p><strong>Figure 1:</strong> <em>Performance comparison of theorem proving models on the miniF2F-test dataset.</em>
</p> <p>We're excited to announce the release of <strong>Kimina-Prover-72B</strong>, our state-of-the-art theorem proving model trained with the Kimi k1.5<a href="#1">[1]</a> RL pipeline based on Qwen2.5-72B <a href="#2">[2]</a>. Alongside it, we are also releasing two distilled variants: <strong>Kimina-Prover-Distill-8B</strong> and <strong>1.7B</strong> (based on Qwen3-8B and Qwen3-1.7B<a href="#3">[3]</a> respectively).</p>
<p>Our key innovations include:</p>
<ul>
<li><p><strong>Test-Time Reinforcement Learning Search</strong>: A trainable agentic proving framework that enables the model to recursively discover, combine and apply multiple lemmas to construct complex proofs, building on a novel lemma-enabled pattern.</p>
</li>
<li><p><strong>Error-Fixing Capability</strong>: Kimina-Prover can read and interpret Lean’s error messages and propose targeted fixes, demonstrating significantly higher sample efficiency compared to regenerating proofs from scratch.</p>
</li>
</ul>
<p>These advancements enable Kimina-Prover to solve challenging mathematical problems and surpass prior methods. As shown in Figure 1, on the widely used miniF2F benchmark, Kimina-Prover achieves a state-of-the-art pass rate of <strong>92.2%</strong>.</p>
<h2> <a href="#introduction"> </a> <span> Introduction </span>
</h2>
<p>We focus on automated theorem proving (ATP) in the Lean 4 language, aiming to automate the construction of formal mathematical proofs. Recent advances in neural theorem proving have significantly improved the ability of AI systems to assist with or automate this process. Notable progress includes <strong>AlphaProof</strong><a href="#4">[4]</a> from Google DeepMind, which demonstrated strong performance on problems at the level of the International Mathematical Olympiad. Open-source systems such as <strong>DeepSeek-Prover-V2</strong><a href="#5">[5]</a>, which incorporates reinforcement learning, have also achieved state-of-the-art results. In addition, neuro-symbolic agentic approaches like <strong>DSP+</strong><a href="#6">[6]</a> have shown that competitive performance is possible without large-scale training by leveraging off-the-shelf models in a modular framework.</p>
<p>Our earlier work of Kimina-Prover Preview<a href="#7">[7]</a> introduced a large language model for formal theorem proving in Lean, establishing a new performance baseline on the miniF2F benchmark. Trained with a large-scale reinforcement learning pipeline, the model adopted a reasoning-driven exploration paradigm and demonstrated that larger models can serve as stronger formal reasoners. Its structured reasoning pattern enabled efficient proof search and emulated human-like problem-solving strategies.</p>
<p>Following this initial success, we continued to improve the model through further iterations of reinforcement learning. However, single-step reasoning remains insufficient for solving complex problems that require long, multi-stage proofs. To address this limitation, we introduce the Test-Time Reinforcement Learning (TTRL) search framework, which enables the model to discover, combine, and reuse multiple intermediate lemmas autonomously. This framework supports deeper, long-horizon reasoning by decomposing hard problems into reusable subcomponents.</p>
<p>A key ingredient of TTRL search is the <strong>lemma-enabled pattern</strong>, which allows the model to identify and apply intermediate lemmas as part of its proof construction process. This structured reuse of intermediate results significantly expands the model’s problem-solving capability beyond single-step generation.</p>
<p>To further enhance robustness, we also integrate an error-fixing mechanism that interprets Lean’s error messages and proposes targeted corrections. This allows the model to refine its outputs through iterative feedback, improving proof reliability and overall sample efficiency.</p>
<h4> <a href="#a-new-state-of-the-art"> </a> <span> A New State-of-the-Art </span>
</h4> <div> <table> <thead><tr>
<th>Model</th>
<th>pass@1</th>
<th>pass@32</th>
<th>pass@1024</th>
</tr> </thead><tbody><tr>
<td>Kimina-Prover-1.7B</td>
<td>46.7</td>
<td>73.4</td>
<td>—</td>
</tr>
<tr>
<td>DSP+</td>
<td>52.5</td>
<td>71.3</td>
<td>80.7</td>
</tr>
<tr>
<td>DeepSeek-Prover-V2-7B</td>
<td>58.6</td>
<td>75.6</td>
<td>79.9</td>
</tr>
<tr>
<td>Kimina-Prover-8B</td>
<td>61.1</td>
<td>78.3</td>
<td>—</td>
</tr>
<tr>
<td>DeepSeek-Prover-V2-671B</td>
<td>61.9</td>
<td>82.4</td>
<td>86.6</td>
</tr>
<tr>
<td>Kimina-Prover-72B</td>
<td>63.9</td>
<td>84.0</td>
<td>87.7</td>
</tr>
</tbody> </table>
</div> <p><strong>Table 1:</strong> <em>Performance comparison of theorem proving models on the miniF2F-test dataset under equivalent sampling budgets. Kimina-Prover-72B achieves state-of-the-art performance across all evaluated settings.</em>
</p> <p>As the combination of the proposed techniques results in significant improvements in formal theorem proving performance. On the miniF2F benchmark, Kimina-Prover achieves a pass rate of 84.0% with pass@32 and 86.4% with the addition of a single round of error correction. With pass@1024, the pass rate reaches 87.7%. Applying the full Test-Time Reinforcement Learning (TTRL) search framework yields a final pass rate of 92.2%, with an estimated pass upper bound of approximately 42,000. However, this pass budget can be substantially optimized in future versions, as a large portion of the current sampling is spent on proving unhelpful or redundant lemmas.</p>
<p>Notably, these results indicate a shift in the scaling behavior of the prover. While earlier versions exhibited approximately linear improvements in log scale with increasing sampling budget, the current system shows diminishing returns beyond pass@1024. This suggests that further gains are less dependent on increased sampling and instead require more sophisticated search strategies, such as those introduced by TTRL.</p>
<h2> <a href="#methodology"> </a> <span> Methodology </span>
</h2>
<h3> <a href="#lemma-enabled-pattern"> </a> <span> Lemma enabled pattern </span>
</h3>
<p>The lemma-enabled pattern is designed to equip the model with the ability to identify and utilize useful lemmas provided in the input. To support this capability, during reinforcement learning (RL) training, a random subset of one to three formal lemmas is prepended to the problem context, exposing the prover to potentially useful intermediate results that can aid in constructing the final proof. These lemmas are prepared through a two-step pipeline: (1) a general-purpose LLM generates candidate lemmas in natural language; (2) these are then translated into formal statements using our <code>Kimina-Autoformalizer-7b</code>.</p>
<p>Initial observations showed that the model had a low tendency to incorporate the provided lemmas. To address this, we introduced a preference-based reward shaping strategy within the RL framework. When a theorem could be proven through multiple trajectories, solutions that successfully leveraged a provided lemma were assigned a higher reward, while those that did not were penalized. This approach proved effective, increasing the lemma utilization rate to a stable 30–40% after training. Importantly, this method not only encouraged lemma usage but also promoted selectivity: the model learned to apply lemmas strategically when they were useful, while ignoring irrelevant ones, demonstrating more efficient and human-like reasoning behavior.</p>
<h2> <a href="#ttrl-search"> </a> <span> TTRL search </span>
</h2>
<p><a href="https://hackmd.io/_uploads/H119Z46Sge.png"><img alt="kimina-prover-ttrl-search-fixed-fixed" src="https://hackmd.io/_uploads/H119Z46Sge.png"></a></p> <p><strong>Figure 2:</strong> <em>Diagram of the Test-Time Reinforcement Learning (TTRL) Search framework. It is composed of three main components: RL training, sublemma generation, and negation filtering. Sublemmas are generated and formalized, then integrated into the training loop with dynamic scoring and pruning. A negation filter ensures logical consistency by discarding invalid lemmas.</em>
</p> <p>The <strong>lemma-enabled pattern</strong> allowed the model to incorporate pre-generated lemmas as intermediate steps in constructing proofs. However, we observed that randomly sampling and inserting lemmas was insufficient for solving complex problems requiring highly structured and deeply nested reasoning. To address this limitation, we developed the <strong>Test-Time Reinforcement Learning Search</strong> framework—a trainable, agentic approach that systematically organizes, filters, and composes a large set of candidate lemmas to build complete proofs. This framework transitions the process from random exploration to a more strategic, goal-directed search.</p>
<p>As illustrated in Figure 2, we define the <strong>search scope</strong> of each problem as the problem itself along with its associated candidate lemmas. TTRL Search tracks a <strong>lemma utilization score</strong> within each search scope to measure how frequently and effectively each lemma contributes to the final proof. At the beginning of each RL training iteration, for each problem (i.e., search scope), we construct <strong>K = 10</strong> input variants by prepending different combinations of lemmas. To balance exploration and exploitation, <strong>60%</strong> of the inputs are built using the top-ranking lemmas—those with the highest utilization scores—focusing the model on the most promising proof paths. The remaining <strong>40%</strong> are formed by including these top lemmas alongside one to four randomly selected additional lemmas, encouraging exploration of novel and potentially useful lemma combinations.</p>
<p>To ensure quality, a <strong>filtering mechanism</strong> prunes lemmas that consistently fail to contribute meaningfully: any lemma that fails to achieve a utilization score of at least τ=0.10 after 50 insertion attempts is removed from the search pool.</p>
<p>A key feature of TTRL is its <strong>recursive search mechanism</strong>. The search scope is not limited to the original theorem but is also maintained for each lemma, allowing the framework to recursively decompose the problem into smaller subproblems. A parallel <strong>sublemma generation process</strong> runs throughout, and whenever a theorem or lemma fails to find a proof after <strong>N = 128</strong> attempts, new candidate sublemmas are generated. This recursive strategy enables test-time scaling of reasoning depth, significantly extending the model’s effective problem-solving capability.</p>
<p>To maintain logical soundness, we address a failure mode wherein incorrectly formalized lemmas could lead to trivial or invalid proofs. In such cases, the model may exploit inconsistencies to construct seemingly valid but unsound solutions. To prevent this, we introduce a <strong>negation proving process</strong>: for each newly generated lemma, we attempt to prove its logical negation. If the negated statement is provable, it indicates that the original lemma is logically inconsistent and is immediately discarded. This step ensures the reliability and soundness of the overall proof construction process.</p>
<h2> <a href="#enabling-error-fixing-in-kimina-prover"> </a> <span> Enabling Error-Fixing in Kimina-Prover </span>
</h2>
<p>A critical limitation of recent advanced theorem proving models is their lack of the ability to correct proofs based on feedback from the proof assistant—capabilities that human users routinely leverage. To address this gap, we developed a dedicated framework to integrate <strong>error-fixing capabilities</strong> into Kimina-Prover.</p>
<p><strong>SFT Data Generation for Error Correction.</strong> General-purpose large language models exhibit a low success rate when interpreting Lean’s error messages and proposing valid corrections. To overcome this, we constructed a specialized <strong>Supervised Fine-Tuning (SFT)</strong> dataset tailored for error correction. This dataset consists of triplets in the form of <em>(incorrect proof, Lean feedback, correct proof)</em>. To enrich the supervision signal, we prompted Claude 3.7 sonnet<a href="#8">[8]</a> to synthesize step-by-step reasoning chains explaining how the incorrect proof can be transformed into the correct one using the provided feedback. The result is a high-quality dataset that includes not only the initial and corrected proofs but also the intermediate reasoning, facilitating more effective learning.</p>
<p><strong>Batched Failure Replay Strategy.</strong> Integrating error correction directly into the reinforcement learning (RL) loop initially proved ineffective due to the low success rate (~1%) of the SFT model in fixing errors, resulting in sparse rewards and unstable training. To address this, we designed the <strong>Batched Failure Replay</strong> strategy. Rather than attempting to correct errors immediately during an RL iteration, all failed proof attempts from iteration <em>N</em> are collected. In the subsequent iteration <em>N+1</em>, the training batch is composed of a fixed-size union of these prior failures (e.g., 500 samples) and standard problems from the prompt set (e.g., another 500 samples). This ensures consistent and high-volume exposure to error correction tasks in each training step, enabling the model to gradually learn effective error-handling behaviors in a stable and data-efficient manner.</p> <div> <table> <thead><tr>
<th></th>
<th>16+16 attempt-and-fix</th>
<th>32×1 brute-force</th>
<th>32+32 attempt-and-fix</th>
</tr> </thead><tbody><tr>
<td>kimina-prover</td>
<td>35.6</td>
<td>28.8</td>
<td>44.1</td>
</tr>
</tbody> </table>
</div> <p><strong>Table 2:</strong> <em>Performance comparison between error-fixing and brute-force strategies on a selected subset of 59 MiniF2F-Test problems with the lowest win rates. Under equal sample budgets, the error-fixing strategies (16+16) outperform the brute-force baseline (32×1), demonstrating improved sample efficiency.</em>
</p> <p>This training approach led to measurable improvements in the model’s ability to recover from failure. The model advanced from correcting basic syntax errors to resolving complex logical mistakes and, eventually, discovering alternative proof strategies when initial attempts failed. Crucially, this capability improved sample efficiency. As shown in Table 2, we compared different strategies under fixed computational budgets. The 16+16 attempt-and-fix strategy—consisting of 16 initial proof attempts, each followed by one error-fixing attempt—achieved a success rate of 35.6%, outperforming the 32×1 brute-force baseline, which reached 28.8% with 32 independent attempts. Further increasing the sample budget to 32+32 with error correction yielded a success rate of 44.1%. These results demonstrate that enabling the model to correct its own errors is a more efficient use of computational resources than repeated trial-and-error.</p>
<h2> <a href="#other-improvement"> </a> <span> Other improvement </span>
</h2>
<p>In addition to our core TTRL search and Error fixing, we developed several other novel techniques to enhance the model's learning process and problem-solving capabilities.</p>
<p><strong>Prompt Set Curation and Iteration.</strong> Effective data curation is critical for reinforcement learning (RL) efficiency. Our initial prompt set of over 300K problems was refined to a competition-focused subset of approximately 90K, with an emphasis on problems from sources such as the <em>olympiads-ref</em> subset of NuminaMath 1.5<a href="#9">[9]</a>. During RL, we applied <strong>dynamic filtering</strong>: problems with consistently high success rates were removed to maintain challenge, while persistently difficult problems were decomposed into simpler subproblems or variations using a general-purpose LLM. The final prompt set combines auto-formalized statements for broad coverage, human-annotated problems for quality, and augmented variations for targeted skill development. The curated prompt set will be open-sourced.</p>
<p><strong>Continuous Pre-training on Lean Data.</strong> To address the limited Lean proficiency in most base models, we applied Continuous Pre-training (CPT). A 6-billion-token CPT dataset was constructed from multiple sources: 260M tokens from online platforms such as GitHub, 5.5B tokens of compiler-validated rollout data from our RL pipeline, and additional structured data in <code>state–tactic–state</code> and <code>state–tactic–error</code> formats to enhance diversity. These structured data supplements the base model with additional domain knowledge.</p>
<p><strong>Random Proof Cut Data Augmentation.</strong> To better utilize high-quality, human-annotated proofs that lack intermediate reasoning steps, we developed the <strong>Random Proof Cut</strong> technique. This method augments such data using two variations:</p>
<ul>
<li><strong>Proof truncation</strong>: The final part of a proof is removed, and the model must complete it.</li>
<li><strong>Proof infilling</strong>: A randomly selected internal block is replaced with the placeholder token <code>sorry</code>, and the model must reconstruct the missing steps.</li>
</ul>
<p>This strategy allows the model to learn how to extend existing lines of reasoning and to fill in logical gaps, effectively integrating human-generated content into the training process.</p>
<p><strong>Non-proof Problem Solving.</strong> Many problems are presented in the form of requiring a final answer, which cannot be naturally framed as a traditional proof task. Inspired by the CombiBench<a href="#10">[10]</a> evaluation methodology, we introduced a capability for non-proof problem solving to unify answer generation with proof construction. In this setting, the model is given a problem with the final answer field left blank. It performs a two-stage process within a single inference: it first deduces the correct answer and then generates a complete formal proof to justify that answer. This approach ensures the model’s reasoning is explicitly conditioned on reaching the correct solution.</p>
<h2> <a href="#sample-proof-cases"> </a> <span> Sample proof cases </span>
</h2>
<p>Here we provide some proof cases found by our newest Kimina-prover model. The complete list of solved miniF2F problems is available on <a href="https://github.com/MoonshotAI/Kimina-Prover-Preview">GitHub</a></p>
<h3> <a href="#ttrl-search-proof-example"> </a> <span> TTRL search proof example </span>
</h3>
<p>The system recursively decomposed the problem into four layers of lemmas using a TTRL search approach, ultimately generating a 520-line formal proof. During this recursive proving process, initially, only one lemma, <code>sum_cexp_div_pow_ne_zero</code>, remained to be solved. While this conclusion seems straightforward to prove informally, it would still require a lot of steps to prove it rigorously in Lean 4. Our system recursively generated two extra layers of lemmas and obtained a 260-line formal proof for <code>sum_cexp_div_pow_ne_zero</code>. <strong>This proof is valid under Mathlib v4.15</strong></p> Sample proof for imo 1969 p2 <h3> <a href="#proof-structure"> </a> <span> Proof structure </span>
</h3> <p><img alt="drawing" src="https://hackmd.io/_uploads/SkdQtJaSxg.png"> </p>
<p><strong>Figure 3:</strong> <em>Proof dependency graph for the theorem imo_1969_p2, illustrating the structure of lemma references and calls. Each node represents a lemma or theorem, with directed edges indicating dependency relationships (i.e., one lemma calling another). Lemma names are randomly generated during proof construction; for clarity, we manually renamed them post hoc to reflect their mathematical content more accurately.</em>
</p>
<br> <h3> <a href="#formal-code"> </a> <span> Formal code </span>
</h3>
<pre><code>import Mathlib open Finset in
theorem norm_le_sum_norm_of_sum_eq_zero {N : ℕ} (hN : N &gt; 0) (z : ℕ → ℂ) (hsum : ∑ i ∈ range N, z i = 0) : ‖z 0‖ ≤ ∑ i ∈ Icc 1 (N - 1), ‖z i‖ := by by_cases h : N &gt; 1 · have h6 : ∑ i in range N, z i = z 0 + ∑ i in Icc 1 (N - 1), z i := by have h10 : range N = {0} ∪ Icc 1 (N - 1) := by ext x simp omega rw [h10] rw [sum_union] · simp · apply disjoint_left.mpr intro x hx1 hx2 simp at hx1 simp [hx1] at hx2 have h3 : z 0 = - (∑ i ∈ Icc 1 (N - 1), z i) := by have h4 : ∑ i in range N, z i = 0 := hsum rw [h6] at h4 calc z 0 = (z 0 + ∑ i in Icc 1 (N - 1), z i) - ∑ i in Icc 1 (N - 1), z i := by ring _ = (0 : ℂ) - ∑ i in Icc 1 (N - 1), z i := by rw [h4] _ = - (∑ i in Icc 1 (N - 1), z i) := by ring have h11 : ‖z 0‖ = ‖(∑ i ∈ Icc 1 (N - 1), z i : ℂ)‖ := by rw [h3] simp [norm_neg] have h12 : ‖(∑ i ∈ Icc 1 (N - 1), z i : ℂ)‖ ≤ ∑ i ∈ Icc 1 (N - 1), ‖z i‖ := by apply norm_sum_le linarith [h11, h12] · have h5 : N = 1 := by omega rw [h5] have h6 : ∑ i in range 1, z i = 0 := by have h7 : N = 1 := h5 have h8 : ∑ i in range N, z i = 0 := hsum rw [show N = 1 by omega] at h8 simpa using h8 have h7 : z 0 = 0 := by simp at h6 all_goals try tauto rw [show z 0 = (0 : ℂ) by exact h7] simp open Finset in
theorem sum_pow_one_half_from_two_to_N {N : ℕ} (hN : 0 &lt; N) : ∑ j ∈ Icc 1 (N - 1), (1 / 2 : ℝ) ^ (j + 1) = 1 / 2 - 1 / 2 ^ N := by have h2 : ∀ (k : ℕ), ∑ j in Icc 1 (k), (1 / 2 : ℝ) ^ (j + 1) = 1 / 2 - 1 / 2 ^ (k + 1 : ℕ) := by intro k induction k with | zero =&gt; simp | succ k ihk =&gt; rw [sum_Icc_succ_top (by linarith)] rw [ihk] field_simp at * ring_nf have h4 : ∑ j in Icc 1 (N - 1), (1 / 2 : ℝ) ^ (j + 1) = 1 / 2 - 1 / 2 ^ (N : ℕ) := by have h5 : ∑ j in Icc 1 (N - 1), (1 / 2 : ℝ) ^ (j + 1) = 1 / 2 - 1 / 2 ^ ((N - 1 : ℕ) + 1 : ℕ) := by apply h2 (N - 1) rw [h5] have h6 : (N - 1 : ℕ) + 1 = N := by omega rw [h6] exact h4 open Complex Finset in
theorem sum_eq_zero_of_sq_add_sq_eq_geom_seq_false {N : ℕ} (hN : 0 &lt; N) (x y : Fin N → ℝ) (hxsum : ∑ i : Fin N, x i = 0) (hysum : ∑ i : Fin N, y i = 0) (hxy : ∀ j : Fin N, (x j)^2 + (y j)^2 = (1/4)^(j.1+1)) : False := by let z : ℕ → ℂ := fun i =&gt; if h : i &lt; N then (x ⟨i, h⟩ : ℂ) + (y ⟨i, h⟩ : ℂ) * I else 0 have hsumz : ∑ i in range N, z i = 0 := by have h4 : ∑ i in range N, z i = (∑ i : Fin N, ((x i : ℂ) + (y i : ℂ) * I)) := by simp [z, Finset.sum_fin_eq_sum_range, Finset.sum_congr] rw [h4] simp [Complex.ext_iff, Finset.sum_congr, hxsum, hysum] have hz0 : ‖z 0‖ ≤ ∑ i ∈ Icc 1 (N - 1), ‖z i‖ := norm_le_sum_norm_of_sum_eq_zero hN z hsumz have h2 : ‖z 0‖ = (1 / 2 : ℝ) := by have h6 : z 0 = (x ⟨0, by omega⟩ : ℂ) + (y ⟨0, by omega⟩ : ℂ) * I := by have h7 : (0 : ℕ) &lt; N := by omega simp [z, h7] rw [h6] have h7 : ((x ⟨0, by omega⟩ : ℝ) ^ 2 + (y ⟨0, by omega⟩ : ℝ) ^ 2) = (1 / 4 : ℝ) := by have h8 := hxy (⟨0, by omega⟩) norm_num at h8 ⊢ nlinarith have h8 : ‖((x ⟨0, by omega⟩ : ℂ) + (y ⟨0, by omega⟩ : ℂ) * I)‖ = Real.sqrt ((x ⟨0, by omega⟩ : ℝ) ^ 2 + (y ⟨0, by omega⟩ : ℝ) ^ 2) := by simp [Complex.norm_eq_abs, Complex.abs, Complex.normSq] all_goals ring_nf rw [h8, h7] have h9 : Real.sqrt ((1 / 4 : ℝ)) = (1 / 2 : ℝ) := by rw [Real.sqrt_eq_iff_mul_self_eq] &lt;;&gt; norm_num rw [h9] have h3 : ∑ i ∈ Icc 1 (N - 1), ‖z i‖ = ∑ i ∈ Icc 1 (N - 1), (1 / 2 : ℝ) ^ (i + 1 : ℕ) := by apply Finset.sum_congr . rfl . intro i hi have h10 : i ≥ 1 := by have h11 : i ∈ Icc (1 : ℕ) (N - 1) := by simpa using hi simp at h11 ⊢ omega have h11 : i ≤ N - 1 := by have h12 : i ∈ Icc (1 : ℕ) (N - 1) := by simpa using hi simp at h12 ⊢ omega have h12 : i &lt; N := by omega have h13 : z i = (x ⟨i, by omega⟩ : ℂ) + (y ⟨i, by omega⟩ : ℂ) * I := by have h14 : i &lt; N := by omega simp [z, h14] have h14 : ‖z i‖ = (1 / 2 : ℝ) ^ (i + 1 : ℕ) := by rw [h13] have h14 : ((x ⟨i, by omega⟩ : ℝ) ^ 2 + (y ⟨i, by omega⟩ : ℝ) ^ 2) = (1 / 4 : ℝ) ^ (i + 1 : ℕ) := by have h15 := hxy (⟨i, by omega⟩) norm_num at h15 ⊢ nlinarith have h15 : ‖((x ⟨i, by omega⟩ : ℂ) + (y ⟨i, by omega⟩ : ℂ) * I)‖ = Real.sqrt ((x ⟨i, by omega⟩ : ℝ) ^ 2 + (y ⟨i, by omega⟩ : ℝ) ^ 2) := by simp [Complex.norm_eq_abs, Complex.abs, Complex.normSq] all_goals ring_nf rw [h15] have h16 : Real.sqrt ((x ⟨i, by omega⟩ : ℝ) ^ 2 + (y ⟨i, by omega⟩ : ℝ) ^ 2) = (1 / 2 : ℝ) ^ (i + 1 : ℕ) := by have h17 : ((x ⟨i, by omega⟩ : ℝ) ^ 2 + (y ⟨i, by omega⟩ : ℝ) ^ 2) = (1 / 4 : ℝ) ^ (i + 1 : ℕ) := h14 rw [h17] have h18 : Real.sqrt ((1 / 4 : ℝ) ^ (i + 1 : ℕ)) = (1 / 2 : ℝ) ^ (i + 1 : ℕ) := by have h19 : ((1 / 4 : ℝ) : ℝ) = (1 / 2 : ℝ) ^ (2 : ℕ) := by norm_num rw [h19] have h20 : Real.sqrt (((1 / 2 : ℝ) ^ (2 : ℕ)) ^ (i + 1 : ℕ)) = (1 / 2 : ℝ) ^ (i + 1 : ℕ) := by have h21 : ((1 / 2 : ℝ) ^ (2 : ℕ)) ^ (i + 1 : ℕ) = ((1 / 2 : ℝ) ^ (i + 1 : ℕ)) ^ 2 := by have h22 : ((1 / 2 : ℝ) ^ (2 : ℕ)) ^ (i + 1 : ℕ) = (1 / 2 : ℝ) ^ (2 * (i + 1 : ℕ) : ℕ) := by rw [← pow_mul] all_goals ring_nf have h23 : ((1 / 2 : ℝ) ^ (i + 1 : ℕ)) ^ 2 = (1 / 2 : ℝ) ^ (2 * (i + 1 : ℕ) : ℕ) := by ring_nf rw [h22, h23] rw [h21] have h22 : Real.sqrt (((1 / 2 : ℝ) ^ (i + 1 : ℕ)) ^ 2) = (1 / 2 : ℝ) ^ (i + 1 : ℕ) := by rw [Real.sqrt_sq (show (1 / 2 : ℝ) ^ (i + 1 : ℕ) ≥ 0 by positivity)] rw [h22] exact h20 exact h18 exact h16 linarith rw [h3] at hz0 rw [h2] at hz0 have h6 : ∑ i ∈ Icc 1 (N - 1), (1 / 2 : ℝ) ^ (i + 1 : ℕ) = (1 / 2 - 1 / 2 ^ N : ℝ) := by have h7 : ∑ i ∈ Icc 1 (N - 1), (1 / 2 : ℝ) ^ (i + 1 : ℕ) = (1 / 2 - 1 / 2 ^ N : ℝ) := sum_pow_one_half_from_two_to_N hN linarith rw [h6] at hz0 have h7 : (1 / 2 ^ N : ℝ) &gt; 0 := by have h10 : (1 / 2 ^ N : ℝ) &gt; 0 := by have h11 : (1 / 2 ^ N : ℝ) = (1 / 2 : ℝ) ^ N := by ring_nf rw [h11] positivity linarith have h11 : (1 / 2 - 1 / 2 ^ N : ℝ) &lt; (1 / 2 : ℝ) := by have h12 : (1 / 2 ^ N : ℝ) &gt; 0 := h7 linarith linarith open BigOperators Real Nat Topology Rat in
theorem sum_cexp_div_pow_ne_zero {N : ℕ} (hN : N &gt; 0) (a : Fin N → ℝ) : ((∑ j : Fin N, cos (a j) / 2 ^ (j : ℕ))^2 + (∑ j : Fin N, sin (a j) / 2 ^ (j : ℕ))^2) &gt; 0 := by by_contra h push_neg at h have h1 : (∑ j : Fin N, cos (a j) / 2 ^ (j : ℕ)) ^ 2 ≥ 0 := by apply sq_nonneg have h2 : (∑ j : Fin N, sin (a j) / 2 ^ (j : ℕ)) ^ 2 ≥ 0 := by apply sq_nonneg have h3 : (∑ j : Fin N, cos (a j) / 2 ^ (j : ℕ)) ^ 2 = 0 := by linarith have h4 : (∑ j : Fin N, sin (a j) / 2 ^ (j : ℕ)) ^ 2 = 0 := by linarith have h5 : (∑ j : Fin N, cos (a j) / 2 ^ (j : ℕ)) = 0 := by nlinarith have h6 : (∑ j : Fin N, sin (a j) / 2 ^ (j : ℕ)) = 0 := by nlinarith let x : Fin N → ℝ := fun j =&gt; cos (a j) / 2 ^ (j.1 + 1 : ℕ) let y : Fin N → ℝ := fun j =&gt; sin (a j) / 2 ^ (j.1 + 1 : ℕ) have hxsum : ∑ i : Fin N, x i = 0 := by have eq2 : ∑ i : Fin N, x i = (∑ i : Fin N, (cos (a i) / 2 ^ (i.1 : ℕ) : ℝ)) / 2 := by have eq3 : ∑ i : Fin N, x i = ∑ i : Fin N, (cos (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) := by congr rw [eq3] have eq4 : ∑ i : Fin N, (cos (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) = (∑ i : Fin N, (cos (a i) / 2 ^ (i.1 : ℕ) : ℝ)) / 2 := by calc ∑ i : Fin N, (cos (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) = ∑ i : Fin N, ((cos (a i) / 2 ^ (i.1 : ℕ) : ℝ) / 2) := by apply Finset.sum_congr . rfl intro i hi have h12 : (cos (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) = (cos (a i) / 2 ^ (i.1 : ℕ) : ℝ) / 2 := by have h11 : (2 : ℝ) ^ (i.1 + 1 : ℕ) = (2 : ℝ) ^ (i.1 : ℕ) * 2 := by ring_nf rw [h11] field_simp all_goals ring exact h12 _ = (∑ i : Fin N, (cos (a i) / 2 ^ (i.1 : ℕ) : ℝ)) / 2 := by simp [Finset.sum_div] exact eq4 rw [eq2] rw [show ∑ i : Fin N, (cos (a i) / 2 ^ (i.1 : ℕ) : ℝ) = (0 : ℝ) by simpa using h5] all_goals norm_num have hysum : ∑ i : Fin N, y i = 0 := by have eq2 : ∑ i : Fin N, y i = (∑ i : Fin N, (sin (a i) / 2 ^ (i.1 : ℕ) : ℝ)) / 2 := by have eq3 : ∑ i : Fin N, y i = ∑ i : Fin N, (sin (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) := by congr rw [eq3] have eq4 : ∑ i : Fin N, (sin (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) = (∑ i : Fin N, (sin (a i) / 2 ^ (i.1 : ℕ) : ℝ)) / 2 := by calc ∑ i : Fin N, (sin (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) = ∑ i : Fin N, ((sin (a i) / 2 ^ (i.1 : ℕ) : ℝ) / 2) := by apply Finset.sum_congr . rfl intro i hi have h12 : (sin (a i) / 2 ^ (i.1 + 1 : ℕ) : ℝ) = (sin (a i) / 2 ^ (i.1 : ℕ) : ℝ) / 2 := by have h11 : (2 : ℝ) ^ (i.1 + 1 : ℕ) = (2 : ℝ) ^ (i.1 : ℕ) * 2 := by ring_nf rw [h11] field_simp all_goals ring exact h12 _ = (∑ i : Fin N, (sin (a i) / 2 ^ (i.1 : ℕ) : ℝ)) / 2 := by simp [Finset.sum_div] exact eq4 rw [eq2] rw [show ∑ i : Fin N, (sin (a i) / 2 ^ (i.1 : ℕ) : ℝ) = (0 : ℝ) by simpa using h6] all_goals norm_num have hxy : ∀ j : Fin N, (x j) ^ 2 + (y j) ^ 2 = (1 / 4 : ℝ) ^ (j.1 + 1 : ℕ) := by intro j have h11 : cos (a j) ^ 2 + sin (a j) ^ 2 = 1 := by exact Real.cos_sq_add_sin_sq (a j) simp [x, y] have h12 : (4 : ℝ) ^ (j.1 + 1 : ℕ) = (2 : ℝ) ^ (2 * (j.1 + 1 : ℕ)) := by have h13 : (4 : ℝ) = (2 : ℝ) ^ (2 : ℕ) := by norm_num rw [h13] rw [← pow_mul] have h13 : (2 : ℝ) ^ (2 * (j.1 + 1 : ℕ)) = ((2 : ℝ) ^ (j.1 + 1 : ℕ)) ^ 2 := by ring_nf field_simp [h11, h12, h13] all_goals ring_nf have h12 : False := sum_eq_zero_of_sq_add_sq_eq_geom_seq_false (show 0 &lt; N by omega) x y hxsum hysum hxy tauto open BigOperators Real Nat Topology Rat in
theorem mul_cos_sub_mul_sin_eq_mul_cos_add (C S : ℝ) (h : C ^ 2 + S ^ 2 ≠ 0) : ∃ R α : ℝ, R &gt; 0 ∧ ∀ x : ℝ, C * cos x - S * sin x = R * cos (x + α) := by have h1 : C ^ 2 + S ^ 2 &gt; 0 := by by_contra h2 push_neg at h2 have h3 : C ^ 2 ≥ 0 := sq_nonneg C have h4 : S ^ 2 ≥ 0 := sq_nonneg S have h5 : C ^ 2 + S ^ 2 = 0 := by nlinarith tauto have h2 : ∃ R : ℝ, R &gt; 0 ∧ R ^ 2 = C ^ 2 + S ^ 2 := by use Real.sqrt (C ^ 2 + S ^ 2) constructor · -- Show that sqrt (C^2 + S^2) &gt; 0 apply Real.sqrt_pos.mpr linarith · -- Show that (sqrt (C^2 + S^2)) ^ 2 = C^2 + S^2 rw [Real.sq_sqrt] positivity rcases h2 with ⟨R, hR_pos, hR_sq⟩ have h12 : (C / R) ^ 2 + (S / R) ^ 2 = 1 := by have h14 : R ≠ 0 := by linarith have h15 : R ^ 2 = C ^ 2 + S ^ 2 := hR_sq field_simp at * nlinarith have h13 : ∃ α : ℝ, Real.cos α = C / R ∧ Real.sin α = S / R := by have h9 : (C / R) ^ 2 + (S / R) ^ 2 = 1 := h12 by_cases hC : C ≥ 0 · -- C ≥ 0 use Real.arcsin (S / R) constructor · -- Show cos (arcsin (S / R)) = C / R have h14 : Real.cos (Real.arcsin (S / R)) = Real.sqrt (1 - (S / R) ^ 2) := by rw [Real.cos_arcsin] have h15 : Real.sqrt (1 - (S / R) ^ 2) = C / R := by have h151 : (C / R) ^ 2 = 1 - (S / R) ^ 2 := by linarith [h9] have h161 : Real.sqrt (1 - (S / R) ^ 2) = Real.sqrt ((C / R) ^ 2) := by rw [show 1 - (S / R) ^ 2 = (C / R) ^ 2 by linarith [h9]] rw [h161] have h171 : Real.sqrt ((C / R) ^ 2) = C / R := by apply Real.sqrt_sq (show 0 ≤ C / R by have h211 : R &gt; 0 := hR_pos apply div_nonneg linarith linarith ) rw [h171] rw [h14, h15] · -- Show sin (arcsin (S / R)) = S / R have h20 : -1 ≤ S / R := by have h6 : (S / R) ^ 2 ≤ 1 := by nlinarith [h9] nlinarith [sq_nonneg (S / R - 1), sq_nonneg (S / R + 1)] have h21 : S / R ≤ 1 := by have h6 : (S / R) ^ 2 ≤ 1 := by nlinarith [h9] nlinarith [sq_nonneg (S / R - 1), sq_nonneg (S / R + 1)] have h18 : Real.sin (Real.arcsin (S / R)) = S / R := by apply Real.sin_arcsin all_goals linarith rw [h18] · -- C &lt; 0 have hC2 : C &lt; (0 : ℝ) := by linarith have hC3 : C / R &lt; 0 := by have hR_pos1 : R &gt; 0 := hR_pos apply div_neg_of_neg_of_pos hC2 (by linarith) use Real.pi - Real.arcsin (S / R) constructor · -- Show cos (π - arcsin (S / R)) = C / R have h28 : Real.cos (Real.pi - Real.arcsin (S / R)) = - Real.sqrt (1 - (S / R) ^ 2) := by have h1 : Real.cos (Real.pi - Real.arcsin (S / R)) = - Real.cos (Real.arcsin (S / R)) := by rw [Real.cos_pi_sub] have h2 : Real.cos (Real.arcsin (S / R)) = Real.sqrt (1 - (S / R) ^ 2) := by rw [Real.cos_arcsin] rw [h1, h2] have h29 : Real.sqrt (1 - (S / R) ^ 2) = - (C / R) := by have h301 : (C / R) ^ 2 = 1 - (S / R) ^ 2 := by linarith [h9] have h311 : Real.sqrt (1 - (S / R) ^ 2) = Real.sqrt ((C / R) ^ 2) := by rw [show 1 - (S / R) ^ 2 = (C / R) ^ 2 by linarith [h9]] rw [h311] have h321 : Real.sqrt ((C / R) ^ 2) = - (C / R) := by have h331 : C / R &lt; 0 := hC3 have : Real.sqrt ((C / R) ^ 2) = - (C / R) := by rw [Real.sqrt_sq_eq_abs] rw [abs_of_neg h331] linarith linarith rw [h28, h29] all_goals nlinarith · -- Show sin (π - arcsin (S / R)) = S / R have h30 : Real.sin (Real.pi - Real.arcsin (S / R)) = Real.sin (Real.arcsin (S / R)) := by rw [Real.sin_pi_sub] have h31 : Real.sin (Real.arcsin (S / R)) = S / R := by have h20 : -1 ≤ S / R := by have h6 : (S / R) ^ 2 ≤ 1 := by nlinarith [h9] nlinarith [sq_nonneg (S / R - 1), sq_nonneg (S / R + 1)] have h21 : S / R ≤ 1 := by have h6 : (S / R) ^ 2 ≤ 1 := by nlinarith [h9] nlinarith [sq_nonneg (S / R - 1), sq_nonneg (S / R + 1)] apply Real.sin_arcsin all_goals linarith rw [h30, h31] rcases h13 with ⟨α, h14, h15⟩ use R, α constructor · -- Show R &gt; 0 linarith · -- Show ∀ x : ℝ, C * cos x - S * sin x = R * cos (x + α) intro x have h21 : Real.cos (x + α) = Real.cos x * Real.cos α - Real.sin x * Real.sin α := by rw [Real.cos_add] have h22 : Real.cos α = C / R := by linarith [h14] have h23 : Real.sin α = S / R := by linarith [h15] calc C * Real.cos x - S * Real.sin x = R * (Real.cos x * (C / R) - Real.sin x * (S / R)) := by field_simp [show R ≠ 0 by linarith] all_goals ring _ = R * (Real.cos x * Real.cos α - Real.sin x * Real.sin α) := by rw [show Real.cos α = C / R by linarith [h14], show Real.sin α = S / R by linarith [h15]] _ = R * Real.cos (x + α) := by rw [h21] theorem sum_cos_div_two_pow_eq_mul_cos (N : ℕ) (a : ℕ → ℝ) (hN : N &gt; 0) : ∃ R0 α : ℝ, R0 &gt; 0 ∧ ∀ x : ℝ, ∑ j : Fin N, Real.cos (a j + x) / 2 ^ j.1 = (R0 : ℝ) * Real.cos (x + α) := by have h2 : ((∑ j : Fin N, Real.cos (a j) / 2 ^ (j : ℕ)) ^ 2 + (∑ j : Fin N, Real.sin (a j) / 2 ^ (j : ℕ)) ^ 2) &gt; 0 := by apply sum_cexp_div_pow_ne_zero (by omega) (fun j : Fin N =&gt; a j) have h4 : (∑ j : Fin N, Real.cos (a j) / 2 ^ (j : ℕ)) ^ 2 + (∑ j : Fin N, Real.sin (a j) / 2 ^ (j : ℕ)) ^ 2 ≠ 0 := by linarith have h5 : ∃ R α : ℝ, R &gt; 0 ∧ ∀ x : ℝ, (∑ j : Fin N, Real.cos (a j) / 2 ^ (j : ℕ)) * Real.cos x - (∑ j : Fin N, Real.sin (a j) / 2 ^ (j : ℕ)) * Real.sin x = R * Real.cos (x + α) := by apply mul_cos_sub_mul_sin_eq_mul_cos_add (∑ j : Fin N, Real.cos (a j) / 2 ^ (j : ℕ)) (∑ j : Fin N, Real.sin (a j) / 2 ^ (j : ℕ)) (by exact h4 ) rcases h5 with ⟨R0, α, hR0_pos, h_eq⟩ use R0, α constructor . exact hR0_pos . intro x have h_eq2 : ∑ j : Fin N, Real.cos (a j + x) / 2 ^ j.1 = (∑ j : Fin N, Real.cos (a j) / 2 ^ (j : ℕ)) * Real.cos x - (∑ j : Fin N, Real.sin (a j) / 2 ^ (j : ℕ)) * Real.sin x := by have h8 : ∀ j : Fin N, Real.cos (a j + x) / (2 : ℝ) ^ (j : ℕ) = (Real.cos (a j) * Real.cos x - Real.sin (a j) * Real.sin x) / (2 : ℝ) ^ (j : ℕ) := by intro j have h9 : Real.cos (a j + x) = Real.cos (a j) * Real.cos x - Real.sin (a j) * Real.sin x := by rw [Real.cos_add] rw [h9] have h10 : ∑ j : Fin N, Real.cos (a j + x) / 2 ^ j.1 = ∑ j : Fin N, ((Real.cos (a j) * Real.cos x - Real.sin (a j) * Real.sin x) / (2 : ℝ) ^ (j : ℕ)) := by apply Finset.sum_congr . rfl . intro j hj have h9 : Real.cos (a j + x) / (2 : ℝ) ^ (j : ℕ) = (Real.cos (a j) * Real.cos x - Real.sin (a j) * Real.sin x) / (2 : ℝ) ^ (j : ℕ) := h8 j simpa using h9 rw [h10] have h11 : ∑ j : Fin N, ((Real.cos (a j) * Real.cos x - Real.sin (a j) * Real.sin x) / (2 : ℝ) ^ (j : ℕ)) = (∑ j : Fin N, Real.cos (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.cos x - (∑ j : Fin N, Real.sin (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.sin x := by have h12 : ∀ j : Fin N, ((Real.cos (a j) * Real.cos x - Real.sin (a j) * Real.sin x) / (2 : ℝ) ^ (j : ℕ)) = (Real.cos (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.cos x - (Real.sin (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.sin x := by intro j ring_nf calc ∑ j : Fin N, ((Real.cos (a j) * Real.cos x - Real.sin (a j) * Real.sin x) / (2 : ℝ) ^ (j : ℕ)) = ∑ j : Fin N, ((Real.cos (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.cos x - (Real.sin (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.sin x) := by apply Finset.sum_congr . rfl . intro j hj specialize h12 j linarith _ = (∑ j : Fin N, (Real.cos (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.cos x) - (∑ j : Fin N, (Real.sin (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.sin x) := by rw [Finset.sum_sub_distrib] _ = (∑ j : Fin N, Real.cos (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.cos x - (∑ j : Fin N, Real.sin (a j) / (2 : ℝ) ^ (j : ℕ)) * Real.sin x := by rw [Finset.sum_mul, Finset.sum_mul] exact h11 rw [h_eq2] specialize h_eq x linarith open Real Set in
theorem sub_eq_int_mul_pi_of_cos_eq_zero : ∀ (θ₁ θ₂ : ℝ), cos θ₁ = 0 → cos θ₂ = 0 → ∃ m : ℤ, θ₂ - θ₁ = m * π := by intro θ₁ θ₂ h₁ h₂ have h1 : ∃ k : ℤ, θ₁ = Real.pi / 2 + k * Real.pi := by rw [Real.cos_eq_zero_iff] at h₁ rcases h₁ with ⟨k, hk⟩ use k linarith rcases h1 with ⟨k, hk1⟩ have h2 : ∃ l : ℤ, θ₂ = Real.pi / 2 + l * Real.pi := by rw [Real.cos_eq_zero_iff] at h₂ rcases h₂ with ⟨l, hl⟩ use l linarith rcases h2 with ⟨l, hl2⟩ use l - k rw [hl2, hk1] field_simp at * &lt;;&gt; ring_nf &lt;;&gt; norm_num open BigOperators Real Nat Topology Rat in
theorem imo_1969_p2 (m n : ℝ) (k : ℕ) (a : ℕ → ℝ) (y : ℝ → ℝ) (h₀ : 0 &lt; k) (h₁ : ∀ x, y x = ∑ i in Finset.range k, Real.cos (a i + x) / 2 ^ i) (h₂ : y m = 0) (h₃ : y n = 0) : ∃ t : ℤ, m - n = t * Real.pi := by have h4 : y m = ∑ i in Finset.range k, Real.cos (a i + m) / 2 ^ i := by specialize h₁ m simpa using h₁ have h5 : y n = ∑ i in Finset.range k, Real.cos (a i + n) / 2 ^ i := by specialize h₁ n simpa using h₁ rw [h4] at h₂ rw [h5] at h₃ have h9 : ∃ R0 α : ℝ, R0 &gt; 0 ∧ ∀ x : ℝ, ∑ j : Fin k, Real.cos (a j + x) / 2 ^ j.1 = R0 * Real.cos (x + α) := by apply sum_cos_div_two_pow_eq_mul_cos k (fun (j : ℕ) =&gt; a j) (by omega) rcases h9 with ⟨R0, α, hR0, h_eq3⟩ have h10 : ∑ i in Finset.range k, Real.cos (a i + m) / 2 ^ i = R0 * Real.cos (m + α) := by have h11 : ∑ i in Finset.range k, Real.cos (a i + m) / 2 ^ i = ∑ j : Fin k, Real.cos (a j + m) / 2 ^ j.1 := by simp [Finset.sum_range] rw [h11] specialize h_eq3 m simpa using h_eq3 have h11 : ∑ i in Finset.range k, Real.cos (a i + n) / 2 ^ i = R0 * Real.cos (n + α) := by have h12 : ∑ i in Finset.range k, Real.cos (a i + n) / 2 ^ i = ∑ j : Fin k, Real.cos (a j + n) / 2 ^ j.1 := by simp [Finset.sum_range] rw [h12] specialize h_eq3 n simpa using h_eq3 have h10' : R0 * Real.cos (m + α) = 0 := by have h_eq10 : ∑ i in Finset.range k, Real.cos (a i + m) / 2 ^ i = 0 := by linarith [h₂, h10] linarith [h10, h_eq10] have h11' : R0 * Real.cos (n + α) = 0 := by have h_eq11 : ∑ i in Finset.range k, Real.cos (a i + n) / 2 ^ i = 0 := by linarith [h₃, h11] linarith [h11, h_eq11] have h12 : Real.cos (m + α) = 0 := by apply (mul_left_inj' (ne_of_gt hR0)).mp linarith have h13 : Real.cos (n + α) = 0 := by apply (mul_left_inj' (ne_of_gt hR0)).mp linarith have h14 : ∃ m1 : ℤ, (n + α) - (m + α) = m1 * Real.pi := by apply sub_eq_int_mul_pi_of_cos_eq_zero (m + α) (n + α) h12 h13 rcases h14 with ⟨m1, hm1⟩ use -m1 have hm4 : (m : ℝ) - (n : ℝ) = - (m1 * Real.pi) := by have hm3 : (n + α : ℝ) - (m + α : ℝ) = (m1 : ℝ) * Real.pi := by linarith [hm1] nlinarith have hm5 : (-m1 : ℤ) * Real.pi = - (m1 * Real.pi) := by simp rw [hm5] linarith [hm4]
</code></pre> <h3> <a href="#error-fixing-example"> </a> <span> Error fixing example </span>
</h3>
<p> In the following example, the initial proof timed out because directly applying <code>simp</code> to <code>((Real.sqrt 3 / 2 : ℂ) + (1 / 2) * Complex.I) ^ 12</code> resulted in excessive search complexity. Breaking down the proof by step-by-step calculating intermediate powers like $z^3$, then $z^6$, and finally $z^{12}$ significantly reduced the computational burden on the compiler.</p> Sample proof of Error fixing <h2> <a href="#proof-before-error-fixing"> </a> <span> Proof before error fixing </span>
</h2>
<pre><code>import Mathlib theorem algebra_299086 {z : ℂ} (hz : z = (Real.sqrt 3 / 2) + (1 / 2) * .I) : z ^ 2016 = 1 := by have h1 : z = (Real.sqrt 3 / 2) + (1 / 2) * Complex.I := hz -- Prove z^12 = 1 have h2 : z ^ 12 = 1 := by rw [h1] have h3 : ((Real.sqrt 3 / 2 : ℂ) + (1 / 2) * Complex.I) ^ 12 = 1 := by simp [pow_succ, pow_zero, Complex.ext_iff, Complex.I_mul_I, mul_add, add_mul, mul_comm, mul_assoc, pow_two, pow_three, pow_succ, Real.sqrt_sq] field_simp [Complex.ext_iff, mul_add, add_mul, pow_two, pow_three] &lt;;&gt; ring_nf &lt;;&gt; norm_num [Real.sqrt_sq] exact h3 calc z ^ 2016 = (z ^ 12) ^ 168 := by ring _ = 1 ^ 168 := by rw [h2] _ = 1 := by norm_num
</code></pre>
<h2> <a href="#error-message"> </a> <span> Error message </span>
</h2>
<pre><code>Error message: Lean process timed out
</code></pre>
<h2> <a href="#proof-after-error-fixing"> </a> <span> Proof after error fixing </span>
</h2>
<pre><code>import Mathlib theorem algebra_299086 {z : ℂ} (hz : z = (Real.sqrt 3 / 2) + (1 / 2) * .I) : z ^ 2016 = 1 := by have h1 : z = (Real.sqrt 3 / 2) + (1 / 2) * Complex.I := by exact_mod_cast hz have h2 : z ^ 3 = Complex.I := by rw [h1] simp [pow_three, Complex.ext_iff, Complex.add_re, Complex.add_im, Complex.mul_re, Complex.mul_im, mul_add, add_mul, pow_two, mul_comm, mul_assoc] field_simp &lt;;&gt; ring_nf &lt;;&gt; norm_num have h3 : z ^ 6 = -1 := by calc z ^ 6 = (z ^ 3) ^ 2 := by ring _ = Complex.I ^ 2 := by rw [h2] _ = -1 := by simp [Complex.I_sq] have h4 : z ^ 12 = 1 := by calc z ^ 12 = (z ^ 6) ^ 2 := by ring _ = (-1) ^ 2 := by rw [h3] _ = 1 := by norm_num calc z ^ 2016 = (z ^ 12) ^ 168 := by ring_nf _ = (1) ^ 168 := by rw [h4] _ = 1 := by norm_num
</code></pre> <br> <h2> <a href="#citation"> </a> <span> Citation </span>
</h2>
<p>If you'd like to cite Kimina-Prover, please feel free to reference our preview paper for now. A full paper is currently in preparation and will be available soon.</p>
<pre><code>@article{kimina_prover_2025, title = {Kimina-Prover Preview: Towards Large Formal Reasoning Models with Reinforcement Learning}, author = {Wang, Haiming and Unsal, Mert and Lin, Xiaohan and Baksys, Mantas and Liu, Junqi and Santos, Marco Dos and Sung, Flood and Vinyes, Marina and Ying, Zhenzhe and Zhu, Zekai and Lu, Jianqiao and Saxcé, Hugues de and Bailey, Bolton and Song, Chendong and Xiao, Chenjun and Zhang, Dehao and Zhang, Ebony and Pu, Frederick and Zhu, Han and Liu, Jiawei and Bayer, Jonas and Michel, Julien and Yu, Longhui and Dreyfus-Schmidt, Léo and Tunstall, Lewis and Pagani, Luigi and Machado, Moreira and Bourigault, Pauline and Wang, Ran and Polu, Stanislas and Barroyer, Thibaut and Li, Wen-Ding and Niu, Yazhe and Fleureau, Yann and Hu, Yangyang and Yu, Zhouliang and Wang, Zihan and Yang, Zhilin and Liu, Zhengying and Li, Jia}, year = {2025}, url = {http://arxiv.org/abs/2504.11354},
}
</code></pre>
<h2> <a href="#references"> </a> <span> References </span>
</h2>
<p><a>[1]</a>Team, Kimi, et al. "Kimi k1. 5: Scaling reinforcement learning with llms." arXiv preprint arXiv:2501.12599 (2025).</p>
<p><a>[2]</a>Qwen, et al. "Qwen2.5 Technical Report" arXiv preprint arXiv:2412.15115 (2024).</p>
<p><a>[3]</a>Yang, An, et al. "Qwen3 technical report." arXiv preprint arXiv:2505.09388 (2025).</p>
<p><a>[4]</a><a href="https://deepmind.google/discover/blog/ai-solves-imo-problems-at-silver-medal-level/">https://deepmind.google/discover/blog/ai-solves-imo-problems-at-silver-medal-level/</a></p>
<p><a>[5]</a>Ren, Z. Z., et al. "Deepseek-prover-v2: Advancing formal mathematical reasoning via reinforcement learning for subgoal decomposition." arXiv preprint arXiv:2504.21801 (2025).</p>
<p><a>[6]</a>Cao, Chenrui, et al. "Reviving DSP for Advanced Theorem Proving in the Era of Reasoning Models." arXiv preprint arXiv:2506.11487 (2025).</p>
<p><a>[7]</a>Wang, Haiming, et al. "Kimina-prover preview: Towards large formal reasoning models with reinforcement learning." arXiv preprint arXiv:2504.11354 (2025).</p>
<p><a>[8]</a><a href="https://assets.anthropic.com/m/785e231869ea8b3b/original/claude-3-7-sonnet-system-card.pdf">https://assets.anthropic.com/m/785e231869ea8b3b/original/claude-3-7-sonnet-system-card.pdf</a></p>
<p><a>[9]</a>Li, Jia, et al. "Numinamath: The largest public dataset in ai4maths with 860k pairs of competition math problems and solutions." Hugging Face repository 13 (2024): 9.</p>
<p><a>[10]</a>Liu, Junqi, et al. "CombiBench: Benchmarking LLM capability for combinatorial mathematics." arXiv preprint arXiv:2505.03171 (2025).</p>
</div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>