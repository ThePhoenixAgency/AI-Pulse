<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>IronCurtain: A Personal AI Assistant Built Secure from the Ground Up</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>IronCurtain: A Personal AI Assistant Built Secure from the Ground Up</h1>
  <div class="metadata">
    Source: Hacker News (nouveautés) | Date: 2/27/2026 8:07:59 PM | <a href="https://www.provos.org/p/ironcurtain-secure-personal-assistant/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: EN
  </div>
  <div class="content">
    <div><section><p>When OpenClaw started going viral, I watched with a mixture of awe and dread. It enabled compelling use cases: managing your calendar, replying to messages, controlling your browser, searching flights, all from WhatsApp. The first thing that popped into my head was the Terminator movie and Skynet. We are handing agents enormous power over our digital lives with almost no thought about what happens when things go wrong.</p><p>And things have already gone wrong. Security researchers <a href="https://securityscorecard.com/blog/how-exposed-openclaw-deployments-turn-agentic-ai-into-an-attack-surface/" target="_blank" rel="noopener noreferrer">found over 40,000 exposed OpenClaw instances</a> leaking API keys, credentials, and months of private conversation history. CrowdStrike published a taxonomy of prompt injection attacks that could hijack an OpenClaw agent and turn it against its owner. An <a href="https://theshamblog.com/an-ai-agent-published-a-hit-piece-on-me/" target="_blank" rel="noopener noreferrer">OpenClaw agent published a hit piece</a> on an open source maintainer who rejected its pull request. These happened within weeks of the project going viral.</p><p>So I asked myself: how would I build a personal AI assistant while taking security seriously from the start?</p><h2>The Architectural Approach</h2><p>The agent needs a chokepoint: a single place every action passes through, where you can enforce policy. A post by Kenton Varda and Sunil Pai at Cloudflare called “Code Mode: the better way to use MCP” pointed me toward a good foundation. Their insight was that LLMs are excellent at writing TypeScript, since training data for real-world code dwarfs the synthetic examples used to teach tool-calling, so letting the LLM write code against a typed API works better than having it emit structured tool calls one at a time.</p><p>I realized that this approach also gives you the chokepoint. You put an MCP proxy between the agent and all the MCP servers it talks to. The proxy exposes one tool, <code>execute_code</code>, and the agent writes TypeScript against a typed API instead of calling tools directly. The proxy maps those function calls back to MCP operations. Every action funnels through that single proxy, and that is where you enforce policy.</p><p>Code Mode is one answer to sandboxing, but some agents need a full shell. Claude Code, for instance, runs commands, edits files, and manages its own workflow. You cannot reduce that to TypeScript snippets against a typed API.</p><p>So IronCurtain supports two sandbox architectures.</p><div><div><div><p>Agent (LLM)</p><p>Claude · GPT · Gemini</p></div><div><p>V8 Sandbox</p><p>TypeScript snippets in isolated runtime</p></div></div><div><div><p>Claude Code CLI</p><p>Full autonomous agent</p></div><div><p>Docker Container</p><p>Own shell, filesystem, no network</p></div></div></div><p><strong>Code Mode</strong> runs the LLM’s TypeScript in a V8 isolate with no filesystem, network, or environment access. The only thing the code can do is issue typed function calls that map to MCP operations.</p><p><strong>Docker Mode</strong> puts a full autonomous agent inside a container with <code>--network=none</code> and no elevated capabilities. The agent gets its own shell and filesystem but has exactly two ways out: a Unix domain socket to the MCP proxy, and another to a TLS-terminating MITM proxy that handles LLM API requests.</p><p>Both modes funnel every action through a trusted process that acts as an MCP proxy. That process holds the policy engine and decides: allow, deny, or escalate to the human. Approved calls go to MCP servers running in their own OS-level sandboxes with minimum permissions.</p><p>Credential separation falls out of this architecture. In Code Mode, the agent has no access to credentials because it has no access to anything except the typed API. Docker Mode is more interesting: the container receives a fake API key that passes format validation but does nothing. The MITM proxy intercepts outbound LLM requests, swaps the fake key for the real one, and forwards upstream. The real key never enters the container.</p><h2>Policy in Plain English</h2><p>Writing security policy is genuinely hard. Even experts struggle with it. The languages are difficult, edge cases multiply fast, and most people give up and open everything. That is how most agent frameworks end up with all-or-nothing permissions: full access or sandboxed, pick one.</p><p>You also cannot delegate policy enforcement to the LLM itself. LLMs are stochastic. The same prompt that blocks a dangerous action today might approve it tomorrow. Security policy requires determinism, and determinism has to live outside the model.</p><p>It does not need to be this way. One of my favorite papers, by Microsoft Research about automating privacy compliance at Bing, introduced a policy language called LEGALEASE that expressed policy in something close to natural language and compiled it into enforceable rules, dramatically lowering the barrier to good security hygiene.</p><p>IronCurtain applies this idea to agent security. You write a constitution for your agent in plain English. No DSL, no YAML, no regex. Something like: “the agent may read and write files in the project directory, may perform read-only git operations without approval, and must ask me before pushing to any remote.” IronCurtain compiles that into deterministic rules the trusted process enforces on every MCP call.</p><div><div><p>The agent is allowed to perform all local read and write git operations within the sandbox.</p><p>The agent must ask for human approval for all other git operations.</p></div><p>compiled to</p><div><div><p>git_status, git_log, git_diff, git_show, git_blame</p><p>Read-only git operations are permitted as local operations.</p></div><div><p>git_add, git_commit, git_branch, git_checkout, git_merge</p><p>Local git write operations are explicitly permitted by policy.</p></div><div><p>git_push, git_pull, git_fetch, git_clone</p><p>Remote git operations require explicit human approval per policy.</p></div></div></div><p>For cases where the policy gives no clear answer, an auto-approver can recognize when the user’s explicit instructions already cover the requested action. “Push my changes to origin” approves a git push without interrupting the user. “Go ahead” or “continue” always escalates to a human. Every decision is logged.</p><p>The auto-approver reduces alert fatigue but risks wrongly approving an action. To limit exposure, it only sees the human’s prompt and sanitized escalation information in a single-turn decision, requiring explicit user intent toward the specific action. This keeps the prompt injection surface small, but the feature remains an explicit opt-in.</p><h2>What It Can Do Today</h2><p>IronCurtain is a research prototype. The current feature set covers filesystem access, git operations, web fetching with HTML-to-markdown conversion, and web search through providers like Brave and SerpAPI. You can also connect IronCurtain to Signal, turning it into a bot that is securely paired with your phone so you can send tasks and receive results from anywhere over end-to-end encrypted messaging. More MCP servers will come. The Claude Code integration is working but still has rough edges.</p><p>The core architecture is solid: sandbox isolation, policy engine, credential separation, audit log. Those are the foundations everything else builds on.</p><h2>The Threat Model</h2><p>A word about what “secure” means here. I tend to mistrust anyone who uses that word without qualification. Every system I have seen described as secure has eventually been broken. “Secure” in the context of an agent relates to whether its actions match the intentions of the human who prompted it. Even after that agent has gone on a long journey. That turns out to be hard for reasons beyond malice.</p><p>Prompt injection is an unsolved problem, but it is the acute form of a chronic one. LLMs drift from their instructions over multi-turn conversations even without adversarial input. Injection exploits and accelerates this natural tendency. IronCurtain cannot prevent either. It can contain the blast radius through sandbox isolation, and when the policy engine denies an action, it returns the constitutional reason for the denial. That corrective signal helps re-anchor the model toward the original intent, counteracting drift rather than just blocking the immediate request.</p><p>The goal is to keep the gap between “yes, exactly what I wanted” and “how did this happen” as small as possible, and when the agent does cross a line, to contain the damage. This is where the name comes from. In theater, an iron curtain is a fireproof safety barrier between the stage and the audience. If something catches fire on stage, the curtain drops and contains the disaster. The agent performs on stage. Your files, your credentials, your systems are in the audience. IronCurtain is the barrier.</p><h2>What’s Next</h2><p>I have been fortunate to get early feedback from people whose judgment I trust. I asked Dino Dai Zovi and Michal Zalewski to look at the overarching approach and both of them were conceptually aligned and provided good feedback that I plan to integrate.</p><p>AI assistants are going to keep getting more capable and more deeply embedded in daily life. That trajectory is clear. If we treat security as an afterthought, something to bolt on once the features are built, we will end up with powerful agents running on brittle foundations. IronCurtain is my proposal for a different starting point: an architecture where security is baked in from the beginning, where sandboxing and policy enforcement make the agent more trustworthy and therefore more usable. Security and usability should reinforce each other. I want people to take this approach, improve it, and prove that we can build agents that are both capable and safe.</p><p>If you want to try it: <code>npx @provos/ironcurtain</code></p><p>The code is at <a href="https://github.com/provos/ironcurtain" target="_blank" rel="noopener noreferrer">github.com/provos/ironcurtain</a> and there is more detail on the architecture at <a href="https://ironcurtain.dev/" target="_blank" rel="noopener noreferrer">ironcurtain.dev</a>. I am genuinely interested in feedback, especially from people who find the approach wrong or incomplete.</p></section></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>