<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Pourquoi Rails est devenu, par accident, le framework parfait pour l'IA</title>
<style>
  body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; line-height: 1.55; color: #e2e8f0; max-width: 800px; margin: 26px auto; padding: 0 18px; background: #0a0e27; }
  h1 { color: #00d9ff; margin-bottom: 0.35em; line-height: 1.22; font-size: clamp(1.45rem, 2.1vw, 1.95rem); font-weight: 700; }
  h2, h3 { line-height: 1.28; margin: 1.1em 0 0.45em; }
  .metadata { color: #94a3b8; font-size: 0.86em; margin-bottom: 1.2em; border-bottom: 1px solid rgba(0,217,255,0.2); padding-bottom: 0.7em; }
  img { max-width: 100%; width: auto !important; height: auto !important; object-fit: contain !important; border-radius: 8px; display: block; margin: 0.6em auto; }
  a { color: #00d9ff; }
  p { margin-bottom: 0.72em; line-height: 1.58; }
  ul, ol { margin: 0.5em 0 0.9em 1.1em; }
  li { margin: 0.18em 0; }
  blockquote { border-left: 3px solid #825ee4; padding-left: 12px; margin: 0.8em 0; color: #94a3b8; }
  code { background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 3px; color: #ff79c6; }
  pre { background: rgba(0,0,0,0.4); padding: 12px; border-radius: 6px; overflow-x: auto; }
  .article-elevator { position: fixed; right: 14px; bottom: 14px; display: flex; flex-direction: column; gap: 8px; z-index: 9999; }
  .article-elevator-btn { width: 36px; height: 36px; border: 1px solid rgba(0,217,255,0.35); border-radius: 10px; background: rgba(10,14,39,0.88); color: #00d9ff; cursor: pointer; font-size: 16px; line-height: 1; }
  .article-elevator-btn:hover { background: rgba(10,14,39,1); }
  [id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"],
  [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"],
  [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"] {
    display: none !important;
    visibility: hidden !important;
    pointer-events: none !important;
  }
</style>
</head>
<body>
  <h1>Pourquoi Rails est devenu, par accident, le framework parfait pour l'IA</h1>
  <div class="metadata">
    Source: Journal du Hacker | Date: 2/25/2026 8:41:29 AM | <a href="https://michaelbensoussan.com/posts/rails-llm-friendly/" target="_blank" rel="noopener noreferrer">Lien</a> | Lang: FR
  </div>
  <div class="content">
    <div><div><p>L’autre soir, j’ai demandé à Claude Code d’ajouter un champ au modèle Politician de <a href="https://touslesmemes.fr/">touslesmemes.fr</a>, un quiz politique que je construis seul depuis quelques mois. La machine a touché le modèle, créé la migration, mis à jour les vues admin, corrigé les tests. Sans que je lui explique où était quoi. Sans que je lui dessine l’architecture.</p><p>Je me suis levé pour me faire un café.</p><p>En revenant, le diff était propre. Et je me suis demandé si j’avais encore <em>codé</em> quoi que ce soit ce soir-là, ou si j’avais simplement <em>supervisé</em>.</p><hr><p>Ce qui s’est passé, techniquement, c’est que la machine connaissait le sentier. <code>app/models/</code>, <code>app/controllers/</code>, <code>app/views/</code>, <code>db/schema.rb</code>. Tous les projets Rails du monde sont organisés pareil. Un projet de 2015 et un de 2026 se ressemblent. La machine a vu des milliers de codebases Rails dans son <em>training data</em>, et elles suivent toutes les mêmes conventions.</p><p>C’est la force du <em>Convention over Configuration</em>. Le LLM n’a pas besoin d’apprendre l’architecture de <em>ton</em> projet. Il la connaît déjà.</p><p>Et il y a <code>schema.rb</code>. Un seul fichier, auto-généré, qui décrit toutes les tables, colonnes et index. La machine le lit et comprend 100% du modèle de données. Là où d’autres stacks éparpillent la vérité sur la structure dans une galaxie de fichiers d’interfaces, Rails centralise tout dans un sentier unique.</p><p>Simon Willison a proposé le terme <em>vibe engineering</em> pour distinguer l’usage professionnel de ces outils du <em>vibe coding</em> :</p><div><blockquote><p>AI tools amplify existing expertise. The more skills and experience you have as a software engineer the faster and better the results you can get.</p><p>— Simon Willison, <a href="https://simonwillison.net/2025/Oct/7/vibe-engineering/"><em>Vibe engineering</em></a></p></blockquote></div><p><em>Amplify existing expertise.</em> Les conventions de Rails sont justement une forme d’expertise collective déjà encodée. Des milliers de développeur·ices qui ont convergé, sur des années, par friction et consensus, vers les mêmes chemins. La machine amplifie ça. Elle amplifie le fait que tout le monde a rangé ses modèles au même endroit.</p><p>Ruby a été pensé pour coller au langage naturel. Matz voulait un langage pour les humains d’abord. Résultat, le code se lit presque comme de la prose :</p><div><pre><code><span><span><span>class</span> <span>Politician</span> <span>&lt;</span> <span>ApplicationRecord</span>
</span></span><span><span> has_many <span>:quotes</span><span>,</span> <span>dependent</span><span>:</span> <span>:destroy</span>
</span></span><span><span>
</span></span><span><span> enum <span>:status</span><span>,</span> <span>{</span> <span>draft</span><span>:</span> <span>0</span><span>,</span> <span>published</span><span>:</span> <span>1</span> <span>},</span> <span>default</span><span>:</span> <span>:draft</span>
</span></span><span><span> enum <span>:ideology</span><span>,</span> <span>{</span> <span>far_left</span><span>:</span> <span>0</span><span>,</span> <span>left</span><span>:</span> <span>1</span><span>,</span> <span>center</span><span>:</span> <span>2</span><span>,</span> <span>right</span><span>:</span> <span>3</span><span>,</span> <span>far_right</span><span>:</span> <span>4</span> <span>}</span>
</span></span><span><span>
</span></span><span><span> validates <span>:name</span><span>,</span> <span>presence</span><span>:</span> <span>true</span>
</span></span><span><span> validates <span>:slug</span><span>,</span> <span>presence</span><span>:</span> <span>true</span><span>,</span> <span>uniqueness</span><span>:</span> <span>true</span>
</span></span><span><span><span>end</span>
</span></span></code></pre></div><p><code>has_many :quotes</code>. <code>validates :name, presence: true</code>. C’est déclaratif. C’est dense. La machine génère ça correctement du premier coup 9 fois sur 10. Elle a vu des millions d’exemples identiques, et il y a peu d’espace pour halluciner quand la syntaxe ne laisse pas de place au doute.</p><p>Moins de tokens pour décrire la même logique, c’est moins de risques que la machine perde le fil. Plus de signal, moins de bruit. Un ratio qui compte quand la fenêtre de contexte est ta ressource la plus précieuse.</p><p>(Et mon fichier <code>CLAUDE.md</code> ? Il ne documente que la logique métier. Pas l’architecture. Rails l’a déjà fait.)</p><hr><p>Avec Hotwire (Turbo + Stimulus), toute l’interactivité tient côté serveur. Le serveur renvoie un fragment HTML qui remplace un bout de page. Pas de JSON, de sérialisation, de <em>state management</em> côté client. La machine ne fait pas d’erreurs de state. Parce qu’il n’y en a pas.</p><p>C’est de la cuisine maison. Un plat, une assiette, pas de chaîne d’intermédiation. Rails 8 avec Propshaft et Importmap bypasse complètement Node.js. Cinq lignes de config pour tout le JavaScript. Moins il y a de config, moins il y a de casse.</p><hr><p>Coder 80% d’un projet avec un LLM. Le <em>One-Person Framework</em> tient sa promesse : une seule personne qui gère front, back, base de données, infra. Du <em>VibeArtisanat</em>, en quelque sorte. Ça marche. Ça ship. Mais qu’est-ce que je maîtrise encore, en tant qu’artisan·e, exactement ?</p><p>Charity Majors :</p><p>Et plus loin :</p><div><blockquote><p>Generating code that can compile, execute, and pass a test suite isn’t especially hard; the hard part is crafting a code base that many people, teams, and successive generations of teams can navigate, mutate, and reason about for years to come.</p><p>— Charity Majors, <a href="https://charity.wtf/2024/06/10/generative-ai-is-not-going-to-build-your-engineering-team-for-you/"><em>Generative AI is not going to build your engineering team for you</em></a></p></blockquote></div><p>La machine écrit le code. Mais qui <em>maintient</em> ? Qui comprend le pourquoi derrière le comment ? Mon <code>CLAUDE.md</code> sert de cerveau externalisé entre les sessions, mais c’est un cerveau qui ne retient que ce qu’on lui dit de retenir.</p><p>Je remarque que je lis les diffs de moins en moins attentivement. Que j’accepte des implémentations dont je comprends l’intention mais pas toujours le détail. Que parfois un test passe et je ne saurais pas expliquer exactement <em>pourquoi</em> il passe.</p><p>Je délègue ma compréhension. Chaque prompt est un petit pacte faustien : je ship plus vite, mais j’habite de moins en moins ma propre maison technique.</p><p>C’est là que ça me gratte. Pas dans l’abstraction, dans ces gestes-là.</p><p>Cassidy Williams a écrit quelque chose qui m’est resté en travers :</p><div><blockquote><p>There’s no ‘YAY I am a GENIUS because I FIGURED IT OUT’ feeling. […] Just watching the code being written instead of doing anything is like this era’s ‘watching paint dry’.</p><p>— Cassidy Williams, <a href="https://cassidoo.co/post/vibe-coding-yawn/"><em>Vibe coding is boring</em></a></p></blockquote></div><p>Et pourtant. Et pourtant on continue. Parce que le résultat est là, l’app tourne, les features sortent, le quiz fonctionne. Mais ce petit “YES” intérieur quand le test passe après une heure de debug, ce moment où tu comprends enfin pourquoi ça marchait pas. Ça, la machine ne te le donne pas.</p><hr><p>Rails bouge peu. Un <code>has_many</code>, un <code>before_action</code>, un <code>turbo_stream.replace</code>, ça fonctionne pareil en 2020 et en 2026. Les patterns n’ont pas bougé depuis des années, le code que génère la machine reste valide longtemps. Pas de mélange de versions, pas de paradigmes qui changent entre deux <em>minor releases</em>.</p><p>C’est un avantage concret pour le code assisté : la machine ne mélange pas Rails 7 et Rails 8 parce qu’il n’y a presque rien à mélanger. Avec d’autres stacks, le LLM génère du code pour la mauvaise API, le mauvais pattern, la mauvaise version du framework. Pas par incompétence, mais parce que les paradigmes changent souvent et que son <em>training data</em> contient toutes les versions en même temps.</p><p>Rester sur un sentier connu plutôt que courir après le dernier framework. Une forme de sagesse. Ou de paresse (probablement les deux).</p><p>Il y a un contre-argument légitime. Ruby n’a pas de types statiques. Si la machine se trompe, ça pète au runtime. Le refactoring à grande échelle, c’est <code>grep</code> et espoir. C’est réel.</p><p>Mais pour un projet solo assisté par la machine, la vitesse d’itération prime. La machine lit ta codebase entière en quelques secondes, elle n’a pas besoin du compilateur pour tracer les appels à travers les fichiers. Pour une équipe de 20 sur un monolithe, je comprendrais le choix inverse. Pour touslesmemes.fr, fait seul dans mon salon avec du café, je prends la vitesse.</p><p>La boucle de feedback par les tests compense une partie de ce manque. Tu décris le comportement attendu dans un test, la machine écrit le code qui passe. Rouge, vert, rouge, vert, en boucle fermée. Le test est devenu le langage dans lequel on parle à la machine.</p><p>Le test, c’est la laisse. Sans <code>rails test</code>, je ne pilote rien du tout, je regarde dériver.</p><hr><p>Simon Willison (encore lui) a résumé le truc :</p><div><blockquote><p>Managing a growing army of weird digital interns who will absolutely cheat if you give them a chance.</p><p>— Simon Willison, <a href="https://simonwillison.net/2025/Oct/7/vibe-engineering/"><em>Vibe engineering</em></a></p></blockquote></div><p>Des stagiaires numériques bizarres qui tricheront si on leur en donne l’occasion. </p><p>Le résultat chez moi : <a href="https://touslesmemes.fr/">touslesmemes.fr</a>. Design, algorithme de scoring, back-office, pipeline de sourcing de citations, le tout fait en solo avec Claude Code et Rails 8. Et cette question qui revient, chaque soir où je lance un prompt au lieu d’ouvrir un fichier. Pendant combien de temps est-ce qu’on continue à appeler ça <em>coder</em> ?</p></div></div>
  </div>
  <div class="article-elevator" aria-label="Navigation article">
    <button class="article-elevator-btn" type="button" onclick="scrollToTop()">▲</button>
    <button class="article-elevator-btn" type="button" onclick="scrollToBottom()">▼</button>
  </div>
  <script>
    function stripBlockingPanels() {
      const selector = '[id*="overlay"], [class*="overlay"], [id*="modal"], [class*="modal"], [id*="popup"], [class*="popup"], [id*="paywall"], [class*="paywall"], [id*="subscribe"], [class*="subscribe"], [id*="cookie"], [class*="cookie"], [id*="consent"], [class*="consent"], [id*="gdpr"], [class*="gdpr"], [role="dialog"], [aria-modal="true"]';
      const textPattern = /\b(cookie|consent|gdpr|subscribe|subscription|paywall|abonnez[-\s]?vous|inscrivez[-\s]?vous|continue reading|continuez la lecture)\b/i;
      document.querySelectorAll(selector).forEach((node) => node.remove());
      document.querySelectorAll('div, section, aside').forEach((node) => {
        const styleAttr = String(node.getAttribute('style') || '').toLowerCase();
        const classAndId = String(node.className || '').toLowerCase() + ' ' + String(node.id || '').toLowerCase();
        const text = String(node.textContent || '').slice(0, 800);
        const hasKeyword = textPattern.test(classAndId) || textPattern.test(text);
        const looksFixed = /(position\s*:\s*(fixed|sticky)|inset\s*:|top\s*:|left\s*:|right\s*:|bottom\s*:)/.test(styleAttr);
        const hasPriority = /(z-index\s*:\s*[1-9]\d{1,}|backdrop-filter|overflow\s*:\s*hidden)/.test(styleAttr);
        if (hasKeyword && (looksFixed || hasPriority)) node.remove();
      });
    }
    function scrollToTop() {
      window.scrollTo({ top: 0, behavior: 'auto' });
    }
    function scrollToBottom() {
      window.scrollTo({ top: document.documentElement.scrollHeight, behavior: 'auto' });
    }
    window.addEventListener('message', (event) => {
      const data = event && event.data;
      if (!data || data.type !== 'AI_PULSE_SCROLL') return;
      if (data.direction === 'up' || data.direction === 'top') scrollToTop();
      if (data.direction === 'down' || data.direction === 'bottom') scrollToBottom();
    });
    stripBlockingPanels();
    setTimeout(stripBlockingPanels, 60);
    setTimeout(stripBlockingPanels, 220);
    setTimeout(stripBlockingPanels, 650);
  </script>
</body>
</html>